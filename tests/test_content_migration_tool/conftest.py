import http.server
import os
import shutil
import socketserver
import threading
from functools import partial
from time import sleep

import pytest
from wazuh_testing.tools.file import remove_file, write_json_file, truncate_file
from wazuh_testing.tools.logging import Logging
from wazuh_testing.cmt import LOG_FILE_PATH
from wazuh_testing.cmt.utils import clean_cmt_output_files, drop_cmt_tables

logger = Logging('cmt')


@pytest.fixture(scope='session', autouse=True)
def setup_feed_server():
    """Setup an HTTP server that run in a daemon thread.
    """
    hostname = 'localhost'
    server_port = 8888
    server_directory = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
    handler = partial(http.server.SimpleHTTPRequestHandler, directory=server_directory)
    # Disable auto bind and activate
    httpd = socketserver.TCPServer(server_address=(hostname, server_port), RequestHandlerClass=handler,
                                   bind_and_activate=False)
    # Allow reuse address to allow binding
    httpd.allow_reuse_address = True
    httpd.server_bind()
    httpd.server_activate()

    def _serve_forever(httpd):
        with httpd:
            logger.info(f"Serving at port {server_port}")
            httpd.serve_forever()

    # Start server on a separated thread
    # "(httpd, )" intentionally done to avoid module "threading" warning, due to expecting an iterable
    thread = threading.Thread(daemon=True, target=_serve_forever, args=(httpd, ))
    thread.start()
    # Wait for the server to fully initialize
    sleep(3)

    yield
    # After yield the server will stop abruptly because the main process will end


@pytest.fixture
def build_cmt_config_file(request, configuration):
    """Build N configuration files for the Content Migration Tool to run.

    Args:
        request (fixture): Provide information about the running test function.
        configuration (list): Test case configuration.
    """
    dest_paths = []
    for idx, config in enumerate(configuration['configurations']):
        file_path = os.path.join(request.module.CONFIGURATION_PATH, f"config_{idx}.json")
        dest_paths.append(file_path)
        write_json_file(file_path=file_path, data=config)

    yield dest_paths

    for file_path in dest_paths:
        remove_file(file_path)


@pytest.fixture
def clean_results():
    """Clean the output files generated by the tool, the tables created in the DB and the log.
    """
    def clean():
        truncate_file(LOG_FILE_PATH)
        clean_cmt_output_files()
        drop_cmt_tables()

    clean()

    yield

    clean()


@pytest.fixture
def prepare_alas_feed(request, metadata):
    '''The process of fetching feeds is different for ALAS.
    In the case of ALAS 1 and ALAS 2:
        - A plain file (mirror.list) is downloaded from the URL specified in the config file, that file contains a URL
        - The "/repodata/updateinfo.xml.gz" string is appended to the above-mentioned URL
        - The "updateinfo.xml.gz" is the file that contains the desired feed
    In the case of ALAS 2022:
        - An XML file, containing the release version of ALAS, is downloaded from the URL specified in the config file
        - The 'releasemd.xml' string in the previous URL is replaced by 'mirrors/<OBTAINED_VERSION>/x86_64/mirror.list'
        - The file 'mirror.list' is downloaded and it contains the URL from which the feed will be downloaded
        - The '/repodata/updateinfo.xml.gz' string is appended to the last URL
        - The "updateinfo.xml.gz" is the file that contains the desired feed

    This fixture copies the desired feed to the destination folder and then removes it.

    Args:
        metadata (dict): Test case metadata.
    '''
    alas_data_path = os.path.join(request.module.FEEDS_PATH, 'alas')
    repodata_path = os.path.join(alas_data_path, 'repodata')
    dest_path = os.path.join(repodata_path, 'updateinfo.xml.gz')

    if 'alas' in metadata['output_file']:
        src_path = os.path.join(alas_data_path, f"alas{metadata['alas_version']}_feed.xml.gz")
        shutil.copyfile(src_path, dest_path)

    yield

    if 'alas' in metadata['output_file']:
        remove_file(dest_path)
