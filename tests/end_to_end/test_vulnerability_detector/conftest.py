"""
Pytest configuration for Vulnerability Detector E2E testing

This module contains Pytest fixtures and configuration settings for Wazuh end-to-end testing.
It provides reusable fixtures and setup that can be shared across multiple test modules.

Functions:
    - `collect_e2e_environment_data`: Collect data from the environment for the test. For example, logs from the
        Wazuh components.
    - `collect_evidences`: Collect specific evidences for the test
    - `validate_environment`: Check if the environment is accessible

Fixtures:
    - `host_manager`: Fixture for creating a HostManager instance representing the Wazuh test environment.
    - `setup`: Fixture for running setup and teardown operations for the test.

Configuration Options:
    - `--inventory-path`: Path to the inventory file specifying the test environment hosts.

Constants:
    - `STYLE_PATH`: Path to the CSS stylesheet used by the HTML report.

Example:
    To use the `host_manager` fixture in your test module:

    ```python
    def test_example(host_manager):
        # Your test logic using the host_manager fixture
        pass
    ```
"""
import datetime
import time
import json
import logging
import os
import shutil
import uuid
import pytest

from numpydoc.docscrape import FunctionDoc
from py.xml import html
from typing import Dict, Generator

from wazuh_testing.end_to_end import VD_E2E_TIMEOUT_SYSCOLLECTOR_SCAN
from wazuh_testing.end_to_end.vulnerability_detector import PACKAGE_VULNERABILITY_SCAN_TIME
from wazuh_testing.end_to_end.check_validators import (
    compare_expected_found_vulnerabilities,
    compare_expected_found_vulnerabilities_alerts,
    get_failed_operation_hosts)
from wazuh_testing.end_to_end.configuration import (backup_configurations,
                                                    restore_configuration,
                                                    save_indexer_credentials_into_keystore)
from wazuh_testing.end_to_end.indexer_api import (
    get_wazuh_states_vulnerabilities_indexname, delete_index)
from wazuh_testing.end_to_end.logs import (get_hosts_alerts, get_hosts_logs,
                                           truncate_remote_host_group_files)
from wazuh_testing.end_to_end.remote_operations_handler import (
    filter_hosts_by_os, get_expected_alerts, get_expected_index,
    get_vulnerabilities_index, get_vulnerability_alerts,
    launch_parallel_operations)
from wazuh_testing.tools.system import HostManager

STYLE_PATH = os.path.join(os.path.dirname(__file__), '../../../deps/wazuh_testing/wazuh_testing/reporting/style.css')
gather_evidences_when_passed = True
enable_verbose_evidences = True

catalog = list()
results = dict()


@pytest.fixture(scope="module", autouse=True)
def install_npm(host_manager: HostManager):
    """Check and install npm if not already installed"""

    node_version = "v21.7.1"
    node_package_url = f"https://nodejs.org/dist/{node_version}/node-{node_version}.pkg"

    target_os_groups = ["macos"]

    for group in target_os_groups:
        for host in host_manager.get_group_hosts(group):
            # Check if Node and npm is installed
            logging.info(f"Checking and installing npm on {host}")
            node_check_command = "PATH=/usr/local/bin:$PATH && command -v node"
            node_check_result = host_manager.get_host(host).ansible(
                "shell",
                node_check_command,
                become=True,
                become_user="vagrant",
                check=False,
            )
            logging.info(f"Node check result on {host}: {node_check_result}")
            # Install node if it is not already installed.
            if node_check_result["rc"] != 0:
                logging.info(
                    f"Installing Node.js and npm using package: {node_package_url}"
                )

                # Use the install_package method to handle the installation.
                install_result = host_manager.install_package(
                    host, node_package_url, system="macos"
                )

                # Logging the result of installation attempt.
                logging.info(
                    f"Node.js and npm installation result on {host}: {install_result}"
                )
            else:
                logging.info("Node.js and npm are already installed.")


@pytest.fixture(scope="module")
def backup_configuration(host_manager: HostManager):
    hosts_configuration_backup = backup_configurations(host_manager)

    yield

    logging.error("Restoring original configuration")
    restore_configuration(host_manager, hosts_configuration_backup)

    logging.error("Restarting environment")

    host_manager.control_environment("restart", ["agent"], parallel=True)
    host_manager.control_environment("restart", ["manager"], parallel=True)


@pytest.fixture(scope="module")
def clean_environment_logs(host_manager: HostManager):
    """Clean Agents and Managers logs

    Args:
        host_manager: An instance of the HostManager class containing information about hosts.

    """
    yield

    logging.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, "all", "logs")


@pytest.fixture(scope="function")
def clean_environment_logs_function(host_manager: HostManager):
    """Clean Agents and Managers logs

    Args:
        host_manager: An instance of the HostManager class containing information about hosts.

    """
    yield

    logging.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, "all", "logs")


@pytest.fixture(scope="module")
def delete_states_vulnerability_index(host_manager: HostManager):
    """Delete vulnerability index

    Args:
        host_manager: An instance of the HostManager class containing information about hosts.
    """
    yield
    logging.error("Delete vulnerability index")

    cluster_name = host_manager.get_cluster_name()
    delete_index(host_manager, index=get_wazuh_states_vulnerabilities_indexname(cluster_name))


def collect_e2e_environment_data(logs_path, host_manager) -> None:
    """Collect data from the environment for the test

    Args:
        test_name: Name of the test
        host_manager: An instance of the HostManager class containing information about hosts.
    """
    logging.info("Collecting environment data")
    try:
        environment_logs = get_hosts_logs(host_manager)
        environment_alerts = get_hosts_alerts(host_manager)

        tests_evidences_directory = logs_path

        for host in environment_logs.keys():
            logging.info(f"Collecting logs for {host}")
            host_logs_name_evidence = host + "_ossec.log"
            evidence_log_file = os.path.join(tests_evidences_directory, host_logs_name_evidence)
            with open(evidence_log_file, 'w') as evidence_log_file:
                evidence_log_file.write(environment_logs[host])

        for host in environment_alerts.keys():
            logging.info(f"Collecting alerts for {host}")
            host_alerts_name_evidence = host + "_alert.json"
            evidence_alert_file = os.path.join(tests_evidences_directory, host_alerts_name_evidence)
            with open(evidence_alert_file, 'w') as evidence_alert_file:
                evidence_alert_file.write(environment_alerts[host])

            for host in environment_logs.keys():
                logging.info(f"Collecting logs for {host}")
                host_logs_name_evidence = host + "_ossec.log"
                evidence_file = os.path.join(logs_path, host_logs_name_evidence)
                with open(evidence_file, 'w') as evidence_file:
                    evidence_file.write(environment_logs[host])
    except Exception as e:
        logging.critical(f"Error collecting environment data: {e}")


def collect_evidences(test_name, evidences) -> None:
    """
    Collect specific evidences for the test

    Args:
        test_name: Name of the test
        evidences: Dictionary with the evidences to collect
    """
    current_dir = os.path.dirname(__file__)
    vulnerability_detector_logs_dir = os.path.join(current_dir, "logs")
    tests_evidences_directory = os.path.join(str(vulnerability_detector_logs_dir), str(test_name))
    logging.info(f"Collecting evidences for {test_name}")

    if evidences:
        logging.info(f"Collecting custom evidences for {test_name}")
        for evidence, content in evidences.items():
            logging.info(f"Collecting {evidence} for {test_name}")
            if content is not None and content != [] and content != {}:
                evidence_file = os.path.join(tests_evidences_directory, evidence + ".log")
                with open(evidence_file, 'w') as evidence_file:
                    if content.__class__ == dict:
                        try:
                            json.dump(content, evidence_file, indent=4)
                        except TypeError:
                            logging.critical(f"Error dumping {evidence} to file")
                    else:
                        evidence_file.write(str(content))


@pytest.fixture(scope='session')
def host_manager(request):
    """Fixture for creating a HostManager instance.

    This fixture initializes and provides a HostManager instance for testing purposes. The HostManager
    is set up at the session scope, ensuring it is created only once for the entire test suite.

    Args:
        request (FixtureRequest): The Pytest fixture request object.

    Returns:
        HostManager: An instance of the HostManager class representing the Wazuh test environment.

    Raises:
        ValueError: If the specified inventory path is invalid or not provided.
    """
    inventory_path = request.config.getoption('--inventory-path')
    host_manager = HostManager(inventory_path)
    validate_environment(host_manager)

    return host_manager


def validate_environment(host_manager: HostManager) -> None:
    """Check if the environment is accessible

    Args:
        host_manager: An instance of the HostManager class containing information about hosts.
    """
    hosts_not_reachable = host_manager.get_hosts_not_reachable()

    assert len(hosts_not_reachable) == 0, f"Hosts not reachable: {hosts_not_reachable}"


@pytest.fixture(scope="module")
def save_indexer_credentials_keystore(host_manager: HostManager) -> None:
    """Save the Wazuh indexer username and password into the Wazuh manager keystore

    Args:
        host_manager (HostManager): HostManager fixture.
    """
    logging.error(
        "Save the Wazuh indexer username and password into the Wazuh manager keystore"
    )
    save_indexer_credentials_into_keystore(host_manager)


@pytest.fixture(scope='function')
def setup(preconditions, teardown, host_manager) -> Generator[Dict, None, None]:
    """Fixture for running setup and teardown operations for the specified tests case
    It returns a dictionary with the results of the preconditions and teardown operations

    Args:
        preconditions: Dictionary with the preconditions operations
        teardown: Dictionary with the teardown operations
        host_manager: An instance of the HostManager class containing information about hosts.

    Returns:
        Generator: Dictionary with the results of the preconditions and teardown operations
    """

    logging.info("Running setup")
    result = {}
    failed_agents = []

    if preconditions:
        logging.info("Running preconditions")
        target_to_ignore = []
        agents_to_check = host_manager.get_group_hosts("agent")

        if 'target_os' in preconditions:
            agents_to_check = filter_hosts_by_os(host_manager, preconditions['target_os'])
            target_to_ignore = list(set(host_manager.get_group_hosts('agent')) - set(agents_to_check))

        result = launch_parallel_operations(preconditions, host_manager, target_to_ignore)
        logging.critical(f"Preconditions finished. Results: {result}")

        test_timestamp = datetime.datetime.now(datetime.timezone.utc)
        test_timestamp = test_timestamp.strftime("%Y-%m-%dT%H:%M:%S")

        package_data = [preconditions['package']]

        timeout_syscollector_scan = VD_E2E_TIMEOUT_SYSCOLLECTOR_SCAN
        timeout_vulnerabilities_detected = len(agents_to_check) * PACKAGE_VULNERABILITY_SCAN_TIME

        time.sleep(timeout_syscollector_scan + timeout_vulnerabilities_detected)

        vulnerabilities = get_vulnerabilities_index(host_manager, agents_to_check, package_data)
        vulnerabilities_from_alerts = get_vulnerability_alerts(host_manager, agents_to_check, package_data,
                                                               test_timestamp)

        expected_alerts = get_expected_alerts(host_manager, agents_to_check, preconditions['operation'],
                                              preconditions['package'])
        expected_vulnerabilities = get_expected_index(host_manager, agents_to_check, preconditions['operation'],
                                                      preconditions['package'])

        vuln_alerts = compare_expected_found_vulnerabilities_alerts(vulnerabilities_from_alerts, expected_alerts)
        vuln_detected = compare_expected_found_vulnerabilities(vulnerabilities, expected_vulnerabilities)
        operation_result = get_failed_operation_hosts(result)

        failed_agents = vuln_alerts.get('failed_agents', [])
        failed_agents.extend(vuln_detected.get('failed_agents', []))
        failed_agents.extend(operation_result)

    yield list(set(failed_agents))

    logging.info("Running teardown")

    if teardown:
        target_to_ignore = []
        agents_to_check = host_manager.get_group_hosts("agent")

        if 'target_os' in teardown:
            agents_to_check = filter_hosts_by_os(host_manager, teardown['target_os'])
            target_to_ignore = list(set(host_manager.get_group_hosts('agent')) - set(agents_to_check))

        logging.critical(f"Running teardown for agent: {agents_to_check}")

        result = launch_parallel_operations(teardown, host_manager, target_to_ignore)
        logging.critical(f"Teardown Results: {result}")

        timeout_syscollector_scan = VD_E2E_TIMEOUT_SYSCOLLECTOR_SCAN
        timeout_vulnerabilities_detected = len(agents_to_check) * PACKAGE_VULNERABILITY_SCAN_TIME
        time.sleep(timeout_syscollector_scan + timeout_vulnerabilities_detected)


@pytest.fixture(scope='session', autouse=True)
def handle_logs():
    """Fixture for handling test evidences logs
    """

    logs_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'logs')
    os.makedirs(logs_dir, exist_ok=True)

    yield

    shutil.rmtree(logs_dir, ignore_errors=True)


@pytest.fixture(scope='session', autouse=True)
def enable_modulesd_debug(request, host_manager):
    """Fixture for enabling modulesd debug mode

    Args:
        request: Pytest request object

    Returns:
        bool: True if modulesd debug mode is enabled, False otherwise
    """

    modulesd_debug_enabled = request.config.getoption('--enable-modulesd-debug')

    if modulesd_debug_enabled:
        logging.critical("Enabling modulesd debug mode")
        for manager in host_manager.get_group_hosts('manager'):
            host_manager.modify_file_content(manager, '/var/ossec/etc/local_internal_options.conf', 'wazuh_modules.debug=2\n')
            host_manager.control_environment('restart', ['manager'], parallel=True)

    yield

    if modulesd_debug_enabled:
        logging.critical("Disabling modulesd debug mode")
        for manager in host_manager.get_group_hosts('manager'):
            host_manager.modify_file_content(manager, '/var/ossec/etc/local_internal_options.conf', 'wazuh_modules.debug=0\n')
            host_manager.control_environment('restart', ['manager'], parallel=True)


@pytest.fixture(scope='session', autouse=True)
def handle_gather_evidence_when_passed(request):
    """Fixture for gathering evidences when the test passed

    Args:
        request: Pytest request object
    """

    global gather_evidences_when_passed
    global enable_verbose_evidences

    if request.config.getoption('--gather-evidences-when-passed'):
        gather_evidences_when_passed = True

    if request.config.getoption('--enable-verbose-evidences'):
        enable_verbose_evidences = True


# Configure logging
@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_runtest_setup(item):
    item_name = item._request.node.name
    item_path = item._request.node.path

    logs_dir = os.path.join(os.path.dirname(item_path), 'logs')
    logs_test_dir = os.path.join(logs_dir, item_name)

    os.makedirs(logs_test_dir, exist_ok=True)

    config = item.config
    logging_plugin = config.pluginmanager.get_plugin("logging-plugin")

    filename = os.path.join(logs_test_dir, item._request.node.name + ".log")

    logging_plugin.set_log_path(str(filename))

    yield


@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_runtest_teardown(item, nextitem):
    # Current dir and logs

    yield

    item_name = item._request.node.name
    item_path = item._request.node.path

    logs_dir = os.path.join(os.path.dirname(item_path), 'logs')
    logs_test_dir = os.path.join(logs_dir, item_name)

    shutil.rmtree(logs_test_dir, ignore_errors=True)


def pytest_html_results_table_header(cells):
    cells.insert(2, html.th('Description'))

def pytest_html_results_table_row(report, cells):
    try:
        cells.insert(2, html.td(report.description))
    except AttributeError:
        pass


# HARDCODE: pytest-html generates too long file names. This temp fix is to reduce the name of
# the assets
def create_asset(
        self, content, extra_index, test_index, file_extension, mode="w"
):
    asset_file_name = "{}.{}".format(
        str(uuid.uuid4()),
        file_extension
    )
    asset_path = os.path.join(
        os.path.dirname(self.logfile), "assets", asset_file_name
    )

    if not os.path.exists(os.path.dirname(asset_path)):
        os.makedirs(os.path.dirname(asset_path))

    relative_path = os.path.join("assets", asset_file_name)

    kwargs = {"encoding": "utf-8"} if "b" not in mode else {}

    with open(asset_path, mode, **kwargs) as f:
        f.write(content)
    return relative_path


@pytest.hookimpl(hookwrapper=True)
def pytest_runtest_makereport(item, call):
    pytest_html = item.config.pluginmanager.getplugin('html')
    outcome = yield
    report = outcome.get_result()
    documentation = FunctionDoc(item.function)

    # Add description, markers and tier to the report
    report.description = '. '.join(documentation["Summary"])
    report.tier = ', '.join(str(mark.kwargs['level']) for mark in item.iter_markers(name="tier"))
    report.markers = ', '.join(mark.name for mark in item.iter_markers() if
                               mark.name != 'tier' and mark.name != 'parametrize')

    if report.location[0] not in results:
        results[report.location[0]] = {'passed': 0, 'failed': 0, 'skipped': 0, 'xfailed': 0, 'error': 0}

    extra = getattr(report, 'extra', [])

    if report.when == 'call':
        # Apply hack to fix length filename problem
        pytest_html.HTMLReport.TestResult.create_asset = create_asset

        # Add extended information from docstring inside 'Result' section
        extra.append(pytest_html.extras.html('<div><h2>Test function details</h2></div>'))
        for section in ('Extended Summary', 'Parameters'):
            extra.append(pytest_html.extras.html(f'<div><h3>{section}</h3></div>'))
            for line in documentation[section]:
                extra.append(pytest_html.extras.html(f'<div>{line}</div>'))
        arguments = dict()

        # Add arguments of each text as a json file
        for key, value in item.funcargs.items():
            if isinstance(value, set):
                arguments[key] = list(value)
            try:
                json.dumps(value)
                arguments[key] = value
            except (TypeError, OverflowError):
                arguments[key] = str(value)
        extra.append(pytest_html.extras.json(arguments, name="Test arguments"))

        try:

            current_dir = os.path.dirname(__file__)
            vulnerability_detector_logs_dir = os.path.join(current_dir, "logs")
            logs_path = os.path.join(str(vulnerability_detector_logs_dir), item._request.node.name)

            if 'host_manager' in item.funcargs:
                collect_e2e_environment_data(logs_path, item.funcargs['host_manager'])

            if dict(item.user_properties):
                test_result = dict(item.user_properties)['test_result']
                try:
                    test_result.collect_evidences(logs_path, enable_verbose_evidences, gather_evidences_when_passed)
                except Exception as e:
                    logging.critical(f"Error collecting evidences: {e} for {item._request.node.name}")
            else:
                logging.info(f"No evidences found for {item._request.node.name}")

            files = []

            if os.path.exists(logs_path):
                files = [f for f in os.listdir(logs_path) if
                         os.path.isfile(os.path.join(logs_path, f))]

            for filepath in files:
                fullpath = os.path.join(logs_path, filepath)
                if os.path.isfile(fullpath):
                    with open(fullpath, mode='r', errors='replace') as f:
                        content = f.read()
                        extra.append(pytest_html.extras.text(content, name=os.path.split(filepath)[-1]))
        except Exception as e:
            logging.critical(f"Unexpected error in evidence collection: {e} for {item._request.node.name}")

        if gather_evidences_when_passed and not report.skipped:
            report.extra = extra
        else:
            if not report.passed and not report.skipped:
                report.extra = extra


        if report.longrepr is not None and report.longreprtext.split()[-1] == 'XFailed':
            results[report.location[0]]['xfailed'] += 1
        else:
            results[report.location[0]][report.outcome] += 1

    elif report.outcome == 'failed':
        results[report.location[0]]['error'] += 1


class SummaryTable(html):
    class table(html.table):
        style = html.Style(border='1px solid #e6e6e6', margin='16px 0px', color='#999', font_size='12px')

    class td(html.td):
        style = html.Style(padding='5px', border='1px solid #E6E6E6', text_align='left')

    class th(html.th):
        style = html.Style(padding='5px', border='1px solid #E6E6E6', text_align='left', font_weight='bold', )


def pytest_html_results_summary(prefix, summary, postfix):
    postfix.extend([SummaryTable.table(
        html.thead(
            html.tr([
                SummaryTable.th("Tests"),
                SummaryTable.th("Failed"),
                SummaryTable.th("Success"),
                SummaryTable.th("XFail"),
                SummaryTable.th("Error")]
            ),
        ),
        [html.tbody(
            html.tr([
                SummaryTable.td(k),
                SummaryTable.td(v['failed']),
                SummaryTable.td(v['passed']),
                SummaryTable.td(v['xfailed']),
                SummaryTable.td(v['error']),
            ])
        ) for k, v in results.items()])])


@pytest.hookimpl(tryfirst=True)
def pytest_configure(config):
    if not config.option.css:
        config.option.css = [STYLE_PATH]


@pytest.fixture(scope="session", autouse=True)
def modify_timezone(request):
    inventory_path = request.config.getoption('--inventory-path')
    host_manager = HostManager(inventory_path)
    hosts = host_manager.get_group_hosts('agent')
    command = ''

    for host in hosts:
        if host_manager.get_host_variables(host)['os_name'] == 'macos':
            command = 'systemsetup -settimezone GMT'
        elif host_manager.get_host_variables(host)['os_name'] == 'windows':
            command = 'Set-TimeZone -Id "UTC"'
        else:
            continue

        host_manager.run_shell(host, command, system=host_manager.get_host_variables(host)['os_name'])
