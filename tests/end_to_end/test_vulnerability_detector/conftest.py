"""
Pytest configuration for Vulnerability Detector E2E testing

This module contains Pytest fixtures and configuration settings for Wazuh end-to-end testing.
It provides reusable fixtures and setup that can be shared across multiple test modules.

Functions:
    - `collect_e2e_environment_data`: Collect data from the environment for the test. For example, logs from the
        Wazuh components.
    - `collect_evidences`: Collect specific evidences for the test
    - `validate_environment`: Check if the environment is accessible

Fixtures:
    - `host_manager`: Fixture for creating a HostManager instance representing the Wazuh test environment.
    - `setup`: Fixture for running setup and teardown operations for the test.

Configuration Options:
    - `--inventory-path`: Path to the inventory file specifying the test environment hosts.

Constants:
    - `STYLE_PATH`: Path to the CSS stylesheet used by the HTML report.

Example:
    To use the `host_manager` fixture in your test module:

    ```python
    def test_example(host_manager):
        # Your test logic using the host_manager fixture
        pass
    ```
"""
import pytest
import json
import datetime
import os
import logging
import shutil
import uuid
from py.xml import html
from numpydoc.docscrape import FunctionDoc
from typing import Generator, Dict

from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.remote_operations_handler import launch_parallel_operations
from wazuh_testing.end_to_end.logs import get_hosts_logs, get_hosts_alerts


STYLE_PATH = os.path.join(os.path.dirname(__file__), '../../../deps/wazuh_testing/wazuh_testing/reporting/style.css')
gather_evidences_when_passed = False

catalog = list()
results = dict()


def collect_e2e_environment_data(test_name, host_manager) -> None:
    """Collect data from the environment for the test

    Args:
        test_name: Name of the test
        host_manager: An instance of the HostManager class containing information about hosts.
    """
    logging.info("Collecting environment data")
    environment_logs = get_hosts_logs(host_manager)
    environment_alerts = get_hosts_alerts(host_manager)

    current_dir = os.path.dirname(__file__)
    vulnerability_detector_logs_dir = os.path.join(current_dir, "logs")
    tests_evidences_directory = os.path.join(str(vulnerability_detector_logs_dir), str(test_name))

    for host in environment_logs.keys():
        logging.info(f"Collecting logs for {host}")
        host_logs_name_evidence = host + "_ossec.log"        
        evidence_log_file = os.path.join(tests_evidences_directory, host_logs_name_evidence)
        with open(evidence_log_file, 'w') as evidence_log_file:
            evidence_log_file.write(environment_logs[host])

    for host in environment_alerts.keys():
        logging.info(f"Collecting alerts for {host}")           
        host_alerts_name_evidence = host + "_alert.json"
        evidence_alert_file = os.path.join(tests_evidences_directory, host_alerts_name_evidence)
        with open(evidence_alert_file, 'w') as evidence_alert_file:
            evidence_alert_file.write(environment_alerts[host])


def collect_evidences(test_name, evidences) -> None:
    """
    Collect specific evidences for the test

    Args:
        test_name: Name of the test
        evidences: Dictionary with the evidences to collect
    """
    current_dir = os.path.dirname(__file__)
    vulnerability_detector_logs_dir = os.path.join(current_dir, "logs")
    tests_evidences_directory = os.path.join(str(vulnerability_detector_logs_dir), str(test_name))
    logging.info(f"Collecting evidences for {test_name}")

    if evidences:
        logging.info(f"Collecting custom evidences for {test_name}")
        for evidence, content in evidences.items():
            logging.info(f"Collecting {evidence} for {test_name}")
            if content is not None and content != [] and content != {}:
                evidence_file = os.path.join(tests_evidences_directory, evidence + ".log")
                with open(evidence_file, 'w') as evidence_file:
                    if content.__class__ == dict:
                        try:
                            json.dump(content, evidence_file, indent=4)
                        except TypeError:
                            logging.critical(f"Error dumping {evidence} to file")
                    else:
                        evidence_file.write(str(content))


@pytest.fixture(scope='session')
def host_manager(request):
    """Fixture for creating a HostManager instance.

    This fixture initializes and provides a HostManager instance for testing purposes. The HostManager
    is set up at the session scope, ensuring it is created only once for the entire test suite.

    Args:
        request (FixtureRequest): The Pytest fixture request object.

    Returns:
        HostManager: An instance of the HostManager class representing the Wazuh test environment.

    Raises:
        ValueError: If the specified inventory path is invalid or not provided.
    """
    inventory_path = request.config.getoption('--inventory-path')
    host_manager = HostManager(inventory_path)
    validate_environment(host_manager)

    return host_manager


def validate_environment(host_manager: HostManager) -> None:
    """Check if the environment is accessible

    Args:
        host_manager: An instance of the HostManager class containing information about hosts.
    """
    hosts_not_reachable = host_manager.get_hosts_not_reachable()

    assert len(hosts_not_reachable) == 0, f"Hosts not reachable: {hosts_not_reachable}"


@pytest.fixture(scope='function')
def setup(preconditions, teardown, host_manager) -> Generator[Dict, None, None]:
    """Fixture for running setup and teardown operations for the specified tests case
    It returns a dictionary with the results of the preconditions and teardown operations

    Args:
        preconditions: Dictionary with the preconditions operations
        teardown: Dictionary with the teardown operations
        host_manager: An instance of the HostManager class containing information about hosts.

    Returns:
        Generator: Dictionary with the results of the preconditions and teardown operations
    """

    logging.info("Running setup")
    result = {}

    if preconditions:
        logging.info("Running preconditions")
        result = launch_parallel_operations(preconditions['tasks'], host_manager)
        logging.info(f"Preconditions finished. Results: {result}")

        for host in result.keys():
            if result[host]['checks']['all_successfull'] is False:
                logging.critical(f"Test failed for host {host}. Check logs for more information")
                logging.critical(f"Evidences: {result[host]['evidences']}")

    logging.info(f"Result of preconditions: {result}")

    yield result

    logging.info("Running teardown")

    if teardown:
        result = launch_parallel_operations(teardown, host_manager)

        for host in result.keys():
            if result[host]['checks']['all_successfull'] is False:
                logging.critical(f"Test failed for host {host}. Check logs for more information")
                logging.critical(f"Evidences: {result[host]['evidences']}")

    logging.info(f"Result of teardown: {result}")


@pytest.fixture(scope='session', autouse=True)
def handle_logs():
    """Fixture for handling test evidences logs
    """

    logs_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'logs')
    os.makedirs(logs_dir, exist_ok=True)

    yield

    shutil.rmtree(logs_dir, ignore_errors=True)


# Configure logging
@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_runtest_setup(item):
    item_name = item._request.node.name
    item_path = item._request.node.path

    logs_dir = os.path.join(os.path.dirname(item_path), 'logs')
    logs_test_dir = os.path.join(logs_dir, item_name)

    os.makedirs(logs_test_dir, exist_ok=True)

    config = item.config
    logging_plugin = config.pluginmanager.get_plugin("logging-plugin")

    filename = os.path.join(logs_test_dir, item._request.node.name + ".log")

    logging_plugin.set_log_path(str(filename))

    yield


@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_runtest_teardown(item, nextitem):
    # Current dir and logs

    yield

    item_name = item._request.node.name
    item_path = item._request.node.path

    logs_dir = os.path.join(os.path.dirname(item_path), 'logs')
    logs_test_dir = os.path.join(logs_dir, item_name)

    shutil.rmtree(logs_test_dir, ignore_errors=True)


def pytest_html_results_table_header(cells):
    cells.insert(4, html.th('Tier', class_='sortable tier', col='tier'))
    cells.insert(3, html.th('Markers'))
    cells.insert(2, html.th('Description'))
    cells.insert(1, html.th('Time', class_='sortable time', col='time'))


def pytest_html_results_table_row(report, cells):
    try:
        cells.insert(4, html.td(report.tier))
        cells.insert(3, html.td(report.markers))
        cells.insert(2, html.td(report.description))
        cells.insert(1, html.td(datetime.utcnow(), class_='col-time'))
    except AttributeError:
        pass


# HARDCODE: pytest-html generates too long file names. This temp fix is to reduce the name of
# the assets
def create_asset(
        self, content, extra_index, test_index, file_extension, mode="w"
):
    asset_file_name = "{}.{}".format(
        str(uuid.uuid4()),
        file_extension
    )
    asset_path = os.path.join(
        os.path.dirname(self.logfile), "assets", asset_file_name
    )

    if not os.path.exists(os.path.dirname(asset_path)):
        os.makedirs(os.path.dirname(asset_path))

    relative_path = os.path.join("assets", asset_file_name)

    kwargs = {"encoding": "utf-8"} if "b" not in mode else {}

    with open(asset_path, mode, **kwargs) as f:
        f.write(content)
    return relative_path


@pytest.hookimpl(hookwrapper=True)
def pytest_runtest_makereport(item, call):
    pytest_html = item.config.pluginmanager.getplugin('html')
    outcome = yield
    report = outcome.get_result()
    documentation = FunctionDoc(item.function)

    # Add description, markers and tier to the report
    report.description = '. '.join(documentation["Summary"])
    report.tier = ', '.join(str(mark.kwargs['level']) for mark in item.iter_markers(name="tier"))
    report.markers = ', '.join(mark.name for mark in item.iter_markers() if
                               mark.name != 'tier' and mark.name != 'parametrize')

    if report.location[0] not in results:
        results[report.location[0]] = {'passed': 0, 'failed': 0, 'skipped': 0, 'xfailed': 0, 'error': 0}

    extra = getattr(report, 'extra', [])

    if report.when == 'call':
        # Apply hack to fix length filename problem
        pytest_html.HTMLReport.TestResult.create_asset = create_asset

        # Add extended information from docstring inside 'Result' section
        extra.append(pytest_html.extras.html('<div><h2>Test function details</h2></div>'))
        for section in ('Extended Summary', 'Parameters'):
            extra.append(pytest_html.extras.html(f'<div><h3>{section}</h3></div>'))
            for line in documentation[section]:
                extra.append(pytest_html.extras.html(f'<div>{line}</div>'))
        arguments = dict()

        # Add arguments of each text as a json file
        for key, value in item.funcargs.items():
            if isinstance(value, set):
                arguments[key] = list(value)
            try:
                json.dumps(value)
                arguments[key] = value
            except (TypeError, OverflowError):
                arguments[key] = str(value)
        extra.append(pytest_html.extras.json(arguments, name="Test arguments"))

        try:

            current_dir = os.path.dirname(__file__)
            vulnerability_detector_logs_dir = os.path.join(current_dir, "logs")
            logs_path = os.path.join(str(vulnerability_detector_logs_dir), item._request.node.name)

            if 'host_manager' in item.funcargs:
                collect_e2e_environment_data(item._request.node.name, item.funcargs['host_manager'])

            if 'get_results' in item.funcargs:
                test_result = item.funcargs['get_results']

                if item._request.node.name in test_result and 'evidences' in test_result[item._request.node.name]:
                    evidences = test_result[item._request.node.name]['evidences']
                    collect_evidences(item._request.node.name, evidences)
                else:
                    logging.info(f"No evidences found for {item._request.node.name}")

            files = []

            if os.path.exists(logs_path):
                files = [f for f in os.listdir(logs_path) if
                         os.path.isfile(os.path.join(logs_path, f))]

            for filepath in files:
                fullpath = os.path.join(logs_path, filepath)
                if os.path.isfile(fullpath):
                    with open(fullpath, mode='r', errors='replace') as f:
                        content = f.read()
                        extra.append(pytest_html.extras.text(content, name=os.path.split(filepath)[-1]))
        except Exception as e:
            logging.critical(f"Error collecting evidences: {e} for {item._request.node.name}")

        if gather_evidences_when_passed and not report.skipped:
            report.extra = extra
        else:
            if not report.passed and not report.skipped:
                report.extra = extra


        if report.longrepr is not None and report.longreprtext.split()[-1] == 'XFailed':
            results[report.location[0]]['xfailed'] += 1
        else:
            results[report.location[0]][report.outcome] += 1

    elif report.outcome == 'failed':
        results[report.location[0]]['error'] += 1


class SummaryTable(html):
    class table(html.table):
        style = html.Style(border='1px solid #e6e6e6', margin='16px 0px', color='#999', font_size='12px')

    class td(html.td):
        style = html.Style(padding='5px', border='1px solid #E6E6E6', text_align='left')

    class th(html.th):
        style = html.Style(padding='5px', border='1px solid #E6E6E6', text_align='left', font_weight='bold', )


def pytest_html_results_summary(prefix, summary, postfix):
    postfix.extend([SummaryTable.table(
        html.thead(
            html.tr([
                SummaryTable.th("Tests"),
                SummaryTable.th("Failed"),
                SummaryTable.th("Success"),
                SummaryTable.th("XFail"),
                SummaryTable.th("Error")]
            ),
        ),
        [html.tbody(
            html.tr([
                SummaryTable.td(k),
                SummaryTable.td(v['failed']),
                SummaryTable.td(v['passed']),
                SummaryTable.td(v['xfailed']),
                SummaryTable.td(v['error']),
            ])
        ) for k, v in results.items()])])


@pytest.hookimpl(tryfirst=True)
def pytest_configure(config):
    if not config.option.css:
        config.option.css = [STYLE_PATH]


@pytest.fixture(scope="session", autouse=True)
def modify_timezone(request):
    inventory_path = request.config.getoption('--inventory-path')
    host_manager = HostManager(inventory_path)
    hosts = host_manager.get_group_hosts('agent')
    command = ''

    for host in hosts:
        if host_manager.get_host_variables(host)['os_name'] == 'macos':
            command = 'systemsetup -settimezone GMT'
        elif host_manager.get_host_variables(host)['os_name'] == 'windows':
            command = 'Set-TimeZone -Id "UTC"'
        else:
            continue

        host_manager.run_shell(host, command, system=host_manager.get_host_variables(host)['os_name'])
