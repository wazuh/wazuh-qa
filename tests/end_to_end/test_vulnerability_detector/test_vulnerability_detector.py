# Copyright (C) 2015, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2

"""
Vulnerability Detector Basic Cases Tests
----------------------------------------

Type: End-to-End (E2E)

Brief:
    This module contains basic tests to ensure the proper functionality of the Vulnerability Detector.
    The tests validate that initial Syscollector scans, along with installation, removal, and uninstall operations,
    trigger Vulnerability Detector scans, generating the expected vulnerabilities.
    The verification of vulnerabilities is conducted through Vulnerabilities Index and API endpoint
    Additionally, the tests ensure the consistency of these values.

Tests:
    - TestInitialScans: Validates the initiation of Syscollector scans across all agents in the environment.
        - test_syscollector_first_scan: Validates the initiation of the first Syscollector scans across all agents in
          the environment.
        - test_syscollector_first_scan_index: Validates that the Vulnerability Detector detects vulnerabilities within
          the environment in the first scan in the index.
        - test_syscollector_second_scan: Validates the initiation of the second Syscollector scans across all agents in
          the environment.
        - tests_syscollector_first_second_scan_consistency_index: Ensure the consistency of the agent's vulnerabilities
          between the first and second scans in index.
    - TestScanSyscollectorCases: Validates the Vulnerability Detector's ability to detect new vulnerabilities in the
      environment.

Issue: https://github.com/wazuh/wazuh-qa/issues/4369

Components:
  - vulnerability_detector
  - syscollector

Environment: e2e_vulnerability_detector

Tiers: 0

Markers:
  - e2e
  - vulnerability_detector
  - tier0
"""
import os
import pytest
import logging
import yaml
import time
import ast
import datetime
from typing import Generator

from wazuh_testing.end_to_end.configuration import backup_configurations, restore_configuration, \
        configure_environment, save_indexer_credentials_into_keystore
from wazuh_testing.end_to_end.logs import truncate_remote_host_group_files
from wazuh_testing.end_to_end.waiters import wait_until_vd_is_updated
from wazuh_testing.end_to_end.monitoring import generate_monitoring_logs, monitoring_events_multihost
from wazuh_testing.end_to_end.regex import get_event_regex
from wazuh_testing.end_to_end.indexer_api import get_indexer_values
from wazuh_testing.tools.configuration import load_configuration_template
from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.remote_operations_handler import launch_parallel_operations
from wazuh_testing.end_to_end.vulnerability_detector import get_vulnerabilities_from_states
from wazuh_testing.modules.syscollector import TIMEOUT_SYSCOLLECTOR_SCAN


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

local_path = os.path.dirname(os.path.abspath(__file__))
current_dir = os.path.dirname(__file__)
configurations_dir = os.path.join(current_dir, "configurations")
configurations_paths = {
        'manager': os.path.join(configurations_dir, 'manager.yaml'),
        'agent': os.path.join(configurations_dir, 'agent.yaml')
        }
vulnerability_detector_logs_dir = os.path.join(current_dir, "logs")

TIMEOUT_PER_AGENT_VULNERABILITY_SCAN = 200


def load_vulnerability_detector_configurations(host_manager):
    """Return the configurations for Vulnerability testing for the agent and manager roles

    Return:
        Dict: Configurations for each role
    """
    configurations = {}

    for host in host_manager.get_group_hosts('all'):
        if host in host_manager.get_group_hosts('agent'):
            configurations[host] = load_configuration_template(configurations_paths['agent'], [{}], [{}])
        elif host in host_manager.get_group_hosts('manager'):
            configuration_template = load_configuration_template(configurations_paths['manager'], [{}], [{}])

            # Replace placeholders by real values
            manager_index = host_manager.get_group_hosts('manager').index(host) + 2
            indexer_server = host_manager.get_group_hosts('indexer')[0]
            indexer_server_variables = host_manager.get_host_variables(indexer_server)
            configuration_variables = {
                'INDEXER_SERVER': indexer_server_variables['ip'],
                'FILEBEAT_ROOT_CA': '/etc/pki/filebeat/root-ca.pem',
                'FILEBEAT_CERTIFICATE': f"/etc/pki/filebeat/node-{manager_index}.pem",
                'FILEBEAT_KEY': f"/etc/pki/filebeat/node-{manager_index}-key.pem"
            }
            configuration_template_str = str(configuration_template)

            for key, value in configuration_variables.items():
                configuration_template_str = configuration_template_str.replace(key, value)

            configurations[host] = ast.literal_eval(configuration_template_str)

    return configurations


@pytest.fixture(scope='module')
def setup_vulnerability_tests(host_manager: HostManager) -> Generator:
    """Setup the vulnerability tests environment

    Args:
        host_manager (HostManager): An instance of the HostManager class.
    """
    logger.error("Init setup of environment")

    # Configure managers and agents
    logger.error("Getting backup of current configurations")
    hosts_configuration_backup = backup_configurations(host_manager)

    logger.error("Configuring environment")
    configure_environment(host_manager, load_vulnerability_detector_configurations(host_manager))
    logger.error("Save the Wazuh indexer username and password into the Wazuh manager keystore")
    save_indexer_credentials_into_keystore(host_manager)

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    # Restart managers and stop agents
    logger.error("Stopping agents")
    host_manager.control_environment('stop', ['agent'])
    logger.error("Restarting managers")
    host_manager.control_environment('restart', ['manager'])

    utc_now_timestamp = datetime.datetime.now(datetime.timezone.utc)

    # Format the date and time as per the given format
    test_timestamp = utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%SZ")

    # Wait until VD is updated
    logger.error("Wait until Vulnerability Detector has update all the feeds")
    wait_until_vd_is_updated(host_manager)

    # Start agents
    host_manager.control_environment('start', ['agent'])

    yield test_timestamp

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    logger.error("Restoring original configuration")
    restore_configuration(host_manager, hosts_configuration_backup)

    logger.error("Restarting environment")
    host_manager.control_environment('restart', ['agent'])
    host_manager.control_environment('restart', ['manager'])


@pytest.mark.filterwarnings('ignore::urllib3.exceptions.InsecureRequestWarning')
class TestInitialScans():
    results = {}

    @pytest.fixture(scope='class')
    def get_results(self):
        return self.results

    def test_syscollector_first_scan(self, request, host_manager, setup_vulnerability_tests, get_results):
        """
        description: Validates the initiation of Syscollector scans across all agents in the environment.

        This test ensures that the Vulnerability Detector accurately detects vulnerabilities within the environment.
        The Agent's Vulnerability Indexer index is expected to be updated with the detected vulnerabilities.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that syscollector scan is started after agent start in all agents

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """
        results = get_results
        test_name = request.node.name

        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'agents_not_scanned_first_scan': []
                }
        }

        logger.critical("Monitoring syscollector first scan")
        list_hosts = host_manager.get_group_hosts('agent')
        monitoring_data = generate_monitoring_logs(host_manager,
                                                   [get_event_regex({'event': 'syscollector_scan_start'}),
                                                    get_event_regex({'event': 'syscollector_scan_end'})],
                                                   [TIMEOUT_SYSCOLLECTOR_SCAN, TIMEOUT_SYSCOLLECTOR_SCAN],
                                                   list_hosts)
        monitoring_results = monitoring_events_multihost(host_manager, monitoring_data)

        logger.critical(f"Value of monitoring results is: {monitoring_results}")

        for agent in monitoring_results:
            if monitoring_results[agent]['not_found']:
                test_result['checks']['all_successfull'] = False
                test_result['evidences']['agents_not_scanned_first_scan'].append(agent)

        results[test_name] = test_result

        if not test_result['checks']['all_successfull']:
            logging_message = 'Syscollector scan not started in the following agents:' \
                    f"{test_result['evidences']['agents_not_scanned_first_scan']}."
            logger.critical(logging_message)
            pytest.fail(logging_message)
        else:
            logger.critical("All agents has been scanned")

    def test_syscollector_first_scan_index(self, request, host_manager, setup_vulnerability_tests, get_results):
        """
        description: Validates that the Vulnerability Detector detects vulnerabilities within the environment in the
        first scan in the index.

        This test ensures that the Vulnerability Detector accurately detects vulnerabilities within the environment in
        the index. It is assumed that provided hosts will have at least one vulnerability.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned
            - Verify that all agents has generated vulnerabilities in the index

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """
        results = get_results
        test_name = request.node.name
        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'agents_not_detected_index_vulnerabilities': [],
                    'vulnerabilities_index_first_scan': []
                }
        }

        # Filter agents that has not been scanned
        agents_to_check = [agent for agent in host_manager.get_group_hosts('agent') if agent not in
                           results['test_syscollector_first_scan']['evidences']['agents_not_scanned_first_scan']]

        if len(agents_to_check) == 0:
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        # Check vulnerabilities in the index
        logger.critical("Checking vulnerabilities in the index")
        vuln_by_agent_index = {}

        time.sleep(TIMEOUT_PER_AGENT_VULNERABILITY_SCAN * len(agents_to_check))

        for agent in agents_to_check:
            agent_all_vulnerabilities = get_indexer_values(host_manager,
                                                           greater_than_timestamp=setup_vulnerability_tests,
                                                           agent=agent,
                                                           index='wazuh-states-vulnerabilities',)['hits']['hits']

            vuln_by_agent_index[agent] = agent_all_vulnerabilities

        test_result['evidences']['vulnerabilities_index_first_scan'] = vuln_by_agent_index

        logger.critical("Checking that all agents has been scanned and generated vulnerabilities in the index")
        for agent in agents_to_check:
            if agent not in list(vuln_by_agent_index.keys()) or \
                    len(vuln_by_agent_index[agent]) == 0:

                logger.critical(f"Agent {agent} has not been scanned. Continuing with remaining agents")
                test_result['checks']['all_successfull'] = False
                test_result['evidences']['agents_not_detected_index_vulnerabilities'].append(agent)

        results[test_name] = test_result

        # Store full alert index list in global results. It is needed for the next test
        results['vulnerabilities_index_first_scan'] = vuln_by_agent_index

        if not test_result['checks']['all_successfull']:
            logging_message = 'Some agents has not been scanned and generated vulnerabilities in the index:' \
                    f"{test_result['evidences']['agents_not_detected_index_vulnerabilities']}."
            logger.critical(logging_message)
            pytest.fail(logging_message)
        else:
            logger.critical("All agents has been scanned and updated states index")

    def test_syscollector_second_scan(self, request, host_manager, setup_vulnerability_tests, get_results):
        """
        description: Validates the initiation of the second Syscollector scans across all agents in the environment.

        This test ensures that Syscollector second scans are started in all agents in the environment.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """

        results = get_results
        test_name = request.node.name
        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'agents_syscollector_second_scan_not_started': []
                }
        }

        # Filter agents that has not been scanned
        agents_to_check = [agent for agent in host_manager.get_group_hosts('agent') if agent not in
                           results['test_syscollector_first_scan']['evidences']['agents_not_scanned_first_scan']]

        if len(agents_to_check) == 0:
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        monitoring_data = generate_monitoring_logs(host_manager,
                                                   [get_event_regex({'event': 'syscollector_scan_start'}),
                                                    get_event_regex({'event': 'syscollector_scan_end'})],
                                                   [TIMEOUT_SYSCOLLECTOR_SCAN, TIMEOUT_SYSCOLLECTOR_SCAN],
                                                   host_manager.get_group_hosts('agent'), 2)

        monitoring_results = monitoring_events_multihost(host_manager, monitoring_data)
        logger.critical(f"Value of monitoring results is: {monitoring_results}")

        logger.critical("Checking that all agents has been scanned")
        for agent in monitoring_results:
            if monitoring_results[agent]['not_found']:
                test_result['checks']['all_successfull'] = False
                test_result['evidences']['agents_syscollector_second_scan_not_started'].append(agent)

                logging.critical(f"Syscollector scan not started in the following agents:"
                                 f"{test_result['evidences']['agents_syscollector_second_scan_not_started']}."
                                 'Continuing with the test')

        results[test_name] = test_result

        if not test_result['checks']['all_successfull']:
            logging_message = "Syscollector scan not started in the following agents:" \
                    f"{test_result['evidences']['agents_syscollector_second_scan_not_started']}."
            pytest.fail(logging_message)
        else:
            logger.critical("Syscollector scan started in all agents")

    def tests_syscollector_first_second_scan_consistency_index(self, request, host_manager, setup_vulnerability_tests,
                                                               get_results):
        """
        description: Ensure the consistency of the agent's vulnerabilities between the first and second scans in index.

        This test ensure that alerts in the first scan are consistent with the alerts in the second scan in the index.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that the number of vulnerabilities is the same between scans

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """

        results = get_results
        test_name = request.node.name
        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'vulnerabilities_index_first_scan': results['vulnerabilities_index_first_scan'],
                    'vulnerabilities_index_second_scan': [],
                    'vulnerabilities_not_found_in_second_scan': [],
                    'vulnerabilities_not_found_in_first_scan': [],
                    'agent_not_found_in_first_scan': [],
                    'agent_not_found_in_second_scan': []
                }
        }

        logger.critical("Checking vulnerabilities in the second scan")

        vuln_by_agent_index_second_scan = {}
        for agent in host_manager.get_group_hosts('agent'):
            agent_all_vulnerabilities = get_indexer_values(host_manager,
                                                           greater_than_timestamp=setup_vulnerability_tests,
                                                           index='wazuh-states-vulnerabilities',
                                                           agent=agent)['hits']['hits']
            # Only is expected alert of affected vulnerabilities
            vuln_by_agent_index_second_scan[agent] = agent_all_vulnerabilities

        test_result['evidences']['vulnerabilities_index_second_scan'] = vuln_by_agent_index_second_scan

        # Calculate differences between first and second scan
        agent_not_found_in_first_scan = (list(set(vuln_by_agent_index_second_scan.keys()) -
                                              set(results['vulnerabilities_index_first_scan'].keys())))
        agent_not_found_in_second_scan = (list(set(results['vulnerabilities_index_first_scan'].keys()) -
                                               set(vuln_by_agent_index_second_scan.keys())))

        agent_found_in_all_scans = (set(vuln_by_agent_index_second_scan.keys()) &
                                    set(results['vulnerabilities_index_first_scan'].keys()))

        vulnerabilities_not_found_in_first_scan = {}
        vulnerabilities_not_found_in_second_scan = {}

        for agent in agent_found_in_all_scans:
            vulnerabilities_second_scan = get_vulnerabilities_from_states(vuln_by_agent_index_second_scan[agent])
            vulnerabilities_first_scan = get_vulnerabilities_from_states(
                                         results['vulnerabilities_index_first_scan'][agent])

            # Calculate differences between first and second scan
            vulnerabilities_not_found_second_scan = (list(set(vulnerabilities_first_scan) -
                                                          set(vulnerabilities_second_scan)))
            vulnerabilities_not_found_first_scan = (list(set(vulnerabilities_second_scan) -
                                                         set(vulnerabilities_first_scan)))

            # Change to dict to be able to serialize
            vulnerabilities_not_found_first_scan = [vuln._asdict() for vuln in vulnerabilities_not_found_first_scan]
            vulnerabilities_not_found_second_scan = [vuln._asdict() for vuln in vulnerabilities_not_found_second_scan]

            if len(vulnerabilities_not_found_second_scan) > 0:
                vulnerabilities_not_found_in_second_scan[agent] = vulnerabilities_not_found_second_scan
            if len(vulnerabilities_not_found_first_scan) > 0:
                vulnerabilities_not_found_in_first_scan[agent] = vulnerabilities_not_found_first_scan

        # Check if agents are the same in both scans
        if (len(agent_found_in_all_scans) != len(vuln_by_agent_index_second_scan) !=
                len(results['vulnerabilities_index_first_scan'])):
            test_result['checks']['all_successfull'] = False
            logging.critical("Inconsistencies found between first and second scan in the index. Different agents found")
            if len(agent_not_found_in_first_scan) > 0:
                logging.critical(f"Agents not found in first scan: {agent_not_found_in_first_scan}")
                test_result['evidences']['agent_not_found_in_first_scan'] = agent_not_found_in_first_scan
            if len(agent_not_found_in_second_scan) > 0:
                logging.critical(f"Agents not found in second scan: {agent_not_found_in_second_scan}")
                test_result['evidences']['agent_not_found_in_second_scan'] = agent_not_found_in_second_scan

        # Check if vulnerabilities are the same in both scans
        if vulnerabilities_not_found_in_first_scan or vulnerabilities_not_found_in_second_scan:
            test_result['checks']['all_successfull'] = False
            if vulnerabilities_not_found_in_first_scan:
                logging.critical(f"Vulnerabilities not found in first scan: {vulnerabilities_not_found_in_first_scan}")
                test_result['evidences']['vulnerabilities_not_found_in_first_scan'] = vulnerabilities_not_found_in_first_scan

            if vulnerabilities_not_found_in_second_scan:
                logging.critical("Vulnerabilities not found in second scan: "
                                 f"{vulnerabilities_not_found_in_second_scan}")
                test_result['evidences']['vulnerabilities_not_found_in_second_scan'] = vulnerabilities_not_found_in_second_scan

        results[test_name] = test_result

        if not test_result['checks']['all_successfull']:
            logging_message = "Inconsistencies found between first and second scan in the index." \
                              "Check evidences for more information"
            logger.critical(logging_message)
            pytest.fail(logging_message)

# -------------------------


cases = {}

with open(os.path.join(current_dir, os.path.join('cases', 'test_vulnerability.yaml')), 'r') as cases_file:
    cases = yaml.load(cases_file, Loader=yaml.FullLoader)

complete_list = [
    (
        case['preconditions'] if 'preconditions' in case else None,
        case['body'] if 'body' in case else None,
        case['teardown'] if 'teardown' in case else None
    )
    for case in cases
]

list_ids = [case['id'] for case in cases]


class TestScanSyscollectorCases():
    results = {}

    @pytest.fixture(scope='class')
    def get_results(self):
        return self.results

    @pytest.mark.parametrize('preconditions, body, teardown', complete_list, ids=list_ids)
    def test_vulnerability_detector_scans_cases(self, setup_vulnerability_tests, request, preconditions, body, teardown,
                                                setup, host_manager, get_results):
        test_name = request.node.name

        setup_results = setup
        results = get_results
        results[request.node.name] = {}
        results['setup'] = setup_results

        hosts_to_ignore = []

        for host in setup_results.keys():
            if setup_results[host]['checks']['all_successfull'] is False:
                hosts_to_ignore.append(host)

        if len(hosts_to_ignore) > 0:
            logger.critical(f"Setup test failed for hosts {hosts_to_ignore}. Check logs for more information")
            logger.critical(f"Evidences: {setup_results}")
            logger.critical("Ignoring these hosts for the rest of the test")

        logger.critical("Starting scan cases tests")
        logger.critical(f"Case Info: {body}")

        # Launch tests tasks
        test_result = launch_parallel_operations(body['tasks'], host_manager, hosts_to_ignore)

        success_for_all_agents = True

        for host in test_result.keys():
            if test_result[host]['checks']['all_successfull'] is False:
                success_for_all_agents = False
                logger.critical(f"Test failed for host {host}. Check logs for more information")
                logger.critical(f"Evidences: {test_result[host]['evidences']}")

        results[test_name]['evidences'] = {}

        for agent in test_result.keys():
            if 'evidences' in test_result[agent]:
                for evidence, evidence_values in test_result[agent]['evidences'].items():
                    results[test_name]['evidences'][str(agent)+str(evidence)] = evidence_values

        if 'evidences' in test_result:
            results[test_name]['evidences'] = test_result['evidences']

        results[test_name] = test_result

        logger.critical("Final Results")

        assert success_for_all_agents is True, "Test failed. Check logs for more information"
