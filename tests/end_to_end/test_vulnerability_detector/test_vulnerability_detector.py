# Copyright (C) 2015, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2

"""
Vulnerability Detector Basic Cases Tests
----------------------------------------

Type: End-to-End (E2E)

Brief:
    This module contains basic tests to ensure the proper functionality of the Vulnerability Detector.
    The tests validate that initial Syscollector scans, along with installation, removal, and uninstall operations,
    trigger Vulnerability Detector scans, generating the expected vulnerabilities.
    The verification of vulnerabilities is conducted through Vulnerabilities Index and API endpoint
    Additionally, the tests ensure the consistency of these values.

Tests:
    - TestInitialScans: Validates the initiation of Syscollector scans across all agents in the environment.
        - test_syscollector_first_scan: Validates the initiation of the first Syscollector scans across all agents in the environment.
        - test_syscollector_first_scan_index: Validates that the Vulnerability Detector detects vulnerabilities within the environment in the first scan in the index.
        - test_syscollector_second_scan: Validates the initiation of the second Syscollector scans across all agents in the environment.
        - tests_syscollector_first_second_scan_consistency_index: Ensure the consistency of the agent's vulnerabilities between the first and second scans in index.
    - TestScanSyscollectorCases: Validates the Vulnerability Detector's ability to detect new vulnerabilities in the environment.

Issue: https://github.com/wazuh/wazuh-qa/issues/4369

Components:
  - vulnerability_detector
  - syscollector

Environment: e2e_vulnerability_detector

Tiers: 0

Markers:
  - e2e
  - vulnerability_detector
  - tier0
"""
import os
import pytest
import logging
import yaml
import time
import datetime

from wazuh_testing.end_to_end import TestResult, Check, Evidence
from wazuh_testing.end_to_end.configuration import backup_configurations, restore_configuration, \
        configure_environment, save_indexer_credentials_into_keystore, change_agent_manager_ip, \
        load_vulnerability_detector_configurations
from wazuh_testing.end_to_end.logs import truncate_remote_host_group_files, check_errors_in_environment
from wazuh_testing.end_to_end.waiters import wait_until_vd_is_updated
from wazuh_testing.end_to_end.monitoring import generate_monitoring_logs, monitoring_events_multihost, monitoring_syscollector_scan_agents
from wazuh_testing.end_to_end.regex import get_event_regex
from wazuh_testing.end_to_end.indexer_api import get_indexer_values
from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.remote_operations_handler import launch_parallel_operations
from wazuh_testing.end_to_end.vulnerability_detector import get_vulnerabilities_from_states, get_vulnerabilities_from_states_by_agent
from wazuh_testing.modules.syscollector import TIMEOUT_SYSCOLLECTOR_SCAN


local_path = os.path.dirname(os.path.abspath(__file__))
current_dir = os.path.dirname(__file__)
configurations_dir = os.path.join(current_dir, "configurations")
configurations_paths = {
        'manager': os.path.join(configurations_dir, 'manager.yaml'),
        'agent': os.path.join(configurations_dir, 'agent.yaml')
        }

TIMEOUT_PER_AGENT_VULNERABILITY_SCAN = 100
AGENT_REGISTRATION_TIMEOUT = 15

expected_errors = [r'Invalid ID \d{3} for the source',
                   r'Unable to connect to .* No connection could be made because the target machine actively refused',
                   r'Process locked due to agent is offline. Waiting for connection']


def clean_agents(host_manager, restart_managers=False):
    """Clean and register agents

    Args:
        host_manager (HostManager): An instance of the HostManager class.
        restart_managers (bool, optional): Whether to restart the managers. Defaults to False.
    """
    # Restart managers and stop agents
    logging.info("Stopping agents")
    host_manager.control_environment('stop', ['agent'], parallel=True)

    # Re-Register agents: https://github.com/wazuh/wazuh/issues/21185
    logging.info("Removing agents")
    host_manager.remove_agents()

    if restart_managers:
        logging.info("Restarting managers")
        host_manager.control_environment('restart', ['manager'], parallel=True)

    # Truncate alerts and logs of managers and agents
    logging.info("Truncate managers and agents logs")

    truncate_remote_host_group_files(host_manager, 'all', 'logs')


@pytest.fixture(scope='function')
def configure_vulnerability_detection_test_environment(host_manager: HostManager, vulnerability_detection_previously_enabled: bool):
    """Configure the environment with the given configurations

    Args:
        host_manager (HostManager): An instance of the HostManager class.
        configurations (dict): The configurations to apply to the environment
    """
    hosts_configuration_backup = backup_configurations(host_manager)
    configure_environment(host_manager, load_vulnerability_detector_configurations(host_manager, configurations_paths=configurations_paths,
                                                                                   enable=vulnerability_detection_previously_enabled))

    logging.error("Save the Wazuh indexer username and password into the Wazuh manager keystore")
    save_indexer_credentials_into_keystore(host_manager)

    clean_agents(host_manager)

    utc_now_timestamp = datetime.datetime.utcnow()
    test_timestamp = utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%SZ")

    logging.error("Restarting managers")
    host_manager.control_environment('restart', ['manager'], parallel=True)

    if vulnerability_detection_previously_enabled:
        logging.error("Wait until Vulnerability Detector has update all the feeds")
        wait_until_vd_is_updated(host_manager)

    # Start agents
    host_manager.control_environment('restart', ['agent'], parallel=True)

    # Wait until agents are registered again
    time.sleep(AGENT_REGISTRATION_TIMEOUT * len(host_manager.get_group_hosts('agent')))

    if not vulnerability_detection_previously_enabled:

        configure_environment(host_manager, load_vulnerability_detector_configurations(host_manager, configurations_paths=configurations_paths,
                                                                                       enable=True))
        host_manager.control_environment('restart', ['manager'], parallel=True)

        logging.error("Wait until Vulnerability Detector has update all the feeds")
        wait_until_vd_is_updated(host_manager)

    yield test_timestamp

    # Truncate alerts and logs of managers and agents
    logging.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    logging.error("Restoring original configuration")
    restore_configuration(host_manager, hosts_configuration_backup)

    logging.error("Restarting environment")

    host_manager.control_environment('restart', ['agent'], parallel=True)
    host_manager.control_environment('restart', ['manager'], parallel=True)


@pytest.mark.filterwarnings('ignore::urllib3.exceptions.InsecureRequestWarning')
class TestInitialScans():

    @pytest.fixture(scope='function')
    def get_timestamp(self):
        utc_now_timestamp = datetime.datetime.utcnow()
        return utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%SZ")

    @pytest.fixture(scope='class')
    def get_agents_scanned_syscollector(self):
        agents_not_scanned_by_syscollector = {
                'first_scan': None,
                'second_scan': None
        }

        yield agents_not_scanned_by_syscollector

    @pytest.fixture(scope='class')
    def get_initial_vulnerabilities_environment(self):
        initial_vulnerabilities_environment = {
            'vd_disabled_when_agents_registration': None,
            'vd_enabled_when_agents_registration': None
        }

        yield initial_vulnerabilities_environment
        

    @pytest.mark.parametrize('vulnerability_detection_previously_enabled', [False, True], ids=['vd_disabled_when_agents_registration', 'vd_enabled_when_agents_registration'])
    def test_first_syscollector_scan(self, request, host_manager, vulnerability_detection_previously_enabled,
                                     configure_vulnerability_detection_test_environment,
                                     record_property, get_initial_vulnerabilities_environment, get_agents_scanned_syscollector):
        """
        description: Validates the initiation of the first Syscollector scans across all agents in the environment.

        This test ensures that Syscollector first scans are started in all agents in the environment.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - vulnerability_detection_previously_enabled:
                type: fixture
                brief: Whether the vulnerability detection was previously enabled
            - configure_environment:
                type: fixture
                brief: Configure the environment with the given configurations
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned
        """
        test_result = TestResult(request.node.name)
        test_result.add_check(Check('all_agents_scanned_syscollector_first_scan', lambda agents_not_scanned: len(agents_not_scanned) == 0,
                                    expected_evidences=['agents_not_scanned_syscollector_first_scan']))
        test_result.add_check(Check('all_agents_scanned_vulnerability_first_scan', lambda agents_not_scanned: len(agents_not_scanned) == 0,
                                    expected_evidences=['agents_not_scanned_vulnerability_first_scan']))
        test_result.add_check(Check('no_errors', lambda errors: all(len(error_level_value) == 0 for error_level_value in errors),
                              expected_evidences=['error_level_messages']))
        record_property('test_result', test_result)

        agents_not_scanned_first_scan = monitoring_syscollector_scan_agents(host_manager, TIMEOUT_SYSCOLLECTOR_SCAN)
        agents_to_check = [agent for agent in host_manager.get_group_hosts('agent') if agent not in agents_not_scanned_first_scan]

        test_result.get_check('all_agents_scanned_syscollector_first_scan').validate([Evidence('agents_not_scanned_syscollector_first_scan', agents_not_scanned_first_scan)])
        # Only is stored the last test case result in order to maake the comparision with the second scan
        get_agents_scanned_syscollector['first_scan'] = agents_not_scanned_first_scan

        if len(agents_to_check) == 0:
            pytest.fail("Syscollector scan not started in any agent. Check agent logs for more information")

        # Wait until all agents has been scanned. Timeout: 100 seconds per agent
        logging.critical(f"Waiting until agent all agents have been scanned.")
        time.sleep(TIMEOUT_PER_AGENT_VULNERABILITY_SCAN * len(agents_to_check))

        logging.critical("Checking vulnerabilities in the index")
        vuln_by_agent_index = get_vulnerabilities_from_states_by_agent(host_manager, agents_to_check, 
                                                                       greater_than_timestamp=configure_vulnerability_detection_test_environment)

        get_initial_vulnerabilities_environment['vd_disabled_when_agents_registration' if not vulnerability_detection_previously_enabled else 'vd_enabled_when_agents_registration'] = vuln_by_agent_index
        

        logging.critical("Checking that all agents has been scanned and generated vulnerabilities in the index")
        agent_not_scanned = []
        for agent, vulnerabilities in vuln_by_agent_index.items():
            # We expect at least one vulnerability in each agent
            if len(vulnerabilities) == 0:
                logging.critical(f"No vulnerabilities found for {agent}")
                agent_not_scanned.append(agent)


        test_result.get_check('all_agents_scanned_vulnerability_first_scan').validate([Evidence('agents_not_scanned_vulnerability_first_scan', 
                                                                                                agent_not_scanned),
                                                                                       Evidence('vulnerabilities_index_first_scan', 
                                                                                                vuln_by_agent_index, 
                                                                                                debug=True)])

        logging.critical("Checking for errors in the environment")
        unexpected_errors = check_errors_in_environment(host_manager, expected_errors=expected_errors)
        test_result.get_check('no_errors').validate([Evidence('error_level_messages', unexpected_errors)])

        assert test_result.get_test_result(), test_result.report()

    def test_consistency_initial_scans(self, request, host_manager, get_initial_vulnerabilities_environment, record_property):
        """
        description: Ensure the consistency of the agent's vulnerabilities neither the agent was registered nor the vulnerability detection was enabled.

        This test ensures that the agent's vulnerabilities are consistent with the initial scan.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment

        assertions:
            - Verify that the number of vulnerabilities is the same between scans
        """
        test_result = TestResult(request.node.name)
        test_result.add_check(Check('initial_vulnerabilities_consistent', lambda initial_vulnerabilities: initial_vulnerabilities['vd_disabled_when_agents_registration'] == initial_vulnerabilities['vd_enabled_when_agents_registration'], 
                                    expected_evidences=['different_vulnerabilities']))
    
        record_property('test_result', test_result)
        test_result.get_check('initial_vulnerabilities_consistent').validate([Evidence('different_vulnerabilities', get_initial_vulnerabilities_environment)])

        assert test_result.get_test_result(), test_result.report()


    def test_syscollector_second_scan(self, get_timestamp, request, host_manager, 
                                      record_property,
                                      get_agents_scanned_syscollector, get_initial_vulnerabilities_environment):
        """
        description: Validates the initiation of the second Syscollector scans across all agents in the environment.

        This test ensures that Syscollector second scans are started in all agents in the environment.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """
        TIMEOUT_SECOND_SCAN = 60
        test_result = TestResult(request.node.name)
        test_result.add_check(Check('all_agents_scanned_syscollector_second_scan', lambda agents_not_scanned: len(agents_not_scanned) == 0,
                                    expected_evidences=['agents_not_scanned_syscollector_second_scan']))
        test_result.add_check(Check('no_errors', lambda errors: all(len(error_level_value) == 0 for error_level_value in errors),
                                expected_evidences=['error_level_messages']))
        test_result.add_check(Check('vulnerabilities_consistent_with_first_scan', lambda vulnerabilities_first_scan, vulnerabilities_second_scan: vulnerabilities_first_scan == vulnerabilities_second_scan,
                                expected_evidences=['vulnerabilities_index_first_scan', 'vulnerabilities_index_second_scan']))
        record_property('test_result', test_result)

        if get_agents_scanned_syscollector['first_scan'] is None:
            pytest.skip("First scan was not executed. Skipping test")

        agents_not_scanned_first_scan = get_agents_scanned_syscollector['first_scan']

        # Filter agents that has not been scanned
        agents_to_check = [agent for agent in host_manager.get_group_hosts('agent') if agent not in agents_not_scanned_first_scan]
        if len(agents_to_check) == 0:
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        agents_not_scanned_second_scan = monitoring_syscollector_scan_agents(host_manager, TIMEOUT_SYSCOLLECTOR_SCAN)
        agents_to_check = [agent for agent in agents_to_check if agent not in agents_not_scanned_second_scan]

        test_result.get_check('all_agents_scanned_syscollector_second_scan').validate([Evidence('agents_not_scanned_syscollector_second_scan', agents_not_scanned_second_scan)])

        get_agents_scanned_syscollector['second_scan'] = agents_not_scanned_second_scan

        if len(agents_to_check) == 0:
            pytest.fail("Syscollector scan not started in any agent. Check agent logs for more information")

        logging.critical(f"Waiting until agent all agents have been scanned.")
        time.sleep(TIMEOUT_SECOND_SCAN)

        logging.critical("Checking vulnerabilities in the index")
        vuln_by_agent_index = get_vulnerabilities_from_states_by_agent(host_manager, agents_to_check, greater_than_timestamp=get_timestamp)

        logging.critical("Checking that all agents has been scanned and generated vulnerabilities in the index")
        test_result.get_check('vulnerabilities_consistent_with_first_scan').validate([Evidence('vulnerabilities_index_first_scan', 
                                                                                             get_initial_vulnerabilities_environment['vd_enabled_when_agents_registration']),
                                                                                    Evidence('vulnerabilities_index_second_scan', 
                                                                                             vuln_by_agent_index)])

        unexpected_errors = check_errors_in_environment(host_manager, expected_errors=expected_errors)
        test_result.get_check('no_errors').validate([Evidence('error_level_messages', unexpected_errors)])

        assert test_result.get_test_result(), test_result.report()

        import pdb; pdb.set_trace()

# -------------------------


# Load basic tests cases
cases = {}

with open(os.path.join(current_dir, os.path.join('cases', 'test_vulnerability.yaml')), 'r') as cases_file:
    cases = yaml.load(cases_file, Loader=yaml.FullLoader)

complete_list = [
    (
        case['preconditions'] if 'preconditions' in case else None,
        case['body'] if 'body' in case else None,
        case['teardown'] if 'teardown' in case else None
    )
    for case in cases
]

list_ids = [case['id'] for case in cases]

####

cases_change_manager = {}

with open(os.path.join(current_dir, os.path.join('cases', 'change_manager_cases.yaml')), 'r') as cases_file:
    cases_change_manager = yaml.load(cases_file, Loader=yaml.FullLoader)

test_cases_change_manager = [
    (
        case['preconditions'] if 'preconditions' in case else None,
        case['body'] if 'body' in case else None,
        case['teardown'] if 'teardown' in case else None
    )
    for case in cases_change_manager
]

list_ids_change_manager = [case['id'] for case in cases_change_manager]

class TestScanSyscollectorCases():
    results = {}

    @pytest.fixture(scope='class')
    def get_results(self):
        return self.results

    @pytest.fixture(scope='function')
    def permutate_agents_managers(self, host_manager):

        configuration_backup = backup_configurations(host_manager)
        list_of_managers = host_manager.get_group_hosts('manager')

        for agent in host_manager.get_group_hosts('agent'):
            agent_current_manager = host_manager.get_host_variables(agent)['manager']
            manager_index = list_of_managers.index(agent_current_manager)
            next_manager = list_of_managers[(manager_index + 1)%len(list_of_managers)]
            agent_os = host_manager.get_host_variables(agent)['os_name']

            manager_ip = host_manager.get_host_variables(next_manager)['public_ip'] if agent_os == 'macos' \
                    else host_manager.get_host_variables(next_manager)['ip']

            change_agent_manager_ip(host_manager, agent, manager_ip)

        yield

        logging.error("Restoring original configuration")

        restore_configuration(host_manager, configuration_backup)


    @pytest.mark.parametrize('preconditions, body, teardown', test_cases_change_manager, ids=list_ids_change_manager)
    def test_change_agent_manager(self, permutate_agents_managers, request, preconditions, body, teardown, setup,
                                  host_manager, get_results):
        setup_results = setup
        results = get_results
        test_name = request.node.name
        results[request.node.name] = {}
        results['setup'] = setup_results

        hosts_to_ignore = []

        for host in setup_results.keys():
            if setup_results[host]['checks']['all_successfull'] is False:
                hosts_to_ignore.append(host)

        if len(hosts_to_ignore) > 0:
            logging.critical(f"Setup test failed for hosts {hosts_to_ignore}. Check logs for more information")
            logging.critical(f"Evidences: {setup_results}")
            logging.critical("Ignoring these hosts for the rest of the test")

        logging.critical("Starting scan cases tests")
        logging.critical(f"Case Info: {body}")

        # Launch tests tasks
        test_result = launch_parallel_operations(body['tasks'], host_manager, hosts_to_ignore)

        success_for_all_agents = True

        for host in test_result.keys():
            if test_result[host]['checks']['all_successfull'] is False:
                success_for_all_agents = False
                logging.critical(f"Test failed for host {host}. Check logs for more information")
                logging.critical(f"Evidences: {test_result[host]['evidences']}")

        results[test_name]['evidences'] = {}

        for agent in test_result.keys():
            if 'evidences' in test_result[agent]:
                for evidence, evidence_values in test_result[agent]['evidences'].items():
                    results[test_name]['evidences'][str(agent)+str(evidence)] = evidence_values

        if 'evidences' in test_result:
            results[test_name]['evidences'] = test_result['evidences']

        results[test_name] = test_result

        assert success_for_all_agents is True, "Test failed. Check logs for more information"


    @pytest.mark.parametrize('preconditions, body, teardown', complete_list, ids=list_ids)
    def test_vulnerability_detector_scans_cases(self, request, preconditions, body, teardown, setup,
                                                host_manager, get_results):
        test_name = request.node.name

        setup_results = setup
        results = get_results
        results[request.node.name] = {}
        results['setup'] = setup_results

        hosts_to_ignore = []

        for host in setup_results.keys():
            if setup_results[host]['checks']['all_successfull'] is False:
                hosts_to_ignore.append(host)

        if len(hosts_to_ignore) > 0:
            logging.critical(f"Setup test failed for hosts {hosts_to_ignore}. Check logs for more information")
            logging.critical(f"Evidences: {setup_results}")
            logging.critical("Ignoring these hosts for the rest of the test")

        logging.critical("Starting scan cases tests")
        logging.critical(f"Case Info: {body}")

        # Launch tests tasks
        test_result = launch_parallel_operations(body['tasks'], host_manager, hosts_to_ignore)

        success_for_all_agents = True

        for host in test_result.keys():
            if test_result[host]['checks']['all_successfull'] is False:
                success_for_all_agents = False
                logging.critical(f"Test failed for host {host}. Check logs for more information")
                logging.critical(f"Evidences: {test_result[host]['evidences']}")

        results[test_name]['evidences'] = {}

        for agent in test_result.keys():
            if 'evidences' in test_result[agent]:
                for evidence, evidence_values in test_result[agent]['evidences'].items():
                    results[test_name]['evidences'][str(agent)+str(evidence)] = evidence_values

        if 'evidences' in test_result:
            results[test_name]['evidences'] = test_result['evidences']

        results[test_name] = test_result

        assert success_for_all_agents is True, "Test failed. Check logs for more information"
