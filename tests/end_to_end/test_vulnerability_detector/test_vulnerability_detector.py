# Copyright (C) 2015, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2

"""
Vulnerability Detector Basic Cases Tests
----------------------------------------

Type: End-to-End (E2E)

Brief:
    This module contains basic tests to ensure the proper functionality of the Vulnerability Detector.
    The tests validate that initial Syscollector scans, along with installation, removal, and uninstall operations,
    trigger Vulnerability Detector scans, generating the expected vulnerabilities.
    The verification of vulnerabilities is conducted through Vulnerabilities Index and API endpoint
    Additionally, the tests ensure the consistency of these values.

Tests:
    - test_syscollector_initial_agent_scan:
        Validates the initiation of Syscollector scans across all agents in the environment.
        Subsequently, it ensures that the Vulnerability Detector detects vulnerabilities within the environment.
        The Agent's Vulnerability Indexer index is expected to be updated with the detected vulnerabilities.

Issue: https://github.com/wazuh/wazuh-qa/issues/4369

Components:
  - vulnerability_detector
  - syscollector

Environment: e2e_vulnerability_detector

Tiers: 0

Markers:
  - e2e
  - vulnerability_detector
  - tier0
"""
import os
import pytest
import logging
import yaml
import time
import ast
import datetime
from typing import Generator

from wazuh_testing.end_to_end.configuration import backup_configurations, restore_configuration, \
        configure_environment, save_indexer_credentials_into_keystore
from wazuh_testing.end_to_end.logs import truncate_remote_host_group_files
from wazuh_testing.end_to_end.waiters import wait_until_vd_is_updated
from wazuh_testing.end_to_end.monitoring import generate_monitoring_logs, monitoring_events_multihost
from wazuh_testing.end_to_end.regex import get_event_regex
from wazuh_testing.end_to_end.indexer_api import get_indexer_values
from wazuh_testing.tools.configuration import load_configuration_template
from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.remote_operations_handler import launch_parallel_operations
from wazuh_testing.end_to_end.vulnerability_detector import parse_vulnerability_detector_alerts, \
        check_vuln_state_consistency
from wazuh_testing.modules.syscollector import TIMEOUT_SYSCOLLECTOR_SCAN


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

local_path = os.path.dirname(os.path.abspath(__file__))
current_dir = os.path.dirname(__file__)
configurations_dir = os.path.join(current_dir, "configurations")
configurations_paths = {
        'manager': os.path.join(configurations_dir, 'manager.yaml'),
        'agent': os.path.join(configurations_dir, 'agent.yaml')
        }
vulnerability_detector_logs_dir = os.path.join(current_dir, "logs")

TIMEOUT_PER_AGENT_VULNERABILITY_SCAN = 200


def load_vulnerability_detector_configurations(host_manager):
    """Return the configurations for Vulnerability testing for the agent and manager roles

    Return:
        Dict: Configurations for each role
    """
    configurations = {}

    for host in host_manager.get_group_hosts('all'):
        if host in host_manager.get_group_hosts('agent'):
            configurations[host] = load_configuration_template(configurations_paths['agent'], [{}], [{}])
        elif host in host_manager.get_group_hosts('manager'):
            configuration_template = load_configuration_template(configurations_paths['manager'], [{}], [{}])

            # Replace placeholders by real values
            manager_index = host_manager.get_group_hosts('manager').index(host) + 2
            indexer_server = host_manager.get_group_hosts('indexer')[0]
            indexer_server_variables = host_manager.get_host_variables(indexer_server)
            configuration_variables = {
                'INDEXER_SERVER': indexer_server_variables['ip'],
                'FILEBEAT_ROOT_CA': '/etc/pki/filebeat/root-ca.pem',
                'FILEBEAT_CERTIFICATE': f"/etc/pki/filebeat/node-{manager_index}.pem",
                'FILEBEAT_KEY': f"/etc/pki/filebeat/node-{manager_index}-key.pem"
            }
            configuration_template_str = str(configuration_template)

            for key, value in configuration_variables.items():
                configuration_template_str = configuration_template_str.replace(key, value)

            configurations[host] = ast.literal_eval(configuration_template_str)

    return configurations


@pytest.fixture(scope='module')
def setup_vulnerability_tests(host_manager: HostManager) -> Generator:
    """Setup the vulnerability tests environment

    Args:
        host_manager (HostManager): An instance of the HostManager class.
    """
    logger.error("Init setup of environment")

    # Configure managers and agents
    logger.error("Getting backup of current configurations")
    hosts_configuration_backup = backup_configurations(host_manager)

    logger.error("Configuring environment")
    configure_environment(host_manager, load_vulnerability_detector_configurations(host_manager))

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    # Restart managers and stop agents
    logger.error("Stopping agents")
    host_manager.control_environment('stop', ['agent'])
    logger.error("Restarting managers")
    host_manager.control_environment('restart', ['manager'])

    logger.error("Save the Wazuh indexer username and password into the Wazuh manager keystore")
    save_indexer_credentials_into_keystore(host_manager)

    logger.error("Restarting managers")
    host_manager.control_environment('restart', ['manager'])

    utc_now_timestamp = datetime.datetime.utcnow()

    # Format the date and time as per the given format
    test_timestamp = utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%SZ")

    # Wait until VD is updated
    logger.error("Wait until Vulnerability Detector has update all the feeds")
    wait_until_vd_is_updated(host_manager)

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    # Re-Register agents: https://github.com/wazuh/wazuh/issues/21185
    logger.error("Removing agents")
    host_manager.remove_agents()

    # Wait until agents are registered again
    time.sleep(15)

    # Start agents
    host_manager.control_environment('start', ['agent'])

    yield test_timestamp

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    logger.error("Restoring original configuration")
    restore_configuration(host_manager, hosts_configuration_backup)

    logger.error("Restarting environment")
    host_manager.control_environment('restart', ['agent'])
    host_manager.control_environment('restart', ['manager'])


@pytest.mark.filterwarnings('ignore::urllib3.exceptions.InsecureRequestWarning')
class TestInitialScans():
    results = {}

    @pytest.fixture(scope='class')
    def get_results(self):
        return self.results

    def test_syscollector_first_scan(self, request, host_manager, setup_vulnerability_tests, get_results):
        """
        description: Validates the initiation of Syscollector scans across all agents in the environment.

        This test ensures that the Vulnerability Detector accurately detects vulnerabilities within the environment.
        The Agent's Vulnerability Indexer index is expected to be updated with the detected vulnerabilities.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that syscollector scan is started after agent start in all agents

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """
        results = get_results
        test_name = request.node.name

        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'agents_not_scanned_first_scan': []
                }
        }

        logger.critical("Monitoring syscollector first scan")
        list_hosts = host_manager.get_group_hosts('agent')
        monitoring_data = generate_monitoring_logs(host_manager,
                                                   [get_event_regex({'event': 'syscollector_scan_start'}),
                                                    get_event_regex({'event': 'syscollector_scan_end'})],
                                                   [TIMEOUT_SYSCOLLECTOR_SCAN, TIMEOUT_SYSCOLLECTOR_SCAN],
                                                   list_hosts)
        monitoring_results = monitoring_events_multihost(host_manager, monitoring_data)

        logger.critical(f"Value of monitoring results is: {monitoring_results}")

        for agent in monitoring_results:
            if monitoring_results[agent]['not_found']:
                test_result['checks']['all_successfull'] = False
                test_result['evidences']['agents_not_scanned_first_scan'].append(agent)

        results[test_name] = test_result

        if not test_result['checks']['all_successfull']:
            logging_message = 'Syscollector scan not started in the following agents:' \
                    f"{test_result['evidences']['agents_not_scanned_first_scan']}."
            logger.critical(logging_message)
            pytest.fail(logging_message)
        else:
            logger.critical("All agents has been scanned")


    def test_syscollector_first_scan_alerts(self, request, host_manager, setup_vulnerability_tests, get_results):
        """
        description: Validates that the Vulnerability Detector detects vulnerabilities within the environment in the
        first scan.

        This test ensures that the Vulnerability Detector accurately detects vulnerabilities within the environment.
        It is assumed that provided hosts will have at least one vulnerability.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned
            - Verify that all agents has generated vulnerabilities

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """
        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'agents_not_detected_alerts': [],
                    'vulnerabilities_alerts_first_scan': []
                }
        }

        results = get_results
        test_name = request.node.name

        # Filter agents that has not been scanned
        agents_to_check = [agent for agent in host_manager.get_group_hosts('agent') if agent not in
                           results['test_syscollector_first_scan']['evidences']['agents_not_scanned_first_scan']]

        if len(agents_to_check) == 0:
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        # Wait until all agents has been scanned. Timeout: 60 seconds per agent
        for agent in host_manager.get_group_hosts('agent'):
            logger.critical(f"Waiting until agent {agent} has been scanned."
                            f"Waiting: {TIMEOUT_PER_AGENT_VULNERABILITY_SCAN}")
            time.sleep(TIMEOUT_PER_AGENT_VULNERABILITY_SCAN)

        logger.critical("Check agent's vulnerabilities")

        vuln_by_agent_alerts = {}
        for agent in agents_to_check:
            agent_all_alerts = get_indexer_values(host_manager,
                                                  greater_than_timestamp=setup_vulnerability_tests,
                                                  agent=agent)['hits']['hits']

            # Only is expected alert of affected vulnerabilities
            vuln_by_agent_alerts[agent] = parse_vulnerability_detector_alerts(agent_all_alerts)['affected']

        test_result['evidences']['vulnerabilities_alerts_first_scan'] = vuln_by_agent_alerts

        # Check that it has been triggered vulnerability detector alerts
        logger.critical("Checking that all agents has been scanned")
        for agent in agents_to_check:
            if agent not in list(vuln_by_agent_alerts.keys()) or \
                    len(vuln_by_agent_alerts[agent]) == 0:
                logger.critical(f"Agent {agent} has not been scanned. Continuing with remaining agents")
                test_result['checks']['all_successfull'] = False
                test_result['evidences']['agents_not_detected_alerts'].append(agent)

        results[test_name] = test_result

        # Store full alert list in global results. It is needed for the next test
        results['vulnerabilities_alerts_first_scan'] = vuln_by_agent_alerts


        if not test_result['checks']['all_successfull']:
            logging_message = 'Some agents has not been scanned:' \
                    f"{test_result['evidences']['agents_not_detected_alerts']}."
            logger.critical(logging_message)
            pytest.fail(logging_message)
        else:
            logger.critical("All agents has been scanned")

    def test_syscollector_first_scan_index(self, request, host_manager, setup_vulnerability_tests, get_results):
        """
        description: Validates that the Vulnerability Detector detects vulnerabilities within the environment in the
        first scan in the index.

        This test ensures that the Vulnerability Detector accurately detects vulnerabilities within the environment in
        the index. It is assumed that provided hosts will have at least one vulnerability.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned
            - Verify that all agents has generated vulnerabilities in the index

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """
        results = get_results
        test_name = request.node.name
        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'agents_not_detected_index_vulnerabilities': [],
                    'vulnerabilities_index_first_scan': []
                }
        }

        # Filter agents that has not been scanned
        agents_to_check = [agent for agent in host_manager.get_group_hosts('agent') if agent not in
                           results['test_syscollector_first_scan']['evidences']['agents_not_scanned_first_scan']]

        if len(agents_to_check) == 0:
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        # Check vulnerabilities in the index
        logger.critical("Checking vulnerabilities in the index")
        vuln_by_agent_index = {}

        for agent in agents_to_check:
            agent_all_vulnerabilities = get_indexer_values(host_manager, greater_than_timestamp=setup_vulnerability_tests, agent=agent, index='wazuh-states-vulnerabilities',)['hits']['hits']

            vuln_by_agent_index[agent] = agent_all_vulnerabilities


        test_result['evidences']['vulnerabilities_index_first_scan'] = vuln_by_agent_index

        logger.critical("Checking that all agents has been scanned and generated vulnerabilities in the index")
        for agent in agents_to_check:
            if agent not in list(vuln_by_agent_index.keys()) or \
                    len(vuln_by_agent_index[agent]) == 0:

                logger.critical(f"Agent {agent} has not been scanned. Continuing with remaining agents")
                test_result['checks']['all_successfull'] = False
                test_result['evidences']['agents_not_detected_index_vulnerabilities'].append(agent)

        results[test_name] = test_result

        # Store full alert index list in global results. It is needed for the next test
        results['vulnerabilities_index_first_scan'] = vuln_by_agent_index

        if not test_result['checks']['all_successfull']:
            logging_message = 'Some agents has not been scanned and generated vulnerabilities in the index:' \
                    f"{test_result['evidences']['agents_not_detected_index_vulnerabilities']}."
            logger.critical(logging_message)
            pytest.fail(logging_message)
        else:
            logger.critical("All agents has been scanned and updated states index")


    def tests_syscollector_vulnerabilities_index_alerts_consistency(self, request,
                                                                    setup_vulnerability_tests, get_results):
        """
        description: Ensure the consistency of the agent's vulnerabilities between the index and the alerts.

        This test ensure that alerts in the index are consistent with the alerts in the alerts index after the first
        scan.

        tier: 0

        parameters:
            - request: pytest request object
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that the index is consistent with the alerts

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """
        results = get_results
        test_name = request.node.name
        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'alerts_not_in_states': [],
                    'states_not_in_alerts': [],
                    'alerts_first_scan': results['vulnerabilities_alerts_first_scan'],
                    'states_first_scan': results['vulnerabilities_index_first_scan']
                }
        }

        # Check that the index is consistent with the alerts
        logging.critical("Checking index state consistency")
        inconsistencies_between_alerts_indexer = \
            check_vuln_state_consistency(results['vulnerabilities_alerts_first_scan'],
                                         results['vulnerabilities_index_first_scan'])

        test_result['evidences']['alerts_not_in_states'] = \
            inconsistencies_between_alerts_indexer['alerts_not_in_states']

        test_result['evidences']['states_not_in_alerts'] = \
            inconsistencies_between_alerts_indexer['states_not_in_alerts']

        if len(test_result['evidences']['alerts_not_in_states']) > 0 or \
                len(test_result['evidences']['states_not_in_alerts']) > 0:
            logger.critical("Index state is not consistent with the alerts")
            test_result['checks']['all_successfull'] = False

        results[test_name] = test_result

        if not test_result['checks']['all_successfull']:
            logging_message = "Index state is not consistent with the alerts"
            logger.critical(logging_message)
            logger.critical(f"Alerts not in states: {test_result['evidences']['alerts_not_in_states']}")
            logger.critical(f"States not in alerts: {test_result['evidences']['states_not_in_alerts']}")
            pytest.fail(logging_message)
        else:
            logger.critical("Index state is consistent with the alerts")

    def test_syscollector_second_scan(self, request, host_manager, setup_vulnerability_tests, get_results):
        """
        description: Validates the initiation of the second Syscollector scans across all agents in the environment.

        This test ensures that Syscollector second scans are started in all agents in the environment.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """

        results = get_results
        test_name = request.node.name
        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'agents_syscollector_second_scan_not_started': []
                }
        }

        # Filter agents that has not been scanned
        agents_to_check = [agent for agent in host_manager.get_group_hosts('agent') if agent not in
                           results['test_syscollector_first_scan']['evidences']['agents_not_scanned_first_scan']]

        if len(agents_to_check) == 0:
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        monitoring_data = generate_monitoring_logs(host_manager,
                                                   [get_event_regex({'event': 'syscollector_scan_start'}),
                                                    get_event_regex({'event': 'syscollector_scan_end'})],
                                                   [TIMEOUT_SYSCOLLECTOR_SCAN, TIMEOUT_SYSCOLLECTOR_SCAN],
                                                   host_manager.get_group_hosts('agent'), 2)

        monitoring_results = monitoring_events_multihost(host_manager, monitoring_data)

        logger.critical("Checking that all agents has been scanned")
        for agent in monitoring_results:
            if monitoring_results[agent]['not_found']:
                test_result['checks']['all_successfull'] = False
                test_result['evidences']['agents_syscollector_second_scan_not_started'].append(agent)

                logging.critical(f"Syscollector scan not started in the following agents:"
                                 f"{test_result['evidences']['agents_syscollector_second_scan_not_started']}."
                                 'Continuing with the test')

        results[test_name] = test_result

        if not test_result['checks']['all_successfull']:
            logging_message = "Syscollector scan not started in the following agents:" \
                    f"{test_result['evidences']['agents_syscollector_second_scan_not_started']}."
            pytest.fail(logging_message)
        else:
            logger.critical("Syscollector scan started in all agents")

    def tests_syscollector_first_second_scan_consistency_alerts(self, request, host_manager, setup_vulnerability_tests,
                                                                get_results):
        """
        description: Ensure the consistency of the agent's vulnerabilities between the first and second scans.

        This test ensure that alerts in the first scan are consistent with the alerts in the second scan.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that the number of vulnerabilities is the same between scans

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """

        test_name = request.node.name
        results = get_results
        request = request
        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'vulnerabilities_not_equal_between_scans_alerts': [],
                    'agents_different_between_scans': [],
                    'vulnerabilities_alerts_first_scan': results['vulnerabilities_alerts_first_scan'],
                    'vulnerabilities_alerts_second_scan': []
                }
        }

        # Filter agents that has not been scanned
        agents_to_check = [agent for agent in host_manager.get_group_hosts('agent') if agent not in
                           results['test_syscollector_first_scan']['evidences']['agents_not_scanned_first_scan']]

        if len(agents_to_check) == 0:
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        logger.critical("Waiting until agent's VD scan is over")
        # Only wait for the first agent. Any possible discrepancy will be detected in this interval
        time.sleep(TIMEOUT_PER_AGENT_VULNERABILITY_SCAN)

        logger.critical("Checking vulnerabilities in the second scan")

        vuln_by_agent_alert_second_scan = {}
        for agent in agents_to_check:
            agent_all_alerts = get_indexer_values(host_manager,
                                                  greater_than_timestamp=setup_vulnerability_tests,
                                                  agent=agent)['hits']['hits']
            # Only is expected alert of affected vulnerabilities
            vuln_by_agent_alert_second_scan[agent] = parse_vulnerability_detector_alerts(agent_all_alerts)['affected']

        # Store full alert list in global results. It is needed for the next test
        results['vulnerabilities_alerts_second_scan'] = vuln_by_agent_alert_second_scan
        test_result['evidences']['vulnerabilities_alerts_second_scan'] = vuln_by_agent_alert_second_scan

        alert_present_in_first_scan_not_in_second_scan = []
        alert_present_in_second_scan_not_in_first_scan = []

        logger.critical("Checking that all agents has been scanned")
        # Check if the number of agents for each scan is the same
        if len(vuln_by_agent_alert_second_scan.keys()) != len(results['vulnerabilities_alerts_first_scan'].keys()):
            test_result['checks']['all_successfull'] = False
            logging.critical(f"Agents with vulnerabilities changed between scans: "
                             f"First scan: {list(results['vulnerabilities_alerts_first_scan'].keys())}"
                             f"Second scan: {list(vuln_by_agent_alert_second_scan.keys())}")

            test_result['evidences']['agents_different_between_scans'] = \
                list(set(list(results['vulnerabilities_alerts_first_scan'].keys())) ^
                     set(list(results['vulnerabilities_alerts_second_scan'].keys())))

        logger.critical("Checking the number of vulnerabilities for each agent")
        for agent in agents_to_check:
            if agent in list(results['vulnerabilities_alerts_first_scan'].keys()) and \
                    len(results['vulnerabilities_alerts_first_scan'][agent]):
                for alert in list(vuln_by_agent_alert_second_scan[agent][0]):
                    if alert not in results['vulnerabilities_alerts_first_scan'][agent][0]:
                        alert_present_in_second_scan_not_in_first_scan.append(alert)

                for alert in list(results['vulnerabilities_alerts_first_scan'][agent][0]):
                    if alert not in vuln_by_agent_alert_second_scan[agent][0]:
                        alert_present_in_first_scan_not_in_second_scan.append(alert)

        logger.critical("Checking that all agents has been scanned")
        if alert_present_in_first_scan_not_in_second_scan or alert_present_in_second_scan_not_in_first_scan:
            test_result['checks']['all_successfull'] = False
            test_result['evidences']['vulnerabilities_not_equal_between_scans_alerts'] = {
                'alert_present_in_first_scan_not_in_second_scan': alert_present_in_first_scan_not_in_second_scan,
                'alert_present_in_second_scan_not_in_first_scan': alert_present_in_second_scan_not_in_first_scan
            }

        results[test_name] = test_result

        if not test_result['checks']['all_successfull']:
            logging_message = "Inconsistencies found between first and second scan." \
                    "Check evidences for more information"
            logger.critical(logging_message)
            pytest.fail(logging_message)
        else:
            logger.critical("The number of vulnerabilities is the same between scans")


    def tests_syscollector_first_second_scan_consistency_index(self, request, host_manager, setup_vulnerability_tests,
                                                               get_results):
        """
        description: Ensure the consistency of the agent's vulnerabilities between the first and second scans in index.

        This test ensure that alerts in the first scan are consistent with the alerts in the second scan in the index.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that the number of vulnerabilities is the same between scans

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """

        results = get_results
        test_name = request.node.name
        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'vulnerabilities_not_equal_between_scans_indexer': [],
                    'vulnerabilities_index_first_scan': results['vulnerabilities_index_first_scan'],
                    'vulnerabilities_index_second_scan': []
                }
        }

        logger.critical("Checking vulnerabilities in the second scan")

        vuln_by_agent_index_second_scan = {}
        for agent in host_manager.get_group_hosts('agent'):
            agent_all_vulnerabilities = get_indexer_values(host_manager,
                                                  greater_than_timestamp=setup_vulnerability_tests,
                                                  index='wazuh-states-vulnerabilities',
                                                  agent=agent)['hits']['hits']
            # Only is expected alert of affected vulnerabilities
            vuln_by_agent_index_second_scan[agent] = agent_all_vulnerabilities

        results['vulnerabilities_index_second_scan'] = vuln_by_agent_index_second_scan
        test_result['evidences']['vulnerabilities_index_second_scan'] = vuln_by_agent_index_second_scan

        differences = list(set(results['vulnerabilities_index_first_scan']).symmetric_difference(
            set(results['vulnerabilities_index_second_scan'])))

        results[test_name] = test_result

        if differences:
            test_result['checks']['all_successfull'] = False
            results[test_name]['evidences']['vulnerabilities_not_equal_between_scans_indexer'] = differences
            logging.critical("Inconsistencies found between first and second scan in the index."
                             f"Check evidences for more information: {differences}")
            pytest.fail('The number of vulnerabilities is not the same between scans')
        else:
            logger.critical("The number of vulnerabilities is the same between scans")

# -------------------------


cases = {}

with open(os.path.join(current_dir, os.path.join('cases', 'test_vulnerability.yaml')), 'r') as cases_file:
    cases = yaml.load(cases_file, Loader=yaml.FullLoader)

complete_list = [
    (
        case['preconditions'] if 'preconditions' in case else None,
        case['body'] if 'body' in case else None,
        case['teardown'] if 'teardown' in case else None
    )
    for case in cases
]

list_ids = [case['id'] for case in cases]


class TestScanSyscollectorCases():
    results = {}

    @pytest.fixture(scope='class')
    def get_results(self):
        return self.results

    @pytest.mark.parametrize('preconditions, body, teardown', complete_list, ids=list_ids)
    def test_vulnerability_detector_scans_cases(self, setup_vulnerability_tests, request, preconditions, body, teardown, setup,
                                                host_manager, get_results):
        test_name = request.node.name

        setup_results = setup
        results = get_results
        results[request.node.name] = {}
        results['setup'] = setup_results

        hosts_to_ignore = []

        for host in setup_results.keys():
            if setup_results[host]['checks']['all_successfull'] is False:
                hosts_to_ignore.append(host)

        if len(hosts_to_ignore) > 0:
            logger.critical(f"Setup test failed for hosts {hosts_to_ignore}. Check logs for more information")
            logger.critical(f"Evidences: {setup_results}")
            logger.critical("Ignoring these hosts for the rest of the test")

        logger.critical("Starting scan cases tests")
        logger.critical(f"Case Info: {body}")

        # Launch tests tasks
        test_result = launch_parallel_operations(body['tasks'], host_manager, hosts_to_ignore)

        success_for_all_agents = True

        for host in test_result.keys():
            if test_result[host]['checks']['all_successfull'] is False:
                success_for_all_agents = False
                logger.critical(f"Test failed for host {host}. Check logs for more information")
                logger.critical(f"Evidences: {test_result[host]['evidences']}")

        results[test_name]['evidences'] = {}

        for agent in test_result.keys():
            if 'evidences' in test_result[agent]:
                for evidence, evidence_values in test_result[agent]['evidences'].items():
                    results[test_name]['evidences'][str(agent)+str(evidence)] = evidence_values

        if 'evidences' in test_result:
            results[test_name]['evidences'] = test_result['evidences']

        results[test_name] = test_result

        logger.critical("Final Results")

        assert success_for_all_agents is True, "Test failed. Check logs for more information"
