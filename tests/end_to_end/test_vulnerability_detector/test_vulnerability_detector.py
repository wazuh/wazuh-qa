# Copyright (C) 2015, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2

"""
Vulnerability Detector Basic Cases Tests
----------------------------------------

Type: End-to-End (E2E)

Brief:
    This module contains basic tests to ensure the proper functionality of the Vulnerability Detector.
    The tests validate that initial Syscollector scans, along with installation, removal, and uninstall operations,
    trigger Vulnerability Detector scans, generating the expected vulnerabilities.
    The verification of vulnerabilities is conducted through Vulnerabilities Index and API endpoint
    Additionally, the tests ensure the consistency of these values.

Tests:
    - test_syscollector_initial_agent_scan:
        Validates the initiation of Syscollector scans across all agents in the environment.
        Subsequently, it ensures that the Vulnerability Detector detects vulnerabilities within the environment.
        The Agent's Vulnerability Indexer index is expected to be updated with the detected vulnerabilities.

Issue: https://github.com/wazuh/wazuh-qa/issues/4369

Components:
  - vulnerability_detector
  - syscollector

Environment: e2e_vulnerability_detector

Tiers: 0

Markers:
  - e2e
  - vulnerability_detector
  - tier0
"""
import os
import re
import pytest
import logging
import yaml
import time
import ast
import datetime
from typing import Generator

from wazuh_testing.end_to_end.configuration import backup_configurations, restore_configuration, \
        configure_environment, save_indexer_credentials_into_keystore, change_agent_manager_ip
from wazuh_testing.end_to_end.logs import truncate_remote_host_group_files, get_hosts_logs
from wazuh_testing.end_to_end.waiters import wait_until_vd_is_updated
from wazuh_testing.end_to_end.monitoring import generate_monitoring_logs, monitoring_events_multihost
from wazuh_testing.end_to_end.regex import get_event_regex
from wazuh_testing.end_to_end.indexer_api import get_indexer_values
from wazuh_testing.tools.configuration import load_configuration_template
from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.remote_operations_handler import launch_parallel_operations
from wazuh_testing.end_to_end.vulnerability_detector import parse_vulnerability_detector_alerts, \
        check_vuln_state_consistency
from wazuh_testing.modules.syscollector import TIMEOUT_SYSCOLLECTOR_SCAN


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

local_path = os.path.dirname(os.path.abspath(__file__))
current_dir = os.path.dirname(__file__)
configurations_dir = os.path.join(current_dir, "configurations")
configurations_paths = {
        'manager': os.path.join(configurations_dir, 'manager.yaml'),
        'agent': os.path.join(configurations_dir, 'agent.yaml')
        }
vulnerability_detector_logs_dir = os.path.join(current_dir, "logs")

TIMEOUT_PER_AGENT_VULNERABILITY_SCAN = 100
AGENT_REGISTRATION_TIMEOUT = 15


def check_errors_in_environment(host_manager: HostManager, greater_than_timestamp: str='') -> dict:
    """Check if there are errors in the environment

    Args:
        host_manager (HostManager): An instance of the HostManager class.
        greater_than_timestamp (str): Timestamp to filter the logs

    Returns:
        dict: Errors found in the environment
    """
    expected_errors = [r'Invalid ID \d{3} for the source', 
                       r'Unable to connect to .* No connection could be made because the target machine actively refused']

    error_level_to_search = ['ERROR', 'CRITICAL', 'WARNING']

    environment_logs = get_hosts_logs(host_manager)
    environment_level_logs = {}

    for host, environment_log in environment_logs.items():
        environment_level_logs[host] = {}
        for level in error_level_to_search:
            environment_level_logs[host][level] = []
            regex = re.compile(fr'((\d{{4}}\/\d{{2}}\/\d{{2}} \d{{2}}:\d{{2}}:\d{{2}}) (.+): ({level}):(.*))')

            matches = regex.findall(environment_log)

            for match in matches:
                if not any(re.match(error, match[0]) for error in expected_errors):
                    if greater_than_timestamp:
                        date_format = "%Y/%m/%d %H:%M:%S"
                        default_tiemstamp_format = "%Y-%m-%dT%H:%M:%S.%f"

                        date_filter_format = datetime.datetime.strptime(greater_than_timestamp, default_tiemstamp_format)
                        log_date = datetime.datetime.strptime(match[1], date_format)

                        if log_date > date_filter_format:
                            environment_level_logs[host][level].append(match[0])
                    else:
                        environment_level_logs[host][level].append(match)


    return environment_level_logs


def monitoring_syscollector_scan_agents(host_manager: HostManager, timeout: int) -> list:
    agents_not_scanned = []

    logger.critical("Monitoring syscollector first scan")
    list_hosts = host_manager.get_group_hosts('agent')
    monitoring_data = generate_monitoring_logs(host_manager,
                                               [get_event_regex({'event': 'syscollector_scan_start'}),
                                                get_event_regex({'event': 'syscollector_scan_end'})],
                                               [TIMEOUT_SYSCOLLECTOR_SCAN, TIMEOUT_SYSCOLLECTOR_SCAN],
                                               list_hosts)
    monitoring_results = monitoring_events_multihost(host_manager, monitoring_data)

    logger.critical(f"Value of monitoring results is: {monitoring_results}")

    for agent in monitoring_results:
        if monitoring_results[agent]['not_found']:
            agents_not_scanned.append(agent)

    return agents_not_scanned
        

def load_vulnerability_detector_configurations(host_manager, enable=True, syscollector_interval='1m'):
    """Return the configurations for Vulnerability testing for the agent and manager roles

    Return:
        Dict: Configurations for each role
    """
    configurations = {}
    vd_enable_value = 'yes' if enable else 'no'


    for host in host_manager.get_group_hosts('all'):
        if host in host_manager.get_group_hosts('agent'):
            configurations[host] = load_configuration_template(configurations_paths['agent'], [{}], [{}])

            configuration_template_str = str(configurations[host])
            configuration_variables = {
                    'SYSCOLLECTOR_INTERVAL': syscollector_interval
            }

            for key, value in configuration_variables.items():
                configuration_template_str = configuration_template_str.replace(key, value)
                configurations[host] = ast.literal_eval(configuration_template_str)

        elif host in host_manager.get_group_hosts('manager'):
            configuration_template = load_configuration_template(configurations_paths['manager'], [{}], [{}])

            # Replace placeholders by real values
            manager_index = host_manager.get_group_hosts('manager').index(host) + 2
            indexer_server = host_manager.get_group_hosts('indexer')[0]
            indexer_server_variables = host_manager.get_host_variables(indexer_server)
            configuration_variables = {
                'VULNERABILITY_DETECTOR_ENABLE': vd_enable_value,
                'INDEXER_SERVER': indexer_server_variables['ip'],
                'FILEBEAT_ROOT_CA': '/etc/pki/filebeat/root-ca.pem',
                'FILEBEAT_CERTIFICATE': f"/etc/pki/filebeat/node-{manager_index}.pem",
                'FILEBEAT_KEY': f"/etc/pki/filebeat/node-{manager_index}-key.pem"
            }
            configuration_template_str = str(configuration_template)

            for key, value in configuration_variables.items():
                configuration_template_str = configuration_template_str.replace(key, value)

            configurations[host] = ast.literal_eval(configuration_template_str)

    return configurations


def clean_agents(host_manager, restart_managers=False):
    """Clean and register agents

    Args:
        host_manager (HostManager): An instance of the HostManager class.
        restart_managers (bool, optional): Whether to restart the managers. Defaults to False.
    """
    # Restart managers and stop agents
    logger.error("Stopping agents")
    host_manager.control_environment('stop', ['agent'], parallel=True)
    
    # Re-Register agents: https://github.com/wazuh/wazuh/issues/21185
    logger.error("Removing agents")
    host_manager.remove_agents()

    if restart_managers:
        logger.error("Restarting managers")
        host_manager.control_environment('restart', ['manager'], parallel=True)

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")

    truncate_remote_host_group_files(host_manager, 'all', 'logs')


@pytest.fixture(scope='function')
def configure_vulnerability_detection_test_environment(host_manager: HostManager, vulnerability_detection_previously_enabled: bool):
    """Configure the environment with the given configurations

    Args:
        host_manager (HostManager): An instance of the HostManager class.
        configurations (dict): The configurations to apply to the environment
    """
    hosts_configuration_backup = backup_configurations(host_manager)
    configure_environment(host_manager, load_vulnerability_detector_configurations(host_manager, enable=vulnerability_detection_previously_enabled))

    logger.error("Save the Wazuh indexer username and password into the Wazuh manager keystore")
    save_indexer_credentials_into_keystore(host_manager)

    clean_agents(host_manager)

    utc_now_timestamp = datetime.datetime.utcnow()
    test_timestamp = utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%SZ")
    
    logger.error("Restarting managers")
    host_manager.control_environment('restart', ['manager'], parallel=True)

    if vulnerability_detection_previously_enabled:
        logger.error("Wait until Vulnerability Detector has update all the feeds")
        wait_until_vd_is_updated(host_manager)

    # Start agents
    host_manager.control_environment('restart', ['agent'], parallel=True)

    # Wait until agents are registered again
    time.sleep(AGENT_REGISTRATION_TIMEOUT * len(host_manager.get_group_hosts('agent')))

    if not vulnerability_detection_previously_enabled:
        configure_environment(host_manager, load_vulnerability_detector_configurations(host_manager, 
                                                                                       enable=True))
        host_manager.control_environment('restart', ['manager'], parallel=True)

        logger.error("Wait until Vulnerability Detector has update all the feeds")
        wait_until_vd_is_updated(host_manager)

    yield test_timestamp

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    logger.error("Restoring original configuration")
    restore_configuration(host_manager, hosts_configuration_backup)

    logger.error("Restarting environment")

    host_manager.control_environment('restart', ['agent'], parallel=True)
    host_manager.control_environment('restart', ['manager'], parallel=True)


@pytest.mark.filterwarnings('ignore::urllib3.exceptions.InsecureRequestWarning')
class TestInitialScans():
    results = {}

    @pytest.fixture(scope='class')
    def get_results(self):
        return self.results

    @pytest.mark.parametrize('vulnerability_detection_previously_enabled', [False, True])
    def test_first_syscollector_scan(self, request, host_manager, vulnerability_detection_previously_enabled, 
                                     configure_vulnerability_detection_test_environment, get_results):
        """
        description: Validates the initiation of the first Syscollector scans across all agents in the environment.

        This test ensures that Syscollector first scans are started in all agents in the environment.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - vulnerability_detection_previously_enabled:
                type: fixture
                brief: Whether the vulnerability detection was previously enabled
            - configure_environment:
                type: fixture
                brief: Configure the environment with the given configurations
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned
        """

        test_result = {'checks': {'all_agents_scanned_syscollector_first_scan': True, 'all_agents_scanned_vulnerability_first_scan': True}, 'no_errors': True,
                       'evidences': {'agents_not_scanned_syscollector_first_scan': [], 'agents_not_scanned_vulnerability_first_scan': []},
                       'vulnerabilities_first_scan': {}}

        results = get_results
        test_name = request.node.name

        agents_not_scanned_first_scan = monitoring_syscollector_scan_agents(host_manager, TIMEOUT_SYSCOLLECTOR_SCAN)
        agents_to_check = [agent for agent in host_manager.get_group_hosts('agent') if agent not in agents_not_scanned_first_scan]

        if agents_not_scanned_first_scan:
            logging_message = f"Syscollector scan not started in the following agents: {agents_not_scanned_first_scan}"
            test_result['checks']['all_agents_scanned_syscollector_first_scan'] = False
            test_result['evidences']['agents_not_scanned_syscollector_first_scan'] = agents_not_scanned_first_scan
            logger.critical(logging_message)

        if len(agents_to_check) == 0:
            pytest.fail("Syscollector scan not started in any agent. Check agent logs for more information")

        # Wait until all agents has been scanned. Timeout: 100 seconds per agent
        logger.critical(f"Waiting until agent all agents have been scanned.")
        time.sleep(TIMEOUT_PER_AGENT_VULNERABILITY_SCAN * len(agents_to_check))

        logger.critical("Checking vulnerabilities in the index")
        vuln_by_agent_index = {}
        for agent in agents_to_check:
            agent_all_vulnerabilities = get_indexer_values(host_manager, 
                                                           greater_than_timestamp=configure_vulnerability_detection_test_environment,
                                                           agent=agent, index='wazuh-states-vulnerabilities',)['hits']['hits']
            vuln_by_agent_index[agent] = agent_all_vulnerabilities

        # Store full alert index list in global results. It is needed for the next test
        test_result['evidences']['vulnerabilities_first_scan'] = vuln_by_agent_index
        results['vulnerabilities_index_first_scan'] = vuln_by_agent_index

        logger.critical("Checking that all agents has been scanned and generated vulnerabilities in the index")
        for agent in agents_to_check:
            if agent not in list(vuln_by_agent_index.keys()) or \
                    len(vuln_by_agent_index[agent]) == 0:
                logger.critical(f"Agent {agent} has not been scanned. Continuing with remaining agents")
                test_result['evidences']['agents_not_scanned_vulnerability_first_scan'].append(agent)

        if len(test_result['evidences']['agents_not_scanned_vulnerability_first_scan']) > 0:
            test_result['checks']['all_agents_scanned_vulnerability_first_scan'] = False

        results[test_name] = test_result
      
        unexpected_errors = check_errors_in_environment(host_manager)
        if unexpected_errors:
            for host, logs_by_level in unexpected_errors.items():
                if any(logs_by_level.values()):
                    logger.critical(f"Unexpected errors found in {host}: {logs_by_level}")
                    test_result['checks']['no_errors'] = False


        check_all = all(test_result['checks'].values())

        assert check_all, "Some agents has not been scanned or unexpected error occurs. Check logs for more information"


    def tests_syscollector_vulnerabilities_index_alerts_consistency(self, request,
                                                                    setup_vulnerability_tests, get_results):
        """
        description: Ensure the consistency of the agent's vulnerabilities between the index and the alerts.

        This test ensure that alerts in the index are consistent with the alerts in the alerts index after the first
        scan.

        tier: 0

        parameters:
            - request: pytest request object
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that the index is consistent with the alerts

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """
        results = get_results
        test_name = request.node.name
        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'alerts_not_in_states': [],
                    'states_not_in_alerts': [],
                    'alerts_first_scan': results['vulnerabilities_alerts_first_scan'],
                    'states_first_scan': results['vulnerabilities_index_first_scan']
                }
        }

        # Check that the index is consistent with the alerts
        logging.critical("Checking index state consistency")
        inconsistencies_between_alerts_indexer = \
            check_vuln_state_consistency(results['vulnerabilities_alerts_first_scan'],
                                         results['vulnerabilities_index_first_scan'])

        test_result['evidences']['alerts_not_in_states'] = \
            inconsistencies_between_alerts_indexer['alerts_not_in_states']

        test_result['evidences']['states_not_in_alerts'] = \
            inconsistencies_between_alerts_indexer['states_not_in_alerts']

        if len(test_result['evidences']['alerts_not_in_states']) > 0 or \
                len(test_result['evidences']['states_not_in_alerts']) > 0:
            logger.critical("Index state is not consistent with the alerts")
            test_result['checks']['all_successfull'] = False

        results[test_name] = test_result

        if not test_result['checks']['all_successfull']:
            logging_message = "Index state is not consistent with the alerts"
            logger.critical(logging_message)
            logger.critical(f"Alerts not in states: {test_result['evidences']['alerts_not_in_states']}")
            logger.critical(f"States not in alerts: {test_result['evidences']['states_not_in_alerts']}")
            pytest.fail(logging_message)
        else:
            logger.critical("Index state is consistent with the alerts")

    def test_syscollector_second_scan(self, request, host_manager, setup_vulnerability_tests, get_results):
        """
        description: Validates the initiation of the second Syscollector scans across all agents in the environment.

        This test ensures that Syscollector second scans are started in all agents in the environment.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """

        results = get_results
        test_name = request.node.name
        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'agents_syscollector_second_scan_not_started': []
                }
        }

        # Filter agents that has not been scanned
        agents_to_check = [agent for agent in host_manager.get_group_hosts('agent') if agent not in
                           results['test_syscollector_first_scan']['evidences']['agents_not_scanned_first_scan']]

        if len(agents_to_check) == 0:
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        monitoring_data = generate_monitoring_logs(host_manager,
                                                   [get_event_regex({'event': 'syscollector_scan_start'}),
                                                    get_event_regex({'event': 'syscollector_scan_end'})],
                                                   [TIMEOUT_SYSCOLLECTOR_SCAN, TIMEOUT_SYSCOLLECTOR_SCAN],
                                                   host_manager.get_group_hosts('agent'), 2)

        monitoring_results = monitoring_events_multihost(host_manager, monitoring_data)

        logger.critical("Checking that all agents has been scanned")
        for agent in monitoring_results:
            if monitoring_results[agent]['not_found']:
                test_result['checks']['all_successfull'] = False
                test_result['evidences']['agents_syscollector_second_scan_not_started'].append(agent)

                logging.critical(f"Syscollector scan not started in the following agents:"
                                 f"{test_result['evidences']['agents_syscollector_second_scan_not_started']}."
                                 'Continuing with the test')

        results[test_name] = test_result

        if not test_result['checks']['all_successfull']:
            logging_message = "Syscollector scan not started in the following agents:" \
                    f"{test_result['evidences']['agents_syscollector_second_scan_not_started']}."
            pytest.fail(logging_message)
        else:
            logger.critical("Syscollector scan started in all agents")

    def tests_syscollector_first_second_scan_consistency_alerts(self, request, host_manager, setup_vulnerability_tests,
                                                                get_results):
        """
        description: Ensure the consistency of the agent's vulnerabilities between the first and second scans.

        This test ensure that alerts in the first scan are consistent with the alerts in the second scan.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that the number of vulnerabilities is the same between scans

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """

        test_name = request.node.name
        results = get_results
        request = request
        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'vulnerabilities_not_equal_between_scans_alerts': [],
                    'agents_different_between_scans': [],
                    'vulnerabilities_alerts_first_scan': results['vulnerabilities_alerts_first_scan'],
                    'vulnerabilities_alerts_second_scan': []
                }
        }

        # Filter agents that has not been scanned
        agents_to_check = [agent for agent in host_manager.get_group_hosts('agent') if agent not in
                           results['test_syscollector_first_scan']['evidences']['agents_not_scanned_first_scan']]

        if len(agents_to_check) == 0:
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        logger.critical("Waiting until agent's VD scan is over")
        # Only wait for the first agent. Any possible discrepancy will be detected in this interval
        time.sleep(TIMEOUT_PER_AGENT_VULNERABILITY_SCAN)

        logger.critical("Checking vulnerabilities in the second scan")

        vuln_by_agent_alert_second_scan = {}
        for agent in agents_to_check:
            agent_all_alerts = get_indexer_values(host_manager,
                                                  greater_than_timestamp=setup_vulnerability_tests,
                                                  agent=agent)['hits']['hits']
            # Only is expected alert of affected vulnerabilities
            vuln_by_agent_alert_second_scan[agent] = parse_vulnerability_detector_alerts(agent_all_alerts)['affected']

        # Store full alert list in global results. It is needed for the next test
        results['vulnerabilities_alerts_second_scan'] = vuln_by_agent_alert_second_scan
        test_result['evidences']['vulnerabilities_alerts_second_scan'] = vuln_by_agent_alert_second_scan

        alert_present_in_first_scan_not_in_second_scan = []
        alert_present_in_second_scan_not_in_first_scan = []

        logger.critical("Checking that all agents has been scanned")
        # Check if the number of agents for each scan is the same
        if len(vuln_by_agent_alert_second_scan.keys()) != len(results['vulnerabilities_alerts_first_scan'].keys()):
            test_result['checks']['all_successfull'] = False
            logging.critical(f"Agents with vulnerabilities changed between scans: "
                             f"First scan: {list(results['vulnerabilities_alerts_first_scan'].keys())}"
                             f"Second scan: {list(vuln_by_agent_alert_second_scan.keys())}")

            test_result['evidences']['agents_different_between_scans'] = \
                list(set(list(results['vulnerabilities_alerts_first_scan'].keys())) ^
                     set(list(results['vulnerabilities_alerts_second_scan'].keys())))

        logger.critical("Checking the number of vulnerabilities for each agent")
        for agent in agents_to_check:
            if agent in list(results['vulnerabilities_alerts_first_scan'].keys()) and \
                    len(results['vulnerabilities_alerts_first_scan'][agent]):
                for alert in list(vuln_by_agent_alert_second_scan[agent][0]):
                    if alert not in results['vulnerabilities_alerts_first_scan'][agent][0]:
                        alert_present_in_second_scan_not_in_first_scan.append(alert)

                for alert in list(results['vulnerabilities_alerts_first_scan'][agent][0]):
                    if alert not in vuln_by_agent_alert_second_scan[agent][0]:
                        alert_present_in_first_scan_not_in_second_scan.append(alert)

        logger.critical("Checking that all agents has been scanned")
        if alert_present_in_first_scan_not_in_second_scan or alert_present_in_second_scan_not_in_first_scan:
            test_result['checks']['all_successfull'] = False
            test_result['evidences']['vulnerabilities_not_equal_between_scans_alerts'] = {
                'alert_present_in_first_scan_not_in_second_scan': alert_present_in_first_scan_not_in_second_scan,
                'alert_present_in_second_scan_not_in_first_scan': alert_present_in_second_scan_not_in_first_scan
            }

        results[test_name] = test_result

        if not test_result['checks']['all_successfull']:
            logging_message = "Inconsistencies found between first and second scan." \
                    "Check evidences for more information"
            logger.critical(logging_message)
            pytest.fail(logging_message)
        else:
            logger.critical("The number of vulnerabilities is the same between scans")


    def tests_syscollector_first_second_scan_consistency_index(self, request, host_manager, setup_vulnerability_tests,
                                                               get_results):
        """
        description: Ensure the consistency of the agent's vulnerabilities between the first and second scans in index.

        This test ensure that alerts in the first scan are consistent with the alerts in the second scan in the index.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that the number of vulnerabilities is the same between scans

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """

        results = get_results
        test_name = request.node.name
        test_result = {
                'checks': {
                    'all_successfull': True,
                },
                'evidences': {
                    'vulnerabilities_not_equal_between_scans_indexer': [],
                    'vulnerabilities_index_first_scan': results['vulnerabilities_index_first_scan'],
                    'vulnerabilities_index_second_scan': []
                }
        }

        logger.critical("Checking vulnerabilities in the second scan")

        vuln_by_agent_index_second_scan = {}
        for agent in host_manager.get_group_hosts('agent'):
            agent_all_vulnerabilities = get_indexer_values(host_manager,
                                                  greater_than_timestamp=setup_vulnerability_tests,
                                                  index='wazuh-states-vulnerabilities',
                                                  agent=agent)['hits']['hits']
            # Only is expected alert of affected vulnerabilities
            vuln_by_agent_index_second_scan[agent] = agent_all_vulnerabilities

        results['vulnerabilities_index_second_scan'] = vuln_by_agent_index_second_scan
        test_result['evidences']['vulnerabilities_index_second_scan'] = vuln_by_agent_index_second_scan

        differences = list(set(results['vulnerabilities_index_first_scan']).symmetric_difference(
            set(results['vulnerabilities_index_second_scan'])))

        results[test_name] = test_result

        if differences:
            test_result['checks']['all_successfull'] = False
            results[test_name]['evidences']['vulnerabilities_not_equal_between_scans_indexer'] = differences
            logging.critical("Inconsistencies found between first and second scan in the index."
                             f"Check evidences for more information: {differences}")
            pytest.fail('The number of vulnerabilities is not the same between scans')
        else:
            logger.critical("The number of vulnerabilities is the same between scans")


# -------------------------




# Load basic tests cases 
cases = {}

with open(os.path.join(current_dir, os.path.join('cases', 'test_vulnerability.yaml')), 'r') as cases_file:
    cases = yaml.load(cases_file, Loader=yaml.FullLoader)

complete_list = [
    (
        case['preconditions'] if 'preconditions' in case else None,
        case['body'] if 'body' in case else None,
        case['teardown'] if 'teardown' in case else None
    )
    for case in cases
]

list_ids = [case['id'] for case in cases]

#### 

cases_change_manager = {}

with open(os.path.join(current_dir, os.path.join('cases', 'change_manager_cases.yaml')), 'r') as cases_file:
    cases_change_manager = yaml.load(cases_file, Loader=yaml.FullLoader)

test_cases_change_manager = [
    (
        case['preconditions'] if 'preconditions' in case else None,
        case['body'] if 'body' in case else None,
        case['teardown'] if 'teardown' in case else None
    )
    for case in cases_change_manager
]

list_ids_change_manager = [case['id'] for case in cases_change_manager]

class TestScanSyscollectorCases():
    results = {}

    @pytest.fixture(scope='class')
    def get_results(self):
        return self.results

    @pytest.fixture(scope='function')
    def permutate_agents_managers(self, host_manager):

        configuration_backup = backup_configurations(host_manager)
        list_of_managers = host_manager.get_group_hosts('manager')

        for agent in host_manager.get_group_hosts('agent'):
            agent_current_manager = host_manager.get_host_variables(agent)['manager']
            manager_index = list_of_managers.index(agent_current_manager)
            next_manager = list_of_managers[(manager_index + 1)%len(list_of_managers)]
            agent_os = host_manager.get_host_variables(agent)['os_name']

            manager_ip = host_manager.get_host_variables(next_manager)['public_ip'] if agent_os == 'macos' \
                    else host_manager.get_host_variables(next_manager)['ip']

            change_agent_manager_ip(host_manager, agent, manager_ip)

        yield 

        logging.error("Restoring original configuration") 
        restore_configuration(host_manager, configuration_backup)

   
    @pytest.mark.parametrize('preconditions, body, teardown', test_cases_change_manager, ids=list_ids_change_manager)
    def test_change_agent_manager(self, permutate_agents_managers, request, preconditions, body, teardown, setup,
                                  host_manager, get_results):
        setup_results = setup
        results = get_results
        test_name = request.node.name
        results[request.node.name] = {}
        results['setup'] = setup_results

        hosts_to_ignore = []

        for host in setup_results.keys():
            if setup_results[host]['checks']['all_successfull'] is False:
                hosts_to_ignore.append(host)

        if len(hosts_to_ignore) > 0:
            logger.critical(f"Setup test failed for hosts {hosts_to_ignore}. Check logs for more information")
            logger.critical(f"Evidences: {setup_results}")
            logger.critical("Ignoring these hosts for the rest of the test")

        logger.critical("Starting scan cases tests")
        logger.critical(f"Case Info: {body}")

        # Launch tests tasks
        test_result = launch_parallel_operations(body['tasks'], host_manager, hosts_to_ignore)

        success_for_all_agents = True

        for host in test_result.keys():
            if test_result[host]['checks']['all_successfull'] is False:
                success_for_all_agents = False
                logger.critical(f"Test failed for host {host}. Check logs for more information")
                logger.critical(f"Evidences: {test_result[host]['evidences']}")

        results[test_name]['evidences'] = {}

        for agent in test_result.keys():
            if 'evidences' in test_result[agent]:
                for evidence, evidence_values in test_result[agent]['evidences'].items():
                    results[test_name]['evidences'][str(agent)+str(evidence)] = evidence_values

        if 'evidences' in test_result:
            results[test_name]['evidences'] = test_result['evidences']

        results[test_name] = test_result

        logger.critical("Final Results")

        assert success_for_all_agents is True, "Test failed. Check logs for more information"



    @pytest.mark.parametrize('preconditions, body, teardown', complete_list, ids=list_ids)
    def test_vulnerability_detector_scans_cases(self, setup_vulnerability_tests, request, preconditions, body, teardown, setup,
                                                host_manager, get_results):
        test_name = request.node.name

        setup_results = setup
        results = get_results
        results[request.node.name] = {}
        results['setup'] = setup_results

        hosts_to_ignore = []

        for host in setup_results.keys():
            if setup_results[host]['checks']['all_successfull'] is False:
                hosts_to_ignore.append(host)

        if len(hosts_to_ignore) > 0:
            logger.critical(f"Setup test failed for hosts {hosts_to_ignore}. Check logs for more information")
            logger.critical(f"Evidences: {setup_results}")
            logger.critical("Ignoring these hosts for the rest of the test")

        logger.critical("Starting scan cases tests")
        logger.critical(f"Case Info: {body}")

        # Launch tests tasks
        test_result = launch_parallel_operations(body['tasks'], host_manager, hosts_to_ignore)

        success_for_all_agents = True

        for host in test_result.keys():
            if test_result[host]['checks']['all_successfull'] is False:
                success_for_all_agents = False
                logger.critical(f"Test failed for host {host}. Check logs for more information")
                logger.critical(f"Evidences: {test_result[host]['evidences']}")

        results[test_name]['evidences'] = {}

        for agent in test_result.keys():
            if 'evidences' in test_result[agent]:
                for evidence, evidence_values in test_result[agent]['evidences'].items():
                    results[test_name]['evidences'][str(agent)+str(evidence)] = evidence_values

        if 'evidences' in test_result:
            results[test_name]['evidences'] = test_result['evidences']

        results[test_name] = test_result

        logger.critical("Final Results")

        assert success_for_all_agents is True, "Test failed. Check logs for more information"
