# Copyright (C) 2015, Wazuh Inc
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2

"""
Vulnerability Detector Basic Cases Tests
----------------------------------------

Type: End-to-End (E2E)

Brief:
    This module contains basic tests to ensure the proper functionality of the Vulnerability Detector.
    The tests validate that initial Syscollector scans, along with installation, removal, and uninstall operations,
    trigger Vulnerability Detector scans, generating the expected vulnerabilities.
    The verification of vulnerabilities is conducted through Vulnerabilities Index and API endpoint
    Additionally, the tests ensure the consistency of these values.

Tests:
    - TestInitialScans: Validates the initiation of Syscollector scans across all agents in the environment.
        - test_syscollector_first_scan: Validates the initiation of the first Syscollector scans across all agents
                                        in the environment.
        - test_syscollector_first_scan_index: Validates that the Vulnerability Detector detects vulnerabilities
                                              within the environment in the first scan in the index.
        - test_syscollector_second_scan: Validates the initiation of the second Syscollector scans
                                         across all agents in the environment.
        - tests_syscollector_first_second_scan_consistency_index: Ensure the consistency of the agent's vulnerabilities
                                                                  between the first and second scans in index.
    - TestScanSyscollectorCases: Validates the Vulnerability Detector's ability to detect new vulnerabilities in the
                                 environment for each of the defined cases.

Issue: https://github.com/wazuh/wazuh-qa/issues/4369

Components:
  - vulnerability_detector
  - syscollector

Environment: e2e_vulnerability_detector

Tiers: 0

Markers:
  - e2e
  - vulnerability_detector
  - tier0
"""
import datetime
import logging
import os
import pytest
import time

from wazuh_testing.end_to_end import Check, Evidence, TestResult
from wazuh_testing.end_to_end.check_validators import equals, equals_but_not_empty, empty, no_errors, validate_operation_results, \
        validate_vulnerabilities_results
from wazuh_testing.end_to_end.configuration import \
    (change_agent_manager_ip, configure_environment,
     load_vulnerability_detector_configurations,
     save_indexer_credentials_into_keystore)
from wazuh_testing.end_to_end.indexer_api import get_indexer_values, delete_index, \
        create_vulnerability_states_indexer_filter, create_alerts_filter
from wazuh_testing.end_to_end.utils import load_test_cases, extract_case_info, get_case_ids
from wazuh_testing.end_to_end.environment_utils import clean_agents
from wazuh_testing.end_to_end.logs import check_errors_in_environment, truncate_remote_host_group_files
from wazuh_testing.end_to_end.monitoring import monitoring_syscollector_scan_agents
from wazuh_testing.end_to_end.remote_operations_handler import launch_parallel_operations
from wazuh_testing.end_to_end.vulnerability_detector import get_vulnerabilities_from_states_by_agent, \
        TIMEOUT_PER_AGENT_VULNERABILITY_SCAN
from wazuh_testing.end_to_end.waiters import wait_until_vd_is_updated
from wazuh_testing.modules.syscollector import TIMEOUT_SYSCOLLECTOR_SCAN
from wazuh_testing.tools.system import HostManager


pytestmark = [pytest.mark.e2e, pytest.mark.vulnerability_detector, pytest.mark.tier0]


AGENTS_NOT_SCANNED_FIRST_SCAN = []
FIRST_SCAN_TIME = None
FIRST_SCAN_VULNERABILITIES_INDEX = {}
AGENT_REGISTRATION_TIMEOUT = 15
VULNERABILITY_DETECTION_E2E_EXPECTED_ERRORS = [
    r"Invalid ID \d{3} for the source",
    r"Unable to connect to .* No connection could be made because the target machine actively refused",
    r"Process locked due to agent is offline. Waiting for connection",
    r"Lost connection with manager. Setting lock",
    r"Unable to connect to .*Connection refused",
    r"Unable to connect to .*No connection could be made because the target machine actively refused it",
]
INITIAL_VULNERABILITIES = {
            "vd_disabled_when_agents_registration": {},
            "vd_enabled_when_agents_registration": {},
}


@pytest.fixture(scope="module")
def save_indexer_credentials_keystore(host_manager):
    logging.error(
        "Save the Wazuh indexer username and password into the Wazuh manager keystore"
    )
    save_indexer_credentials_into_keystore(host_manager)


def configure_vulnerability_detection_and_wait_until_feeds_are_updated(host_manager,
                                                                       vulnerability_detection_previously_enabled):
    current_dir = os.path.dirname(__file__)
    configurations_dir = os.path.join(current_dir, "configurations")
    configurations_paths = {
        "manager": os.path.join(configurations_dir, "manager.yaml"),
        "agent": os.path.join(configurations_dir, "agent.yaml"),
    }

    configure_environment(
        host_manager,
        load_vulnerability_detector_configurations(
            host_manager,
            configurations_paths=configurations_paths,
            enable=vulnerability_detection_previously_enabled,
        ),
    )

    logging.error("Restarting managers")
    host_manager.control_environment("restart", ["manager"], parallel=True)

    if vulnerability_detection_previously_enabled:
        logging.error("Wait until Vulnerability Detector has update all the feeds")
        wait_until_vd_is_updated(host_manager)


def start_agent_and_wait_until_connected(host_manager):
    host_manager.control_environment("restart", ["agent"], parallel=True)
    time.sleep(AGENT_REGISTRATION_TIMEOUT * len(host_manager.get_group_hosts("agent")))


@pytest.fixture(scope="function")
def configure_vulnerability_detection_test_environment(host_manager: HostManager,
                                                       vulnerability_detection_previously_enabled: bool):
    """Configure the environment with the given configurations

    Args:
        host_manager (HostManager): An instance of the HostManager class.
        configurations (dict): The configurations to apply to the environment
    """
    clean_agents(host_manager)

    utc_now_timestamp = datetime.datetime.utcnow()
    test_timestamp = utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%S")

    configure_vulnerability_detection_and_wait_until_feeds_are_updated(host_manager,
                                                                       vulnerability_detection_previously_enabled)

    start_agent_and_wait_until_connected(host_manager)

    if not vulnerability_detection_previously_enabled:
        configure_vulnerability_detection_and_wait_until_feeds_are_updated(host_manager, True)

    yield test_timestamp

    # Truncate alerts and logs of managers and agents
    logging.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, "all", "logs")

    # Delete vulnerability index
    logging.error("Delete vulnerability index")
    delete_index(host_manager, index='wazuh-states-vulnerabilities')


@pytest.mark.filterwarnings("ignore::urllib3.exceptions.InsecureRequestWarning")
class TestInitialScans:
    # Checks definition
    all_agents_scanned_syscollector_first_scan_check = Check(
        "all_agents_scanned_syscollector_first_scan", empty,
        expected_evidences=["agents_not_scanned_syscollector_first_scan"],
    )
    all_agents_scanned_vulnerability_first_scan_check = Check(
        "all_agents_scanned_vulnerability_first_scan",
        empty,
        expected_evidences=["agents_not_scanned_vulnerability_first_scan"],
    )
    initial_vulnerabilities_consistent = Check(
        "initial_vulnerabilities_consistent",
        equals_but_not_empty,
        expected_evidences=[
            "vd_disabled_when_agents_registration",
            "vd_enabled_when_agents_registration",
        ],
    )
    vulnerabilities_consistent_first_second_scan = Check(
        "vulnerabilities_consistent_first_second_scan",
        equals,
        expected_evidences=[
            "vulnerabilities_index_first_scan",
            "vulnerabilities_index_second_scan",
        ],
    )
    all_agents_scanned_syscollector_second_scan_check = Check(
        "all_agents_scanned_syscollector_second_scan",
        empty,
        expected_evidences=["agents_not_scanned_syscollector_second_scan"],
    )
    no_errors_check = Check(
        "no_errors", no_errors, expected_evidences=["error_level_messages"]
    )

    @pytest.fixture(scope="function")
    def get_timestamp(self):
        utc_now_timestamp = datetime.datetime.utcnow()
        return utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%SZ")

    @pytest.mark.parametrize(
        "vulnerability_detection_previously_enabled",
        [False, True],
        ids=[
            "vd_disabled_when_agents_registration",
            "vd_enabled_when_agents_registration",
        ],
    )
    def test_first_syscollector_scan(self, request, host_manager,
                                     vulnerability_detection_previously_enabled,
                                     configure_vulnerability_detection_test_environment,
                                     record_property,):
        """
        description: Validates the initiation of the first Syscollector scans across all agents in the environment.

        This test ensures that Syscollector first scans are started in all agents in the environment.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - vulnerability_detection_previously_enabled:
                type: fixture
                brief: Whether the vulnerability detection was previously enabled
            - configure_environment:
                type: fixture
                brief: Configure the environment with the given configurations
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned
        """
        global AGENTS_NOT_SCANNED_FIRST_SCAN
        global FIRST_SCAN_TIME
        global FIRST_SCAN_VULNERABILITIES_INDEX
        global INITIAL_VULNERABILITIES

        FIRST_SCAN_TIME = configure_vulnerability_detection_test_environment

        test_result = TestResult(request.node.name)
        test_result.add_check(self.all_agents_scanned_syscollector_first_scan_check)
        test_result.add_check(self.all_agents_scanned_vulnerability_first_scan_check)
        test_result.add_check(self.no_errors_check)

        record_property("test_result", test_result)

        # Store the agents scanned by syscollector in a global variable.
        # Only the last test case result is retained for comparison with the second scan.
        AGENTS_NOT_SCANNED_FIRST_SCAN = monitoring_syscollector_scan_agents(host_manager, TIMEOUT_SYSCOLLECTOR_SCAN)
        agents_to_check = [agent for agent in host_manager.get_group_hosts("agent")
                           if agent not in AGENTS_NOT_SCANNED_FIRST_SCAN]

        test_result.validate_check("all_agents_scanned_syscollector_first_scan",
                                   [Evidence("agents_not_scanned_syscollector_first_scan",
                                             AGENTS_NOT_SCANNED_FIRST_SCAN)])

        if len(agents_to_check) == 0:
            logging.critical("Critical error. Test can not continue")
            pytest.fail("Syscollector scan not started in any agent. Check agent logs for more information")

        logging.critical("Waiting until agent all agents have been scanned.")
        time.sleep(TIMEOUT_PER_AGENT_VULNERABILITY_SCAN * len(agents_to_check))

        logging.critical("Checking vulnerabilities in the index")
        vuln_by_agent_index = get_vulnerabilities_from_states_by_agent(host_manager, agents_to_check,
                                                                       greater_than_timestamp=FIRST_SCAN_TIME)

        # Store the vulnerabilities in the global variable to make the comparision in test_consistency_initial_scans
        if not vulnerability_detection_previously_enabled:
            INITIAL_VULNERABILITIES["vd_disabled_when_agents_registration"] = vuln_by_agent_index
        else:
            INITIAL_VULNERABILITIES["vd_enabled_when_agents_registration"] = vuln_by_agent_index

        FIRST_SCAN_VULNERABILITIES_INDEX = vuln_by_agent_index

        logging.critical("Checking that all agents has been scanned and generated vulnerabilities in the index")

        agent_not_scanned = []
        # We expect at least one vulnerability in each agent
        for agent, vulnerabilities in vuln_by_agent_index.items():
            if len(vulnerabilities) == 0:
                logging.critical(f"No vulnerabilities found for {agent}")
                agent_not_scanned.append(agent)

        # Validate that all agents has been scanned and generated vulnerabilities in the index
        test_result.validate_check("all_agents_scanned_vulnerability_first_scan", [
                                            Evidence(
                                                "agents_not_scanned_vulnerability_first_scan", agent_not_scanned
                                            ),
                                            Evidence(
                                                "vulnerabilities_index_first_scan", vuln_by_agent_index, debug=True
                                            ),
                                        ]
                                   )

        logging.critical("Checking for errors in the environment")
        unexpected_errors = check_errors_in_environment(host_manager,
                                                        expected_errors=VULNERABILITY_DETECTION_E2E_EXPECTED_ERRORS)

        test_result.validate_check("no_errors", [Evidence("error_level_messages", unexpected_errors)])

        assert test_result.get_test_result(), test_result.report()

    def test_consistency_initial_scans(self, request, host_manager,
                                       get_initial_vulnerabilities_environment, record_property):
        """
        description: Ensure the consistency of the agent's vulnerabilities neither the agent was registered nor.

        This test ensures that the agent's vulnerabilities are consistent with the initial scan.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment

        assertions:
            - Verify that the number of vulnerabilities is the same between scans
        """
        test_result = TestResult(request.node.name)
        test_result.add_check(self.initial_vulnerabilities_consistent)

        record_property("test_result", test_result)
        test_result.validate_check(
            "initial_vulnerabilities_consistent",
            [
                Evidence(
                    "vd_disabled_when_agents_registration",
                    get_initial_vulnerabilities_environment[
                        "vd_disabled_when_agents_registration"
                    ],
                ),
                Evidence(
                    "vd_enabled_when_agents_registration",
                    get_initial_vulnerabilities_environment[
                        "vd_enabled_when_agents_registration"
                    ],
                ),
            ],
        )

        assert test_result.get_test_result(), test_result.report()

    def test_syscollector_second_scan(self, request, host_manager, record_property, get_timestamp):
        """
        description: Validates the initiation of the second Syscollector scans across all agents in the environment.

        This test ensures that Syscollector second scans are started in all agents in the environment.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """
        TIMEOUT_SECOND_SCAN = 60

        global AGENTS_NOT_SCANNED_FIRST_SCAN

        test_result = TestResult(request.node.name)

        test_result.add_check(self.all_agents_scanned_syscollector_second_scan_check)
        test_result.add_check(self.no_errors_check)
        test_result.add_check(self.vulnerabilities_consistent_first_second_scan)

        record_property("test_result", test_result)

        # Filter agents that has not been scanned
        agents_to_check = [agent for agent in host_manager.get_group_hosts("agent")
                           if agent not in AGENTS_NOT_SCANNED_FIRST_SCAN]

        if len(agents_to_check) == 0:
            pytest.skip("First scan was not executed or no agent was scanned. Skipping test")

        agents_not_scanned_second_scan = monitoring_syscollector_scan_agents(host_manager, TIMEOUT_SYSCOLLECTOR_SCAN,
                                                                             greater_than_timestamp=get_timestamp)

        test_result.validate_check(
            "all_agents_scanned_syscollector_second_scan",
            [
                Evidence(
                    "agents_not_scanned_syscollector_second_scan",
                    agents_not_scanned_second_scan,
                )
            ],
        )

        agents_to_check_vulns = [agent for agent in host_manager.get_group_hosts("agent")
                                 if agent not in agents_not_scanned_second_scan]

        if len(agents_to_check_vulns) == 0:
            pytest.fail("Syscollector scan not started in any agent. Check agent logs for more information")

        logging.critical("Waiting until agent all agents have been scanned.")
        time.sleep(TIMEOUT_SECOND_SCAN)

        global FIRST_SCAN_TIME

        logging.critical("Checking vulnerabilities in the index")
        vuln_by_agent_index = get_vulnerabilities_from_states_by_agent(host_manager, agents_to_check_vulns,
                                                                       greater_than_timestamp=FIRST_SCAN_TIME)

        logging.critical(
            "Checking that all agents has been scanned and generated vulnerabilities in the index"
        )
        test_result.validate_check(
            "vulnerabilities_consistent_first_second_scan",
            [
                Evidence(
                    "vulnerabilities_index_first_scan", FIRST_SCAN_VULNERABILITIES_INDEX
                ),
                Evidence("vulnerabilities_index_second_scan", vuln_by_agent_index),
            ],
        )

        unexpected_errors = check_errors_in_environment(
            host_manager, expected_errors=VULNERABILITY_DETECTION_E2E_EXPECTED_ERRORS,
            greater_than_timestamp=get_timestamp)

        test_result.validate_check(
            "no_errors", [Evidence("error_level_messages", unexpected_errors)]
        )

        assert test_result.get_test_result(), test_result.report()


@pytest.mark.filterwarnings("ignore::urllib3.exceptions.InsecureRequestWarning")
class TestScanSyscollectorCases:
    # Load basic test cases

    current_dir = os.path.dirname(__file__)
    basic_cases_path = os.path.join(current_dir, "cases", "test_vulnerability.yaml")
    cases = load_test_cases(basic_cases_path)
    complete_list = extract_case_info(cases)
    list_ids = get_case_ids(cases)

    # Load single vulnerable case
    single_vulnerable_packages_cases_path = os.path.join(
        current_dir, "cases", "test_vulnerability_single_vulnerable_case.yaml"
    )
    single_vulnerable_package_case = load_test_cases(
        single_vulnerable_packages_cases_path
    )
    single_vulnerable_case_complete_list = extract_case_info(
        single_vulnerable_package_case
    )
    single_vulnerable_case_list_ids = get_case_ids(single_vulnerable_package_case)

    # Load change manager test cases
    change_manager_cases_path = os.path.join(
        current_dir, "cases", "change_manager_cases.yaml"
    )
    cases_change_manager = load_test_cases(change_manager_cases_path)
    test_cases_change_manager = extract_case_info(cases_change_manager)
    list_ids_change_manager = get_case_ids(cases_change_manager)

    no_errors_check = Check(
        "no_errors", no_errors, expected_evidences=["error_level_messages"]
    )

    operation_successfull_for_all_agents = validate_operation_results
    operation_successfull_for_all_agents_check = Check(
        "operation_successfull_for_all_agents",
        operation_successfull_for_all_agents,
        expected_evidences=["operation_results"],
    )

    @pytest.fixture(scope="function")
    def permutate_agents_managers(self, host_manager, backup_configuration):
        list_of_managers = host_manager.get_group_hosts("manager")

        for agent in host_manager.get_group_hosts("agent"):
            agent_current_manager = host_manager.get_host_variables(agent)["manager"]
            manager_index = list_of_managers.index(agent_current_manager)
            next_manager = list_of_managers[(manager_index + 1) % len(list_of_managers)]
            agent_os = host_manager.get_host_variables(agent)["os_name"]

            manager_ip = (
                host_manager.get_host_variables(next_manager)["public_ip"]
                if agent_os == "macos"
                else host_manager.get_host_variables(next_manager)["ip"]
            )

            logging.error(
                f"Changing manager for agent {agent} to {next_manager} ({manager_ip})"
            )
            change_agent_manager_ip(host_manager, agent, manager_ip)

    @pytest.mark.parametrize(
        "preconditions, body, teardown",
        single_vulnerable_case_complete_list,
        ids=single_vulnerable_case_list_ids,
    )
    def test_install_vulnerable_package_when_agent_down(self, host_manager, request, record_property,
                                                        preconditions, body, teardown, setup):
        """
        description: Install a vulnerable package when the agent is down.

        This test ensures that the Vulnerability Detector detects the vulnerability when the agent is down.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - configure_environment:
                type: fixture
                brief: Configure the environment with the given configurations
            - get_results: fixture to get the results of global class tests

        assertions:
        """
        # global agents_not_scanned_first_scan

        # if len(agents_not_scanned_first_scan) == 0:
        #     pytest.skip('No agent was scanned in the first scan. Skipping test.'
        # 'Is mandatory to launch this test along with the first scan test')

        utc_now_timestamp = datetime.datetime.utcnow()
        test_timestamp = utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%SZ")

        agents_not_scanned_first_scan = []
        agents_to_check = [
            agent
            for agent in host_manager.get_group_hosts("agent")
            if agent not in agents_not_scanned_first_scan
        ]

        test_result = TestResult(request.node.name)
        test_result.add_check(self.no_errors_check)
        test_result.add_check(self.operation_successfull_for_all_agents_check)

        record_property("test_result", test_result)

        time_after_install = datetime.datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S")

        # Install Vulnerable package
        operations_result = launch_parallel_operations(
            body["tasks"], host_manager, agents_not_scanned_first_scan
        )

        logging.critical(f"Remote operation results: {operations_result}")
        test_result.validate_check(
            "operation_successfull_for_all_agents",
            [Evidence("operation_results", operations_result)],
        )

        # vulnerabilities = get_vulnerabilities(host_manager, host,
        #                                                 operation_data['package'],
        #                                                 current_datetime)
        # expected_vulnerabilities = get_expected_vulnerabilities_by_agent(host_manager, [host],
        #                                                                         operation_data['package'],
        #                                                                         operation_data['check'])[host]
        logging.critical("Checking vulnerabilites")

        errors_environment = check_errors_in_environment(
            host_manager,
            expected_errors=VULNERABILITY_DETECTION_E2E_EXPECTED_ERRORS,
            greater_than_timestamp=test_timestamp,
        )
        test_result.validate_check(
            "no_errors", [Evidence("error_level_messages", errors_environment)]
        )

        validate_vulnerabilities_results(operations_result)

        logging.critical(f"Time after install: {time_after_install}")

        assert test_result.get_test_result(), test_result.report()

    @pytest.mark.parametrize(
        "preconditions, body, teardown",
        test_cases_change_manager,
        ids=list_ids_change_manager,
    )
    def test_change_agent_manager(
        self,
        permutate_agents_managers,
        request,
        preconditions,
        body,
        teardown,
        setup,
        host_manager,
        get_results,
    ):
        setup_results = setup
        results = get_results
        test_name = request.node.name
        results[request.node.name] = {}
        results["setup"] = setup_results

        hosts_to_ignore = []

        for host in setup_results.keys():
            if setup_results[host]["checks"]["all_successfull"] is False:
                hosts_to_ignore.append(host)

        if len(hosts_to_ignore) > 0:
            logging.critical(
                f"Setup test failed for hosts {hosts_to_ignore}. Check logs for more information"
            )
            logging.critical(f"Evidences: {setup_results}")
            logging.critical("Ignoring these hosts for the rest of the test")

        logging.critical("Starting scan cases tests")
        logging.critical(f"Case Info: {body}")

        # Launch tests tasks
        test_result = launch_parallel_operations(
            body["tasks"], host_manager, hosts_to_ignore
        )

        success_for_all_agents = True

        for host in test_result.keys():
            if test_result[host]["checks"]["all_successfull"] is False:
                success_for_all_agents = False
                logging.critical(
                    f"Test failed for host {host}. Check logs for more information"
                )
                logging.critical(f"Evidences: {test_result[host]['evidences']}")

        results[test_name]["evidences"] = {}

        for agent in test_result.keys():
            if "evidences" in test_result[agent]:
                for evidence, evidence_values in test_result[agent][
                    "evidences"
                ].items():
                    results[test_name]["evidences"][
                        str(agent) + str(evidence)
                    ] = evidence_values

        if "evidences" in test_result:
            results[test_name]["evidences"] = test_result["evidences"]

        results[test_name] = test_result

        assert (
            success_for_all_agents is True
        ), "Test failed. Check logs for more information"

    @pytest.mark.parametrize(
        "preconditions, body, teardown", complete_list, ids=list_ids
    )
    def test_vulnerability_detector_scans_cases(
        self, request, preconditions, body, teardown, setup, host_manager, get_results
    ):
        test_name = request.node.name

        setup_results = setup
        results = get_results
        results[request.node.name] = {}
        results["setup"] = setup_results

        hosts_to_ignore = []

        for host in setup_results.keys():
            if setup_results[host]["checks"]["all_successfull"] is False:
                hosts_to_ignore.append(host)

        if len(hosts_to_ignore) > 0:
            logging.critical(
                f"Setup test failed for hosts {hosts_to_ignore}. Check logs for more information"
            )
            logging.critical(f"Evidences: {setup_results}")
            logging.critical("Ignoring these hosts for the rest of the test")

        logging.critical("Starting scan cases tests")
        logging.critical(f"Case Info: {body}")

        # Launch tests tasks
        test_result = launch_parallel_operations(
            body["tasks"], host_manager, hosts_to_ignore
        )

        success_for_all_agents = True

        for host in test_result.keys():
            if test_result[host]["checks"]["all_successfull"] is False:
                success_for_all_agents = False
                logging.critical(
                    f"Test failed for host {host}. Check logs for more information"
                )
                logging.critical(f"Evidences: {test_result[host]['evidences']}")

        results[test_name]["evidences"] = {}

        for agent in test_result.keys():
            if "evidences" in test_result[agent]:
                for evidence, evidence_values in test_result[agent][
                    "evidences"
                ].items():
                    results[test_name]["evidences"][
                        str(agent) + str(evidence)
                    ] = evidence_values

        if "evidences" in test_result:
            results[test_name]["evidences"] = test_result["evidences"]

        results[test_name] = test_result

        assert (
            success_for_all_agents is True
        ), "Test failed. Check logs for more information"
