# Copyright (C) 2015, Wazuh Inc
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2

"""
Vulnerability Detector Basic Cases Tests
----------------------------------------

Type: End-to-End (E2E)

Brief:
    This module contains basic tests to ensure the proper functionality of the Vulnerability Detector.
    The tests validate that initial Syscollector scans, along with installation, removal, and uninstall operations,
    trigger Vulnerability Detector scans, generating the expected vulnerabilities.
    The verification of vulnerabilities is conducted through Vulnerabilities Index and API endpoint
    Additionally, the tests ensure the consistency of these values.

Tests:
    - TestInitialScans: Validates the initiation of Syscollector scans across all agents in the environment.
        - test_syscollector_first_scan: Validates the initiation of the first Syscollector scans across all agents in the environment.
        - test_syscollector_first_scan_index: Validates that the Vulnerability Detector detects vulnerabilities within the environment in the first scan in the index.
        - test_syscollector_second_scan: Validates the initiation of the second Syscollector scans across all agents in the environment.
        - tests_syscollector_first_second_scan_consistency_index: Ensure the consistency of the agent's vulnerabilities between the first and second scans in index.
    - TestScanSyscollectorCases: Validates the Vulnerability Detector's ability to detect new vulnerabilities in the environment.

Issue: https://github.com/wazuh/wazuh-qa/issues/4369

Components:
  - vulnerability_detector
  - syscollector

Environment: e2e_vulnerability_detector

Tiers: 0

Markers:
  - e2e
  - vulnerability_detector
  - tier0
"""
import os
import pytest
import logging
import yaml
import time
import datetime

from wazuh_testing.end_to_end import TestResult, Check, Evidence
from wazuh_testing.end_to_end.configuration import backup_configurations, restore_configuration, \
        configure_environment, save_indexer_credentials_into_keystore, change_agent_manager_ip, \
        load_vulnerability_detector_configurations
from wazuh_testing.end_to_end.logs import truncate_remote_host_group_files, check_errors_in_environment
from wazuh_testing.end_to_end.waiters import wait_until_vd_is_updated, wait_syscollector_and_vuln_scan
from wazuh_testing.end_to_end.monitoring import generate_monitoring_logs, monitoring_events_multihost, monitoring_syscollector_scan_agents
from wazuh_testing.end_to_end.regex import get_event_regex
from wazuh_testing.end_to_end.indexer_api import get_indexer_values
from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.remote_operations_handler import launch_parallel_operations, install_package, get_expected_vulnerabilities_by_agent, filter_vulnerabilities_by_packages
from wazuh_testing.end_to_end.vulnerability_detector import get_vulnerabilities_from_states, get_vulnerabilities_from_states_by_agent, \
        get_vulnerabilities_from_alerts_by_agent
from wazuh_testing.modules.syscollector import TIMEOUT_SYSCOLLECTOR_SCAN


pytestmark = [pytest.mark.e2e, pytest.mark.vulnerability_detector, pytest.mark.tier0]

local_path = os.path.dirname(os.path.abspath(__file__))
current_dir = os.path.dirname(__file__)
configurations_dir = os.path.join(current_dir, "configurations")
configurations_paths = {
        'manager': os.path.join(configurations_dir, 'manager.yaml'),
        'agent': os.path.join(configurations_dir, 'agent.yaml')
        }
agents_not_scanned_first_scan = []
first_scan_time = None
first_scan_vulnerabilities_index = {}

TIMEOUT_PER_AGENT_VULNERABILITY_SCAN = 300
AGENT_REGISTRATION_TIMEOUT = 15

expected_errors = [r'Invalid ID \d{3} for the source',
                   r'Unable to connect to .* No connection could be made because the target machine actively refused',
                   r'Process locked due to agent is offline. Waiting for connection',
                   r'Lost connection with manager. Setting lock',
                   r'Unable to connect to .*Connection refused',
                   r'Unable to connect to .*No connection could be made because the target machine actively refused it',]

def validate_operation_results(global_operation_results: dict) -> bool:
    for agent, agent_operation_results in global_operation_results.items():
        for operation_result in agent_operation_results:
            results = list(operation_result.values())
            if not all([result['success'] for result in results]):
                return False
    return True

def load_test_cases(file_path):
    with open(file_path, 'r') as cases_file:
        cases = yaml.load(cases_file, Loader=yaml.FullLoader)
    return cases if cases else []


def extract_case_info(cases):
    return [
        (
            case.get('preconditions'),
            case.get('body'),
            case.get('teardown')
        )
        for case in cases
    ]


def get_case_ids(cases):
    return [case['id'] for case in cases]


def clean_agents(host_manager, restart_managers=False):
    """Clean and register agents

    Args:
        host_manager (HostManager): An instance of the HostManager class.
        restart_managers (bool, optional): Whether to restart the managers. Defaults to False.
    """
    # Restart managers and stop agents
    logging.info("Stopping agents")
    host_manager.control_environment('stop', ['agent'], parallel=True)

    # Re-Register agents: https://github.com/wazuh/wazuh/issues/21185
    logging.info("Removing agents")
    host_manager.remove_agents()

    if restart_managers:
        logging.info("Restarting managers")
        host_manager.control_environment('restart', ['manager'], parallel=True)

    # Truncate alerts and logs of managers and agents
    logging.info("Truncate managers and agents logs")

    truncate_remote_host_group_files(host_manager, 'all', 'logs')


@pytest.fixture(scope='function')
def backup_configuration(host_manager: HostManager):

    hosts_configuration_backup = backup_configurations(host_manager)

    yield

    logging.error("Restoring original configuration")
    restore_configuration(host_manager, hosts_configuration_backup)

    logging.error("Restarting environment")

    host_manager.control_environment('restart', ['agent'], parallel=True)
    host_manager.control_environment('restart', ['manager'], parallel=True)


@pytest.fixture(scope='function')
def configure_vulnerability_detection_test_environment(host_manager: HostManager, vulnerability_detection_previously_enabled: bool):
    """Configure the environment with the given configurations

    Args:
        host_manager (HostManager): An instance of the HostManager class.
        configurations (dict): The configurations to apply to the environment
    """
    configure_environment(host_manager, load_vulnerability_detector_configurations(host_manager, configurations_paths=configurations_paths,
                                                                                   enable=vulnerability_detection_previously_enabled))

    logging.error("Save the Wazuh indexer username and password into the Wazuh manager keystore")
    save_indexer_credentials_into_keystore(host_manager)

    clean_agents(host_manager)

    utc_now_timestamp = datetime.datetime.utcnow()
    test_timestamp = utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%SZ")

    logging.error("Restarting managers")
    host_manager.control_environment('restart', ['manager'], parallel=True)

    if vulnerability_detection_previously_enabled:
        logging.error("Wait until Vulnerability Detector has update all the feeds")
        wait_until_vd_is_updated(host_manager)

    # Start agents
    host_manager.control_environment('restart', ['agent'], parallel=True)

    # Wait until agents are registered again
    time.sleep(AGENT_REGISTRATION_TIMEOUT * len(host_manager.get_group_hosts('agent')))

    if not vulnerability_detection_previously_enabled:

        configure_environment(host_manager, load_vulnerability_detector_configurations(host_manager, configurations_paths=configurations_paths,
                                                                                       enable=True))
        host_manager.control_environment('restart', ['manager'], parallel=True)

        logging.error("Wait until Vulnerability Detector has update all the feeds")
        wait_until_vd_is_updated(host_manager)

    yield test_timestamp

    # Truncate alerts and logs of managers and agents
    logging.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')


@pytest.fixture(scope='function')
def mock_example1(request, mocker, vulnerability_detection_previously_enabled):
    import json
    errors =  {
            'agent1': {
                'ERROR': [],
                'CRITICAL': [],
                'WARNING': []
            },
            'agent2': {
                'ERROR': [],
                'CRITICAL': [],
                'WARNING': []
            }
        }

    vulnerabilities = {}
    testing_dir = '/home/rebits/Wazuh/VDCases'

    file_name = 'vulnerabilities_index_first_scanTrue.json' if vulnerability_detection_previously_enabled else 'vulnerabilities_index_first_scanFalse.json'

    file_name = os.path.join(testing_dir, file_name)
    with open(file_name, 'r') as file:
        vulnerabilities = json.load(file)

    mocker.patch(f'{__name__}.check_errors_in_environment',
                      return_value=errors)
    mocker.patch(f'{__name__}.get_vulnerabilities_from_states_by_agent',
                      return_value=vulnerabilities)
    mocker.patch(f'{__name__}.monitoring_syscollector_scan_agents', return_value=[])

    mocker.patch(f'{__name__}.time.sleep')

    mocker.path(f'TestInitialScans.get_agents_scanned_syscollector', return_value={'first_scan': ['agent1']})

    yield


@pytest.fixture(scope='function')
def mock_example2(request, mocker, get_agents_scanned_syscollector, get_initial_vulnerabilities_environment):
    import json
    errors =  {
            'agent1': {
                'ERROR': [],
                'CRITICAL': [],
                'WARNING': []
            },
            'agent2': {
                'ERROR': [],
                'CRITICAL': [],
                'WARNING': []
            }
        }

    vulnerabilities = {}
    testing_dir = '/home/rebits/Wazuh/VDCases'

    file_name = 'vulnerabilities_index_first_scanTrue.json'

    file_name = os.path.join(testing_dir, file_name)
    with open(file_name, 'r') as file:
        vulnerabilities = json.load(file)

    mocker.patch(f'{__name__}.check_errors_in_environment',
                      return_value=errors)
    mocker.patch(f'{__name__}.get_vulnerabilities_from_states_by_agent',
                      return_value=vulnerabilities)
    mocker.patch(f'{__name__}.monitoring_syscollector_scan_agents', return_value=[])

    mocker.patch(f'{__name__}.time.sleep')

    get_agents_scanned_syscollector['first_scan'] = ['agent1']
    get_initial_vulnerabilities_environment['vd_enabled_when_agents_registration'] = vulnerabilities

    yield


@pytest.mark.filterwarnings('ignore::urllib3.exceptions.InsecureRequestWarning')
class TestInitialScans():
    equals = lambda x, y: x == y
    empty = lambda x: len(x) == 0
    no_errors = lambda x: all(not any(x[host][level] for level in ["ERROR", "CRITICAL", "WARNING"]) for host in x)


    all_agents_scanned_syscollector_first_scan_check = Check('all_agents_scanned_syscollector_first_scan',
                                                             empty,
                                                             expected_evidences=['agents_not_scanned_syscollector_first_scan'])
    all_agents_scanned_vulnerability_first_scan_check = Check('all_agents_scanned_vulnerability_first_scan',
                                                              empty,
                                                              expected_evidences=['agents_not_scanned_vulnerability_first_scan'])
    initial_vulnerabilities_consistent = Check('initial_vulnerabilities_consistent',
                                                             equals,
                                                             expected_evidences=['vd_disabled_when_agents_registration', 'vd_enabled_when_agents_registration'])

    vulnerabilities_consistent_first_second_scan = Check('vulnerabilities_consistent_first_second_scan',
                                                         equals,
                                                         expected_evidences=['vulnerabilities_index_first_scan', 'vulnerabilities_index_second_scan'])

    all_agents_scanned_syscollector_second_scan_check = Check('all_agents_scanned_syscollector_second_scan',
                                                              empty,
                                                              expected_evidences=['agents_not_scanned_syscollector_second_scan'])


    no_errors_check = Check('no_errors', no_errors, expected_evidences=['error_level_messages'])


    @pytest.fixture(scope='function')
    def get_timestamp(self):
        utc_now_timestamp = datetime.datetime.utcnow()
        return utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%SZ")

    @pytest.fixture(scope='class')
    def get_initial_vulnerabilities_environment(self):
        initial_vulnerabilities_environment = {
            'vd_disabled_when_agents_registration': None,
            'vd_enabled_when_agents_registration': None
        }

        yield initial_vulnerabilities_environment

    @pytest.mark.parametrize('vulnerability_detection_previously_enabled', [False, True], ids=['vd_disabled_when_agents_registration', 'vd_enabled_when_agents_registration'])
    def test_first_syscollector_scan(self, request, host_manager, vulnerability_detection_previously_enabled,
                                     configure_vulnerability_detection_test_environment,
                                     record_property, get_initial_vulnerabilities_environment):
        """
        description: Validates the initiation of the first Syscollector scans across all agents in the environment.

        This test ensures that Syscollector first scans are started in all agents in the environment.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - vulnerability_detection_previously_enabled:
                type: fixture
                brief: Whether the vulnerability detection was previously enabled
            - configure_environment:
                type: fixture
                brief: Configure the environment with the given configurations
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned
        """
        # Init test checks
        test_result = TestResult(request.node.name)

        test_result.add_check(self.all_agents_scanned_syscollector_first_scan_check)
        test_result.add_check(self.all_agents_scanned_vulnerability_first_scan_check)
        test_result.add_check(self.no_errors_check)

        record_property('test_result', test_result)

        # Wait until syscollector scan is started in all agents
        global agents_not_scanned_first_scan
        global first_scan_time
        global first_scan_vulnerabilities_index

        first_scan_time = configure_vulnerability_detection_test_environment

        # Store the in a global variable the agents that has been scanned by syscollector in the first scan
        # Only is stored the last test case result in order to make the comparision with the second scan
        agents_not_scanned_first_scan = monitoring_syscollector_scan_agents(host_manager,
                                                                                          TIMEOUT_SYSCOLLECTOR_SCAN)
        agents_to_check = [agent for agent in host_manager.get_group_hosts('agent') if agent not in agents_not_scanned_first_scan]

        # Validate that all agents has been scanned by syscollector
        test_result.validate_check('all_agents_scanned_syscollector_first_scan',
                                   [Evidence('agents_not_scanned_syscollector_first_scan',
                                             agents_not_scanned_first_scan)])

        # If no agent has been scanned by syscollector, the test can not continue
        if len(agents_to_check) == 0:
            logging.critical("Critical error. Test can not continue")
            pytest.fail("Syscollector scan not started in any agent. Check agent logs for more information")

        logging.critical(f"Waiting until agent all agents have been scanned.")
        time.sleep(TIMEOUT_PER_AGENT_VULNERABILITY_SCAN * len(agents_to_check))

        logging.critical("Checking vulnerabilities in the index")
        vuln_by_agent_index = get_vulnerabilities_from_states_by_agent(host_manager, agents_to_check,
                                                                       greater_than_timestamp=configure_vulnerability_detection_test_environment)

        # Store the vulnerabilities in the global variable to make the comparision in test_consistency_initial_scans
        initial_vuln_key = 'vd_disabled_when_agents_registration' if not vulnerability_detection_previously_enabled else 'vd_enabled_when_agents_registration'
        get_initial_vulnerabilities_environment[initial_vuln_key] = vuln_by_agent_index
        first_scan_vulnerabilities_index = vuln_by_agent_index

        logging.critical("Checking that all agents has been scanned and generated vulnerabilities in the index")
        agent_not_scanned = []
        for agent, vulnerabilities in vuln_by_agent_index.items():
            # We expect at least one vulnerability in each agent
            if len(vulnerabilities) == 0:
                logging.critical(f"No vulnerabilities found for {agent}")
                agent_not_scanned.append(agent)

        # Validate that all agents has been scanned and generated vulnerabilities in the index
        test_result.validate_check('all_agents_scanned_vulnerability_first_scan', [Evidence('agents_not_scanned_vulnerability_first_scan',
                                                                                            agent_not_scanned),
                                                                                   Evidence('vulnerabilities_index_first_scan',
                                                                                            vuln_by_agent_index,
                                                                                            debug=True)])

        logging.critical("Checking for errors in the environment")
        unexpected_errors = check_errors_in_environment(host_manager, expected_errors=expected_errors)
        test_result.validate_check('no_errors', [Evidence('error_level_messages', unexpected_errors)])

        assert test_result.get_test_result(), test_result.report()

    def test_consistency_initial_scans(self, request, host_manager, get_initial_vulnerabilities_environment, record_property):
        """
        description: Ensure the consistency of the agent's vulnerabilities neither the agent was registered nor the vulnerability detection was enabled.

        This test ensures that the agent's vulnerabilities are consistent with the initial scan.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment

        assertions:
            - Verify that the number of vulnerabilities is the same between scans
        """
        test_result = TestResult(request.node.name)
        test_result.add_check(self.initial_vulnerabilities_consistent)

        record_property('test_result', test_result)
        test_result.validate_check('initial_vulnerabilities_consistent',
                                   [Evidence('vd_disabled_when_agents_registration', get_initial_vulnerabilities_environment['vd_disabled_when_agents_registration']),
                                    Evidence('vd_enabled_when_agents_registration', get_initial_vulnerabilities_environment['vd_enabled_when_agents_registration'])])

        assert test_result.get_test_result(), test_result.report()


    def test_syscollector_second_scan(self, request, host_manager, record_property):
        """
        description: Validates the initiation of the second Syscollector scans across all agents in the environment.

        This test ensures that Syscollector second scans are started in all agents in the environment.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """
        TIMEOUT_SECOND_SCAN = 60

        test_result = TestResult(request.node.name)

        test_result.add_check(self.all_agents_scanned_syscollector_second_scan_check)
        test_result.add_check(self.no_errors_check)
        test_result.add_check(self.vulnerabilities_consistent_first_second_scan)

        record_property('test_result', test_result)

        global agents_not_scanned_first_scan

        # Filter agents that has not been scanned
        agents_to_check = [agent for agent in host_manager.get_group_hosts('agent') if agent not in agents_not_scanned_first_scan]
        if len(agents_to_check) == 0:
            pytest.skip("First scan was not executed or no agent was scanned. Skipping test")

        agents_not_scanned_second_scan = monitoring_syscollector_scan_agents(host_manager, TIMEOUT_SYSCOLLECTOR_SCAN)

        test_result.validate_check('all_agents_scanned_syscollector_second_scan',
                             [Evidence('agents_not_scanned_syscollector_second_scan', agents_not_scanned_second_scan)])

        agents_to_check_vulns = [agent for agent in host_manager.get_group_hosts('agent') if agent not in agents_not_scanned_second_scan]

        if len(agents_to_check_vulns) == 0:
            pytest.fail("Syscollector scan not started in any agent. Check agent logs for more information")

        logging.critical(f"Waiting until agent all agents have been scanned.")
        time.sleep(TIMEOUT_SECOND_SCAN)

        global first_scan_time

        logging.critical("Checking vulnerabilities in the index")
        vuln_by_agent_index = get_vulnerabilities_from_states_by_agent(host_manager, agents_to_check_vulns,
                                                                       greater_than_timestamp=first_scan_time)

        logging.critical("Checking that all agents has been scanned and generated vulnerabilities in the index")
        test_result.validate_check('vulnerabilities_consistent_first_second_scan',
                                   [Evidence('vulnerabilities_index_first_scan', first_scan_vulnerabilities_index),
                                    Evidence('vulnerabilities_index_second_scan', vuln_by_agent_index)])

        unexpected_errors = check_errors_in_environment(host_manager, expected_errors=expected_errors)
        test_result.validate_check('no_errors', [Evidence('error_level_messages', unexpected_errors)])

        assert test_result.get_test_result(), test_result.report()


class TestScanSyscollectorCases():

    # Load basic test cases
    basic_cases_path = os.path.join(current_dir, 'cases', 'test_vulnerability.yaml')
    cases = load_test_cases(basic_cases_path)
    complete_list = extract_case_info(cases)
    list_ids = get_case_ids(cases)

    # Load single vulnerable case
    single_vulnerable_packages_cases_path = os.path.join(current_dir, 'cases',
                                                'test_vulnerability_single_vulnerable_case.yaml')
    single_vulnerable_package_case = load_test_cases(single_vulnerable_packages_cases_path)
    single_vulnerable_case_complete_list = extract_case_info(single_vulnerable_package_case)
    single_vulnerable_case_list_ids = get_case_ids(single_vulnerable_package_case)

    # Load change manager test cases
    change_manager_cases_path = os.path.join(current_dir, 'cases', 'change_manager_cases.yaml')
    cases_change_manager = load_test_cases(change_manager_cases_path)
    test_cases_change_manager = extract_case_info(cases_change_manager)
    list_ids_change_manager = get_case_ids(cases_change_manager)

    no_errors = lambda x: all(not any(x[host][level] for level in ["ERROR", "CRITICAL", "WARNING"]) for host in x)
    no_errors_check = Check('no_errors', no_errors, expected_evidences=['error_level_messages'])


    operation_successfull_for_all_agents = validate_operation_results
    operation_successfull_for_all_agents_check = Check('operation_successfull_for_all_agents',
                                                       operation_successfull_for_all_agents,
                                                       expected_evidences=['operation_results'])

    @pytest.fixture(scope='function')
    def permutate_agents_managers(self, host_manager):
        logging.error("Backup original configuration")
        configuration_backup = backup_configurations(host_manager)
        list_of_managers = host_manager.get_group_hosts('manager')

        for agent in host_manager.get_group_hosts('agent'):
            agent_current_manager = host_manager.get_host_variables(agent)['manager']
            manager_index = list_of_managers.index(agent_current_manager)
            next_manager = list_of_managers[(manager_index + 1)%len(list_of_managers)]
            agent_os = host_manager.get_host_variables(agent)['os_name']

            manager_ip = host_manager.get_host_variables(next_manager)['public_ip'] if agent_os == 'macos' \
                    else host_manager.get_host_variables(next_manager)['ip']

            logging.error(f"Changing manager for agent {agent} to {next_manager} ({manager_ip})")
            change_agent_manager_ip(host_manager, agent, manager_ip)

        yield

        logging.error("Restoring original configuration")
        restore_configuration(host_manager, configuration_backup)

    @pytest.mark.parametrize('preconditions, body, teardown', single_vulnerable_case_complete_list, ids=single_vulnerable_case_list_ids)
    def test_install_vulnerable_package_when_agent_down(self, host_manager, request,
                                                        record_property, preconditions, body, teardown,
                                                        setup):
        """
        description: Install a vulnerable package when the agent is down.

        This test ensures that the Vulnerability Detector detects the vulnerability when the agent is down.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - configure_environment:
                type: fixture
                brief: Configure the environment with the given configurations
            - get_results: fixture to get the results of global class tests

        assertions:
        """
        # global agents_not_scanned_first_scan

        # if len(agents_not_scanned_first_scan) == 0:
        #     pytest.skip("No agent was scanned in the first scan. Skipping test. Is mandatory to launch this test along with the first scan test")

        agents_not_scanned_first_scan = []
        agents_to_check = [agent for agent in host_manager.get_group_hosts('agent') if agent not in agents_not_scanned_first_scan]

        test_result = TestResult(request.node.name)
        test_result.add_check(self.no_errors_check)
        test_result.add_check(self.operation_successfull_for_all_agents_check)

        record_property('test_result', test_result)

        basic_install_vulnerable_package_task = [case for case in self.cases if case['id'] == 'install_package'][0]
        operations_result = launch_parallel_operations(basic_install_vulnerable_package_task['body']['tasks'],
                                   host_manager, agents_not_scanned_first_scan)

        time_after_install = datetime.datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S")

        logging.critical(f"Remote operation results: {operations_result}")
        test_result.validate_check('operation_successfull_for_all_agents',
                                   [Evidence('operation_results', operations_result)])

        logging.critical('Checking vulnerabilites')

        test_result.validate_check('no_errors', [Evidence('error_level_messages',
                                                          check_errors_in_environment(host_manager, expected_errors=expected_errors))])

        logging.critical(f"Time after install: {time_after_install}")

        assert test_result.get_test_result(), test_result.report()


    @pytest.mark.parametrize('preconditions, body, teardown', test_cases_change_manager, ids=list_ids_change_manager)
    def test_change_agent_manager(self, permutate_agents_managers, request, preconditions, body, teardown, setup,
                                  host_manager, get_results):
        setup_results = setup
        results = get_results
        test_name = request.node.name
        results[request.node.name] = {}
        results['setup'] = setup_results

        hosts_to_ignore = []

        for host in setup_results.keys():
            if setup_results[host]['checks']['all_successfull'] is False:
                hosts_to_ignore.append(host)

        if len(hosts_to_ignore) > 0:
            logging.critical(f"Setup test failed for hosts {hosts_to_ignore}. Check logs for more information")
            logging.critical(f"Evidences: {setup_results}")
            logging.critical("Ignoring these hosts for the rest of the test")

        logging.critical("Starting scan cases tests")
        logging.critical(f"Case Info: {body}")

        # Launch tests tasks
        test_result = launch_parallel_operations(body['tasks'], host_manager, hosts_to_ignore)

        success_for_all_agents = True

        for host in test_result.keys():
            if test_result[host]['checks']['all_successfull'] is False:
                success_for_all_agents = False
                logging.critical(f"Test failed for host {host}. Check logs for more information")
                logging.critical(f"Evidences: {test_result[host]['evidences']}")

        results[test_name]['evidences'] = {}

        for agent in test_result.keys():
            if 'evidences' in test_result[agent]:
                for evidence, evidence_values in test_result[agent]['evidences'].items():
                    results[test_name]['evidences'][str(agent)+str(evidence)] = evidence_values

        if 'evidences' in test_result:
            results[test_name]['evidences'] = test_result['evidences']

        results[test_name] = test_result

        assert success_for_all_agents is True, "Test failed. Check logs for more information"


    @pytest.mark.parametrize('preconditions, body, teardown', complete_list, ids=list_ids)
    def test_vulnerability_detector_scans_cases(self, request, preconditions, body, teardown, setup,
                                                host_manager, get_results):
        test_name = request.node.name

        setup_results = setup
        results = get_results
        results[request.node.name] = {}
        results['setup'] = setup_results

        hosts_to_ignore = []

        for host in setup_results.keys():
            if setup_results[host]['checks']['all_successfull'] is False:
                hosts_to_ignore.append(host)

        if len(hosts_to_ignore) > 0:
            logging.critical(f"Setup test failed for hosts {hosts_to_ignore}. Check logs for more information")
            logging.critical(f"Evidences: {setup_results}")
            logging.critical("Ignoring these hosts for the rest of the test")

        logging.critical("Starting scan cases tests")
        logging.critical(f"Case Info: {body}")

        # Launch tests tasks
        test_result = launch_parallel_operations(body['tasks'], host_manager, hosts_to_ignore)

        success_for_all_agents = True

        for host in test_result.keys():
            if test_result[host]['checks']['all_successfull'] is False:
                success_for_all_agents = False
                logging.critical(f"Test failed for host {host}. Check logs for more information")
                logging.critical(f"Evidences: {test_result[host]['evidences']}")

        results[test_name]['evidences'] = {}

        for agent in test_result.keys():
            if 'evidences' in test_result[agent]:
                for evidence, evidence_values in test_result[agent]['evidences'].items():
                    results[test_name]['evidences'][str(agent)+str(evidence)] = evidence_values

        if 'evidences' in test_result:
            results[test_name]['evidences'] = test_result['evidences']

        results[test_name] = test_result

        assert success_for_all_agents is True, "Test failed. Check logs for more information"
