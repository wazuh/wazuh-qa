# Copyright (C) 2015, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2

"""
Vulnerability Detector Basic Cases Tests
----------------------------------------

Type: End-to-End (E2E)

Brief:
    This module contains basic tests to ensure the proper functionality of the Vulnerability Detector.
    The tests validate that initial Syscollector scans, along with installation, removal, and uninstall operations,
    trigger Vulnerability Detector scans, generating the expected vulnerabilities.
    The verification of vulnerabilities is conducted through Vulnerabilities Index and API endpoint
    Additionally, the tests ensure the consistency of these values.

Tests:
    - TestInitialScans: Validates the initiation of Syscollector scans across all agents in the environment.
        - test_syscollector_first_scan: Validates the initiation of the first Syscollector scans across all agents
                                        in the environment.
        - test_syscollector_first_scan_index: Validates that the Vulnerability Detector detects vulnerabilities
                                              within the environment in the first scan in the index.
        - test_syscollector_second_scan: Validates the initiation of the second Syscollector scans
                                         across all agents in the environment.
        - tests_syscollector_first_second_scan_consistency_index: Ensure the consistency of the agent's vulnerabilities
                                                                  between the first and second scans in index.
    - TestScanSyscollectorCases: Validates the Vulnerability Detector's ability to detect new vulnerabilities in the
                                 environment for each of the defined cases.

Issue: https://github.com/wazuh/wazuh-qa/issues/4369

Components:
  - vulnerability_detector
  - syscollector

Environment: e2e_vulnerability_detector

Tiers: 0

Markers:
  - e2e
  - vulnerability_detector
  - tier0
"""
import datetime
import logging
import os
import time

import pytest
from wazuh_testing.end_to_end import Check, Evidence, TestResult, VD_E2E_TIMEOUT_SYSCOLLECTOR_SCAN
from wazuh_testing.end_to_end.check_validators import (
    compare_expected_found_vulnerabilities,
    compare_expected_found_vulnerabilities_alerts, empty, empty_dict, equals,
    equals_but_not_empty, no_errors, validate_operation_results, get_duplicated_vulnerabilities)
from wazuh_testing.end_to_end.configuration import (
    backup_configurations, change_agent_manager_ip, configure_environment,
    load_vulnerability_detector_configurations, restore_configuration,)
from wazuh_testing.end_to_end.logs import check_errors_in_environment
from wazuh_testing.end_to_end.monitoring import \
    monitoring_syscollector_scan_agents
from wazuh_testing.end_to_end.remote_operations_handler import (
    get_expected_alerts, get_expected_index, get_vulnerabilities_index,
    get_vulnerability_alerts, launch_parallel_operations)
from wazuh_testing.end_to_end.utils import (extract_case_info, get_case_ids,
                                            load_test_cases)
from wazuh_testing.end_to_end.vulnerability_detector import (TIMEOUT_PER_AGENT_VULNERABILITY_FIRST_SCAN,
                                                             PACKAGE_VULNERABILITY_SCAN_TIME,
                                                             get_vulnerabilities_from_states_by_agent)
from wazuh_testing.end_to_end.waiters import wait_until_vd_is_updated
from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.indexer_api import (INDEXER_RESULT_WINDOWS_VULN_E2E,
                                                 extend_result_window,
                                                 get_wazuh_states_vulnerabilities_indexname)

pytestmark = [pytest.mark.e2e, pytest.mark.vulnerability_detector, pytest.mark.tier0]

# Wazuh Indexer abuseControl timeout set to 30 minutes (1800 seconds)
MINIMUM_TIMEOUT_RESCAN = 1800

AGENTS_SCANNED_FIRST_SCAN = []
FIRST_SCAN_TIME = None
FIRST_SCAN_VULNERABILITIES_INDEX = {}
AGENT_REGISTRATION_TIMEOUT = 15

VULNERABILITY_DETECTION_E2E_EXPECTED_ERRORS = [
    r"Invalid ID \d{3} for the source",
    r"Unable to connect to .* No connection could be made because the target machine actively refused",
    r"Process locked due to agent is offline. Waiting for connection",
    r"Lost connection with manager. Setting lock",
    r"Unable to connect to .*Connection refused",
    r"Unable to connect to .*No connection could be made because the target machine actively refused it",
    r"Waiting for server reply \(not started\). Tried: .*Ensure that the manager version is .*",
    r"Unable to connect to any server",
    r"Agent key already in use"
]
INITIAL_VULNERABILITIES = {
    "vd_disabled_when_agents_registration": {},
    "vd_enabled_when_agents_registration": {},
}


def configure_vulnerability_detection_and_wait_until_feeds_are_updated(
    host_manager: HostManager, vulnerability_detection_enabled: bool
) -> None:
    """Configure the environment with the default Vulnerability Detection configuration.

    Args:
        host_manager (HostManager): Instance of the HostManager class.
        vulnerability_detection_enabled (bool): True if the vulnerability detection is enabled, False otherwise
    """
    logging.error(
        f"Configuring the environment: Vulnerability Detection Enabled: {vulnerability_detection_enabled}"
    )
    current_dir = os.path.dirname(__file__)
    configurations_dir = os.path.join(current_dir, "configurations")
    configurations_paths = {
        "manager": os.path.join(configurations_dir, "manager.yaml"),
        "agent": os.path.join(configurations_dir, "agent.yaml"),
    }

    configure_environment(
        host_manager,
        load_vulnerability_detector_configurations(
            host_manager,
            configurations_paths=configurations_paths,
            enable=vulnerability_detection_enabled,
        ),
    )

    logging.error("Restarting managers")
    host_manager.control_environment("restart", ["manager"], parallel=True)

    if vulnerability_detection_enabled:
        logging.error("Wait until Vulnerability Detector has update all the feeds")
        wait_until_vd_is_updated(host_manager)


def start_agent_and_wait_until_connected(host_manager: HostManager) -> None:
    """Start agents and wait until they are connected

    Args:
        host_manager (HostManager): HostManager fixture
    """
    logging.error("Starting agents")
    host_manager.control_environment("restart", ["agent"], parallel=True)

    logging.error("Wait until agents are connected")
    time.sleep(AGENT_REGISTRATION_TIMEOUT * len(host_manager.get_group_hosts("agent")))


@pytest.fixture(scope="function")
def configure_vulnerability_detection_test_environment(
    host_manager: HostManager, vulnerability_detection_previously_enabled: bool
):
    """Configure the test environment for Vulnerability Detection.

    This fixture sets up the Vulnerability Detection environment based on the provided test case.
    It performs the following actions:
        - Cleans agent logs
        - Configures the environment with the default VD template configuration,
          enabling or disabling VD depending on the test case.
            - If VD needs to be previously enabled, waits for feeds to be updated.
        - Starts the agents.
            - If VD needs to be previously disabled, enables VD and waits for feeds.

    Args:
        host_manager (HostManager): Instance of the HostManager class.
        vulnerability_detection_previously_enabled (bool): Indicates whether Vulnerability Detection
                                                           was previously enabled.

    Yields:
        str: Timestamp of the test.
    """
    host_manager.clean_agents()

    utc_now_timestamp = datetime.datetime.now(datetime.timezone.utc)

    # Format the date and time as per the given format
    test_timestamp = utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%S")

    configure_vulnerability_detection_and_wait_until_feeds_are_updated(
        host_manager, vulnerability_detection_previously_enabled
    )

    start_agent_and_wait_until_connected(host_manager)

    if not vulnerability_detection_previously_enabled:
        configure_vulnerability_detection_and_wait_until_feeds_are_updated(
            host_manager, True
        )

    yield test_timestamp


def max_result_window(host_manager):
    vuln_index = get_wazuh_states_vulnerabilities_indexname()
    extend_result_window(host_manager, index=vuln_index, new_max_result_window=INDEXER_RESULT_WINDOWS_VULN_E2E)


@pytest.mark.filterwarnings("ignore::urllib3.exceptions.InsecureRequestWarning")
class TestInitialScans:
    # Checks definition
    all_agents_scanned_syscollector_first_scan_check = Check(
        "all_agents_scanned_syscollector_first_scan",
        empty,
        expected_evidences=["agents_not_scanned_syscollector_first_scan"],
    )
    all_agents_scanned_vulnerability_first_scan_check = Check(
        "all_agents_scanned_vulnerability_first_scan",
        empty,
        expected_evidences=["agents_not_scanned_vulnerability_first_scan"],
    )
    initial_vulnerabilities_consistent = Check(
        "initial_vulnerabilities_consistent",
        equals_but_not_empty,
        expected_evidences=[
            "vd_disabled_when_agents_registration",
            "vd_enabled_when_agents_registration",
        ],
    )
    vulnerabilities_consistent_first_second_scan = Check(
        "vulnerabilities_consistent_first_second_scan",
        equals,
        expected_evidences=[
            "vulnerabilities_index_first_scan",
            "vulnerabilities_index_second_scan",
        ],
    )
    all_agents_scanned_syscollector_second_scan_check = Check(
        "all_agents_scanned_syscollector_second_scan",
        empty,
        expected_evidences=["agents_not_scanned_syscollector_second_scan"],
    )
    no_errors_check = Check(
        "no_errors", no_errors, expected_evidences=["error_level_messages"]
    )

    @pytest.fixture(scope="function")
    def get_timestamp(self):
        utc_now_timestamp = datetime.datetime.now(datetime.timezone.utc)
        test_timestamp = utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%S")

        return test_timestamp

    @pytest.mark.parametrize(
        "vulnerability_detection_previously_enabled",
        [False, True],
        ids=[
            "vd_disabled_when_agents_registration",
            "vd_enabled_when_agents_registration",
        ],
    )
    def test_first_syscollector_scan(
        self,
        request,
        host_manager,
        save_indexer_credentials_keystore,
        vulnerability_detection_previously_enabled,
        configure_vulnerability_detection_test_environment,
        record_property,
        clean_environment_logs,
        delete_states_vulnerability_index
    ):
        """
        description: Validates the initiation of the first Syscollector scans across all agents in the environment.

        This test ensures that Syscollector first scans are started in all agents in the environment.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - vulnerability_detection_previously_enabled:
                type: fixture
                brief: Whether the vulnerability detection was previously enabled
            - configure_environment:
                type: fixture
                brief: Configure the environment with the given configurations
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned
        """
        global AGENTS_SCANNED_FIRST_SCAN
        global FIRST_SCAN_TIME
        global FIRST_SCAN_VULNERABILITIES_INDEX
        global INITIAL_VULNERABILITIES

        FIRST_SCAN_TIME = configure_vulnerability_detection_test_environment

        test_result = TestResult(request.node.name)
        test_result.add_check(self.all_agents_scanned_syscollector_first_scan_check)
        test_result.add_check(self.all_agents_scanned_vulnerability_first_scan_check)
        test_result.add_check(self.no_errors_check)

        record_property("test_result", test_result)

        # Store the agents scanned by syscollector in a global variable.
        # Only the last test case result is retained for comparison with the second scan.
        agents_not_scanned_first_scan = monitoring_syscollector_scan_agents(host_manager,
                                                                            VD_E2E_TIMEOUT_SYSCOLLECTOR_SCAN)

        AGENTS_SCANNED_FIRST_SCAN = [
            agent
            for agent in host_manager.get_group_hosts("agent")
            if agent not in agents_not_scanned_first_scan
        ]

        test_result.validate_check(
            "all_agents_scanned_syscollector_first_scan",
            [
                Evidence(
                    "agents_not_scanned_syscollector_first_scan",
                    agents_not_scanned_first_scan,
                )
            ],
        )

        if len(AGENTS_SCANNED_FIRST_SCAN) == 0:
            logging.critical("Critical error. Test can not continue")
            pytest.fail(
                "Syscollector scan not started in any agent. Check agent logs for more information"
            )

        logging.critical("Waiting 30 minutes to avoid Indexer abuseControl.")
        time.sleep(MINIMUM_TIMEOUT_RESCAN)

        logging.critical("Waiting until agent all agents have been scanned.")
        time.sleep(TIMEOUT_PER_AGENT_VULNERABILITY_FIRST_SCAN * len(AGENTS_SCANNED_FIRST_SCAN))

        max_result_window(host_manager)
        logging.critical("Checking vulnerabilities in the index")
        vuln_by_agent_index = get_vulnerabilities_from_states_by_agent(
            host_manager,
            AGENTS_SCANNED_FIRST_SCAN,
            greater_than_timestamp=FIRST_SCAN_TIME,
            size=INDEXER_RESULT_WINDOWS_VULN_E2E
        )

        # Store the vulnerabilities in the global variable to make the comparision in test_consistency_initial_scans
        if not vulnerability_detection_previously_enabled:
            INITIAL_VULNERABILITIES["vd_disabled_when_agents_registration"] = (
                vuln_by_agent_index
            )
        else:
            INITIAL_VULNERABILITIES["vd_enabled_when_agents_registration"] = (
                vuln_by_agent_index
            )

        FIRST_SCAN_VULNERABILITIES_INDEX = vuln_by_agent_index

        logging.critical(
            "Checking that all agents has been scanned and generated vulnerabilities in the index"
        )

        agent_not_scanned = []
        # We expect at least one vulnerability in each agent
        for agent, vulnerabilities in vuln_by_agent_index.items():
            if len(vulnerabilities) == 0:
                logging.critical(f"No vulnerabilities found for {agent}")
                agent_not_scanned.append(agent)

        # Validate that all agents has been scanned and generated vulnerabilities in the index
        test_result.validate_check(
            "all_agents_scanned_vulnerability_first_scan",
            [
                Evidence(
                    "agents_not_scanned_vulnerability_first_scan", agent_not_scanned
                ),
                Evidence(
                    "vulnerabilities_index_first_scan", vuln_by_agent_index, debug=True
                ),
            ],
        )

        logging.critical("Checking for errors in the environment")
        unexpected_errors = check_errors_in_environment(
            host_manager, expected_errors=VULNERABILITY_DETECTION_E2E_EXPECTED_ERRORS
        )

        test_result.validate_check(
            "no_errors", [Evidence("error_level_messages", unexpected_errors)]
        )

        assert test_result.get_test_result(), test_result.report()

    def test_consistency_initial_scans(self, request, record_property):
        """
        description: Ensure the consistency of the agent's vulnerabilities neither the agent was registered nor.

        This test ensures that the agent's vulnerabilities are consistent with the initial scan.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment

        assertions:
            - Verify that the number of vulnerabilities is the same between scans
        """
        test_result = TestResult(request.node.name)
        test_result.add_check(self.initial_vulnerabilities_consistent)

        record_property("test_result", test_result)
        test_result.validate_check(
            "initial_vulnerabilities_consistent",
            [
                Evidence(
                    "vd_disabled_when_agents_registration",
                    INITIAL_VULNERABILITIES["vd_disabled_when_agents_registration"],
                ),
                Evidence(
                    "vd_enabled_when_agents_registration",
                    INITIAL_VULNERABILITIES["vd_enabled_when_agents_registration"],
                ),
            ],
        )

        assert test_result.get_test_result(), test_result.report()

    def test_syscollector_second_scan(
        self,
        request,
        host_manager,
        record_property,
        get_timestamp,
        clean_environment_logs,
        delete_states_vulnerability_index,
    ):
        """
        description: Validates the initiation of the second Syscollector scans across all agents in the environment.

        This test ensures that Syscollector second scans are started in all agents in the environment.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing
            - get_results: fixture to get the results of global class tests

        assertions:
            - Verify that all agents has been scanned

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """
        TIMEOUT_SECOND_SCAN = 60

        global AGENTS_SCANNED_FIRST_SCAN

        test_result = TestResult(request.node.name)

        test_result.add_check(self.all_agents_scanned_syscollector_second_scan_check)
        test_result.add_check(self.no_errors_check)
        test_result.add_check(self.vulnerabilities_consistent_first_second_scan)

        record_property("test_result", test_result)

        if len(AGENTS_SCANNED_FIRST_SCAN) == 0:
            pytest.skip(
                "First scan was not executed or no agent was scanned. Skipping test"
            )

        agents_not_scanned_second_scan = monitoring_syscollector_scan_agents(
            host_manager,
            VD_E2E_TIMEOUT_SYSCOLLECTOR_SCAN,
            greater_than_timestamp=get_timestamp,
        )

        test_result.validate_check(
            "all_agents_scanned_syscollector_second_scan",
            [
                Evidence(
                    "agents_not_scanned_syscollector_second_scan",
                    agents_not_scanned_second_scan,
                )
            ],
        )

        agents_to_check_vulns = [
            agent
            for agent in host_manager.get_group_hosts("agent")
            if agent not in agents_not_scanned_second_scan
        ]

        if len(agents_to_check_vulns) == 0:
            pytest.fail(
                "Syscollector scan not started in any agent. Check agent logs for more information"
            )

        logging.critical("Waiting until agent all agents have been scanned.")
        time.sleep(TIMEOUT_SECOND_SCAN)

        global FIRST_SCAN_TIME

        max_result_window(host_manager)

        logging.critical("Checking vulnerabilities in the index")
        vuln_by_agent_index = get_vulnerabilities_from_states_by_agent(
            host_manager, agents_to_check_vulns, greater_than_timestamp=FIRST_SCAN_TIME,
            size=INDEXER_RESULT_WINDOWS_VULN_E2E)

        logging.critical(
            "Checking that all agents has been scanned and generated vulnerabilities in the index"
        )
        test_result.validate_check(
            "vulnerabilities_consistent_first_second_scan",
            [
                Evidence(
                    "vulnerabilities_index_first_scan", FIRST_SCAN_VULNERABILITIES_INDEX
                ),
                Evidence("vulnerabilities_index_second_scan", vuln_by_agent_index),
            ],
        )

        unexpected_errors = check_errors_in_environment(
            host_manager,
            expected_errors=VULNERABILITY_DETECTION_E2E_EXPECTED_ERRORS,
            greater_than_timestamp=get_timestamp
        )

        test_result.validate_check(
            "no_errors", [Evidence("error_level_messages", unexpected_errors)]
        )

        assert test_result.get_test_result(), test_result.report()


@pytest.mark.filterwarnings("ignore::urllib3.exceptions.InsecureRequestWarning")
class TestScanSyscollectorCases:

    # Load basic test cases
    current_dir = os.path.dirname(__file__)
    basic_cases_path = os.path.join(current_dir, "cases", "test_vulnerability.yaml")
    cases = load_test_cases(basic_cases_path)
    complete_list = extract_case_info(cases)
    list_ids = get_case_ids(cases)

    # Load single vulnerable case
    single_vulnerable_packages_cases_path = os.path.join(
        current_dir, "cases", "test_vulnerability_single_vulnerable_case.yaml"
    )
    single_vulnerable_package_case = load_test_cases(
        single_vulnerable_packages_cases_path
    )
    single_vulnerable_case_complete_list = extract_case_info(
        single_vulnerable_package_case
    )
    single_vulnerable_case_list_ids = get_case_ids(single_vulnerable_package_case)

    # Load change manager test cases
    change_manager_cases_path = os.path.join(
        current_dir, "cases", "test_vulnerability_single_vulnerable_case.yaml"
    )
    cases_change_manager = load_test_cases(change_manager_cases_path)
    test_cases_change_manager = extract_case_info(cases_change_manager)
    list_ids_change_manager = get_case_ids(cases_change_manager)

    no_errors_check = Check(
        "no_errors", no_errors, expected_evidences=["error_level_messages"]
    )

    operation_successfull_for_all_agents = validate_operation_results
    operation_successfull_for_all_agents_check = Check(
        "operation_successfull_for_all_agents",
        operation_successfull_for_all_agents,
        expected_evidences=["operation_results"],
    )

    setup_successfull_for_all_agents_check = Check(
        "setup_operation_results",
        empty,
        expected_evidences=["setup_failed_agents"],
    )

    # Alerts Checks
    expected_vulnerability_affected_alert_check = Check(
        "expected_vulnerability_affected_alert",
        empty_dict,
        expected_evidences=["missing_affected_alerts"],
    )
    expected_vulnerability_mitigated_alert_check = Check(
        "expected_vulnerability_mitigated_alert",
        empty_dict,
        expected_evidences=["missing_mitigated_alerts"],
    )

    # Index Checks
    expected_vulnerabilities_found_in_index_check = Check(
        "expected_vulnerabilities_found_in_index",
        empty_dict,
        expected_evidences=["missing_vulnerabilities"],
    )
    no_unexpected_vulnerabilities_found_in_index_check = Check(
        "no_unexpected_vulnerabilities_found_in_index",
        empty_dict,
        expected_evidences=["unexpected_vulnerabilities"],
    )

    no_duplicated_vulnerabilities_check = Check('no_duplicated_vulnerabilities', empty,
                                                expected_evidences=['duplicated_vulnerabilities'])

    @pytest.fixture(scope="function")
    def permutate_agents_managers(self, host_manager):
        backup_configuration = backup_configurations(host_manager)

        list_of_managers = host_manager.get_group_hosts("manager")

        for agent in host_manager.get_group_hosts("agent"):
            agent_current_manager = host_manager.get_host_variables(agent)["manager"]
            manager_index = list_of_managers.index(agent_current_manager)
            next_manager = list_of_managers[(manager_index + 1) % len(list_of_managers)]
            agent_os = host_manager.get_host_variables(agent)["os_name"]

            manager_ip = (
                host_manager.get_host_variables(next_manager)["public_ip"]
                if agent_os == "macos"
                else host_manager.get_host_variables(next_manager)["ip"]
            )

            logging.error(
                f"Changing manager for agent {agent} to {next_manager} ({manager_ip})"
            )
            change_agent_manager_ip(host_manager, agent, manager_ip)

        # Restart agents to apply the new configuration changes
        logging.error("Restarting agents")
        host_manager.control_environment("restart", ["agent"], parallel=True)

        yield

        # Restore the original configuration after tests are done
        restore_configuration(host_manager, backup_configuration)

        # Restart agents again to ensure they reconnect with their original managers
        logging.error("Restarting agents")
        host_manager.control_environment("restart", ["agent"], parallel=True)

    @pytest.mark.parametrize("preconditions, body, teardown", single_vulnerable_case_complete_list,
                             ids=single_vulnerable_case_list_ids,)
    def test_install_vulnerable_package_when_agent_down(self, host_manager, request, record_property, preconditions,
                                                        body, teardown, setup, clean_environment_logs,
                                                        delete_states_vulnerability_index,
                                                        clean_environment_logs_function):
        """
        description: Install a vulnerable package when the agent is down.

        This test ensures that the Vulnerability Detector detects the vulnerability when the agent is down.

        tier: 0

        parameters:
            - request: pytest request object
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - configure_environment:
                type: fixture
                brief: Configure the environment with the given configurations
            - get_results: fixture to get the results of global class tests

        assertions:
        """
        # Is mandatory to launch this test along with the first scan test'
        global AGENTS_SCANNED_FIRST_SCAN
        if len(AGENTS_SCANNED_FIRST_SCAN) == 0:
            pytest.skip("No agent was scanned in the first scan. Skipping test.")

        target_to_ignore = list(
            set(host_manager.get_group_hosts("agent")) - set(AGENTS_SCANNED_FIRST_SCAN)
        )

        utc_now_timestamp = datetime.datetime.now(datetime.timezone.utc)
        test_timestamp = utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%S")

        test_result = TestResult(request.node.name)
        test_result.add_check(self.no_errors_check)
        test_result.add_check(self.operation_successfull_for_all_agents_check)
        test_result.add_check(self.expected_vulnerabilities_found_in_index_check)
        test_result.add_check(self.no_unexpected_vulnerabilities_found_in_index_check)
        test_result.add_check(self.no_duplicated_vulnerabilities_check)

        record_property("test_result", test_result)

        host_manager.control_environment("stop", ["agent"], parallel=True)

        # Install Vulnerable package
        operations_result = launch_parallel_operations(
            body, host_manager, target_to_ignore
        )

        logging.critical(f"Remote operation results: {operations_result}")
        test_result.validate_check(
            "operation_successfull_for_all_agents",
            [Evidence("operation_results", operations_result)],
        )

        host_manager.control_environment("start", ["agent"], parallel=True)

        time.sleep(AGENT_REGISTRATION_TIMEOUT * len(AGENTS_SCANNED_FIRST_SCAN))
        time.sleep(VD_E2E_TIMEOUT_SYSCOLLECTOR_SCAN + PACKAGE_VULNERABILITY_SCAN_TIME * len(AGENTS_SCANNED_FIRST_SCAN))

        package_data = [body["package"]]
        max_result_window(host_manager)

        vulnerabilities = get_vulnerabilities_index(host_manager, AGENTS_SCANNED_FIRST_SCAN, package_data,
                                                    size=INDEXER_RESULT_WINDOWS_VULN_E2E)
        expected_vulnerabilities = get_expected_index(host_manager, AGENTS_SCANNED_FIRST_SCAN, body["operation"],
                                                      body["package"])
        duplicated_vulnerabilities = get_duplicated_vulnerabilities(vulnerabilities)

        logging.critical("Validating found vulnerabilities")
        test_result.validate_check('no_duplicated_vulnerabilities',
                                   [Evidence('duplicated_vulnerabilities', duplicated_vulnerabilities),
                                    Evidence('vulnerabilities', vulnerabilities)
                                    ])

        result = compare_expected_found_vulnerabilities(vulnerabilities, expected_vulnerabilities)

        vulnerabilities_not_found = result["vulnerabilities_not_found"]
        vulnerabilities_unexpected = result["vulnerabilities_unexpected"]

        logging.critical("Validating found vulnerabilities")
        test_result.validate_check(
            "expected_vulnerabilities_found_in_index",
            [
                Evidence("missing_vulnerabilities", vulnerabilities_not_found),
                Evidence("vulnerabilities_found_in_index", vulnerabilities),
                Evidence("expected_vulnerabilities", expected_vulnerabilities),
            ],
        )

        logging.critical("Validating unexpected vulnerabilities")
        test_result.validate_check(
            "no_unexpected_vulnerabilities_found_in_index",
            [
                Evidence("unexpected_vulnerabilities", vulnerabilities_unexpected),
                Evidence("vulnerabilities_found_in_index", vulnerabilities),
                Evidence("expected_vulnerabilities", expected_vulnerabilities),
            ],
        )

        errors_environment = check_errors_in_environment(
            host_manager,
            expected_errors=VULNERABILITY_DETECTION_E2E_EXPECTED_ERRORS,
            greater_than_timestamp=test_timestamp
        )
        test_result.validate_check("no_errors", [Evidence("error_level_messages", errors_environment)])

        assert test_result.get_test_result(), test_result.report()

    @pytest.mark.parametrize("preconditions, body, teardown", test_cases_change_manager,
                             ids=list_ids_change_manager,)
    def test_change_agent_manager(self, permutate_agents_managers, request, preconditions, body,
                                  teardown, setup, host_manager, record_property, clean_environment_logs,
                                  delete_states_vulnerability_index, clean_environment_logs_function):
        # Is mandatory to launch this test along with the first scan test'
        global AGENTS_SCANNED_FIRST_SCAN
        if len(AGENTS_SCANNED_FIRST_SCAN) == 0:
            pytest.skip("No agent was scanned in the first scan. Skipping test.")

        target_to_ignore = list(
            set(host_manager.get_group_hosts("agent")) - set(AGENTS_SCANNED_FIRST_SCAN)
        )

        utc_now_timestamp = datetime.datetime.now(datetime.timezone.utc)
        test_timestamp = utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%S")

        test_result = TestResult(request.node.name)
        test_result.add_check(self.no_errors_check)
        test_result.add_check(self.operation_successfull_for_all_agents_check)
        test_result.add_check(self.expected_vulnerabilities_found_in_index_check)
        test_result.add_check(self.no_unexpected_vulnerabilities_found_in_index_check)
        test_result.add_check(self.expected_vulnerability_affected_alert_check)
        test_result.add_check(self.expected_vulnerability_mitigated_alert_check)
        test_result.add_check(self.no_duplicated_vulnerabilities_check)

        record_property("test_result", test_result)

        # Install Vulnerable package
        operations_result = launch_parallel_operations(
            body, host_manager, target_to_ignore
        )

        logging.critical(f"Remote operation results: {operations_result}")
        test_result.validate_check(
            "operation_successfull_for_all_agents",
            [Evidence("operation_results", operations_result)],
        )

        # Wait for Syscollector and VD Scan
        time.sleep(VD_E2E_TIMEOUT_SYSCOLLECTOR_SCAN + PACKAGE_VULNERABILITY_SCAN_TIME * len(AGENTS_SCANNED_FIRST_SCAN))

        package_data = [body["package"]]
        max_result_window(host_manager)

        vulnerabilities = get_vulnerabilities_index(host_manager, AGENTS_SCANNED_FIRST_SCAN, package_data,
                                                    size=INDEXER_RESULT_WINDOWS_VULN_E2E)
        expected_vulnerabilities = get_expected_index(host_manager, AGENTS_SCANNED_FIRST_SCAN, body["operation"],
                                                      body["package"])

        result = compare_expected_found_vulnerabilities(vulnerabilities, expected_vulnerabilities)

        vulnerabilities_not_found = result["vulnerabilities_not_found"]
        vulnerabilities_unexpected = result["vulnerabilities_unexpected"]
        duplicated_vulnerabilities = get_duplicated_vulnerabilities(vulnerabilities)

        logging.critical("Validating found vulnerabilities")
        test_result.validate_check('no_duplicated_vulnerabilities',
                                   [Evidence('duplicated_vulnerabilities', duplicated_vulnerabilities),
                                    Evidence('vulnerabilities', vulnerabilities)
                                    ])

        test_result.validate_check(
            "expected_vulnerabilities_found_in_index",
            [
                Evidence("missing_vulnerabilities", vulnerabilities_not_found),
                Evidence("vulnerabilities_found_in_index", vulnerabilities),
                Evidence("expected_vulnerabilities", expected_vulnerabilities),
            ],
        )

        logging.critical("Validating unexpected vulnerabilities")
        test_result.validate_check(
            "no_unexpected_vulnerabilities_found_in_index",
            [
                Evidence("unexpected_vulnerabilities", vulnerabilities_unexpected),
                Evidence("vulnerabilities_found_in_index", vulnerabilities),
                Evidence("expected_vulnerabilities", expected_vulnerabilities),
            ],
        )

        alerts = get_vulnerability_alerts(
            host_manager, AGENTS_SCANNED_FIRST_SCAN, package_data, test_timestamp
        )
        expected_alerts = get_expected_alerts(
            host_manager, AGENTS_SCANNED_FIRST_SCAN, body["operation"], body["package"]
        )

        result_alert = compare_expected_found_vulnerabilities_alerts(
            alerts, expected_alerts
        )

        logging.critical("Validating found alerts")
        test_result.validate_check(
            "expected_vulnerability_affected_alert",
            [
                Evidence(
                    "missing_affected_alerts",
                    result_alert["vulnerabilities_affected_not_found"],
                ),
                Evidence("alerts_found_in_index", alerts),
                Evidence("expected_alerts", expected_alerts),
            ],
        )

        logging.critical("Validating unexpected alerts")
        test_result.validate_check(
            "expected_vulnerability_mitigated_alert",
            [
                Evidence(
                    "missing_mitigated_alerts",
                    result_alert["vulnerabilities_mitigated_not_found"],
                ),
                Evidence("alerts_found_in_index", alerts),
                Evidence("expected_alerts", expected_alerts),
            ],
        )

        errors_environment = check_errors_in_environment(
            host_manager,
            expected_errors=VULNERABILITY_DETECTION_E2E_EXPECTED_ERRORS,
            greater_than_timestamp=test_timestamp
        )

        test_result.validate_check("no_errors", [Evidence("error_level_messages", errors_environment)])

        assert test_result.get_test_result(), test_result.report()

    @pytest.mark.parametrize("preconditions, body, teardown", complete_list, ids=list_ids)
    def test_vulnerability_detector_scans_cases(self, request, preconditions, body, teardown, setup, host_manager,
                                                record_property, clean_environment_logs,
                                                delete_states_vulnerability_index,
                                                clean_environment_logs_function):
        # Is mandatory to launch this test along with the first scan test'
        global AGENTS_SCANNED_FIRST_SCAN
        if len(AGENTS_SCANNED_FIRST_SCAN) == 0:
            pytest.skip("No agent was scanned in the first scan. Skipping test.")

        target_to_ignore = list(
            set(host_manager.get_group_hosts("agent")) - set(AGENTS_SCANNED_FIRST_SCAN)
        )

        utc_now_timestamp = datetime.datetime.now(datetime.timezone.utc)
        test_timestamp = utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%S")

        test_result = TestResult(request.node.name)
        test_result.add_check(self.no_errors_check)
        test_result.add_check(self.operation_successfull_for_all_agents_check)
        test_result.add_check(self.expected_vulnerabilities_found_in_index_check)
        test_result.add_check(self.no_unexpected_vulnerabilities_found_in_index_check)
        test_result.add_check(self.expected_vulnerability_affected_alert_check)
        test_result.add_check(self.expected_vulnerability_mitigated_alert_check)
        test_result.add_check(self.setup_successfull_for_all_agents_check)
        test_result.add_check(self.no_duplicated_vulnerabilities_check)

        record_property("test_result", test_result)

        agents_failed_setup = setup
        test_result.validate_check("setup_operation_results", [Evidence("setup_failed_agents", agents_failed_setup)])

        # Install Vulnerable package
        operations_result = launch_parallel_operations(
            body, host_manager, target_to_ignore
        )

        logging.critical(f"Remote operation results: {operations_result}")
        test_result.validate_check(
            "operation_successfull_for_all_agents",
            [Evidence("operation_results", operations_result)],
        )
        # Wait for syscollector and VD scan
        time.sleep(VD_E2E_TIMEOUT_SYSCOLLECTOR_SCAN + PACKAGE_VULNERABILITY_SCAN_TIME * len(AGENTS_SCANNED_FIRST_SCAN))

        if "to" in body["package"]:
            package_data = [body["package"]["to"], body["package"]["from"]]
        else:
            package_data = [body["package"]]
        max_result_window(host_manager)

        vulnerabilities = get_vulnerabilities_index(host_manager, AGENTS_SCANNED_FIRST_SCAN, package_data,
                                                    size=INDEXER_RESULT_WINDOWS_VULN_E2E)
        expected_vulnerabilities = get_expected_index(host_manager, AGENTS_SCANNED_FIRST_SCAN,
                                                      body["operation"], body["package"])
        duplicated_vulnerabilities = get_duplicated_vulnerabilities(vulnerabilities)

        result = compare_expected_found_vulnerabilities(vulnerabilities, expected_vulnerabilities)
        vulnerabilities_not_found = result["vulnerabilities_not_found"]
        vulnerabilities_unexpected = result["vulnerabilities_unexpected"]

        test_result.validate_check('no_duplicated_vulnerabilities',
                                   [Evidence('duplicated_vulnerabilities', duplicated_vulnerabilities),
                                    Evidence('vulnerabilities', vulnerabilities)
                                    ])

        logging.critical("Validating found vulnerabilities")
        test_result.validate_check(
            "expected_vulnerabilities_found_in_index",
            [
                Evidence("missing_vulnerabilities", vulnerabilities_not_found),
                Evidence("vulnerabilities_found_in_index", vulnerabilities),
                Evidence("expected_vulnerabilities", expected_vulnerabilities),
            ],
        )

        logging.critical("Validating unexpected vulnerabilities")
        test_result.validate_check(
            "no_unexpected_vulnerabilities_found_in_index",
            [
                Evidence("unexpected_vulnerabilities", vulnerabilities_unexpected),
                Evidence("vulnerabilities_found_in_index", vulnerabilities),
                Evidence("expected_vulnerabilities", expected_vulnerabilities),
            ],
        )

        alerts = get_vulnerability_alerts(host_manager, AGENTS_SCANNED_FIRST_SCAN, package_data, test_timestamp)
        expected_alerts = get_expected_alerts(
            host_manager, AGENTS_SCANNED_FIRST_SCAN, body["operation"], body["package"]
        )

        result_alert = compare_expected_found_vulnerabilities_alerts(
            alerts, expected_alerts
        )

        logging.critical("Validating found alerts")
        test_result.validate_check(
            "expected_vulnerability_affected_alert",
            [
                Evidence(
                    "missing_affected_alerts",
                    result_alert["vulnerabilities_affected_not_found"],
                ),
                Evidence("alerts_found_in_index", alerts),
                Evidence("expected_alerts", expected_alerts),
            ],
        )

        logging.critical("Validating unexpected alerts")
        test_result.validate_check(
            "expected_vulnerability_mitigated_alert",
            [
                Evidence(
                    "missing_mitigated_alerts",
                    result_alert["vulnerabilities_mitigated_not_found"],
                ),
                Evidence("alerts_found_in_index", alerts),
                Evidence("expected_alerts", expected_alerts),
            ],
        )

        errors_environment = check_errors_in_environment(
            host_manager,
            expected_errors=VULNERABILITY_DETECTION_E2E_EXPECTED_ERRORS,
            greater_than_timestamp=test_timestamp
        )

        test_result.validate_check("no_errors", [Evidence("error_level_messages", errors_environment)])

        assert test_result.get_test_result(), test_result.report()
