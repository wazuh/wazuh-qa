# Copyright (C) 2015-2021, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is free software; you can redistribute it and/or modify it under the terms of GPLv2
import os
from datetime import datetime, timedelta
from sys import platform

import pytest

import wazuh_testing.vulnerability_detector as vd
from wazuh_testing import logger
from wazuh_testing.tools import LOG_FILE_PATH, WAZUH_PATH
from wazuh_testing.tools.configuration import load_wazuh_configurations, check_apply_test
from wazuh_testing.tools.monitoring import FileMonitor
from wazuh_testing.tools.services import control_service
from wazuh_testing.tools.time import TimeMachine

if platform == 'linux':
    from distro import linux_distribution

# Marks
pytestmark = [pytest.mark.server, pytest.mark.tier(level=0)]

local_internal_options = {
    'wazuh_modules.debug': 2,
    'monitord.rotate_log': 0
}

# variables
distro = 'centos'
DB_PATH = os.path.join(WAZUH_PATH, 'queue', 'db', f"000.db")
CVE_DB_PATH = os.path.join(WAZUH_PATH, 'queue', 'vulnerabilities', 'cve.db')
test_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
configurations_path = os.path.join(test_data_path, 'wazuh_min_full_scan_interval_rhel.yaml')
# Check linux distribution to load the proper settings.
if platform == 'linux':
    distro = linux_distribution()[0]
    if distro.lower().startswith("debian"):
        configurations_path = os.path.join(test_data_path, 'wazuh_min_full_scan_interval_debian.yaml')
    elif distro.lower().startswith("ubuntu"):
        configurations_path = os.path.join(test_data_path, 'wazuh_min_full_scan_interval_ubuntu.yaml')
wazuh_log_monitor = FileMonitor(LOG_FILE_PATH)
min_full_scan_interval_values = [10, 25]
min_full_scan_interval_units = ['m', 'h', 'd']
parameters = []
metadata = []
ids = []

# Offline feeds
RHEL5_OVAL_FEED = 'com.redhat.rhsa-RHEL5.xml.bz2'
RHEL6_OVAL_FEED = 'rhel-6-including-unpatched.oval.xml.bz2'
RHEL7_OVAL_FEED = 'rhel-7-including-unpatched.oval.xml.bz2'
RHEL8_OVAL_FEED = 'rhel-8-including-unpatched.oval.xml.bz2'
RHEL_JSON_FEED = 'redhat-feed.*json$'
FOCAL_OVAL_FEED = 'com.ubuntu.focal.cve.oval.xml.bz2'
BIONIC_OVAL_FEED = 'com.ubuntu.bionic.cve.oval.xml.bz2'
XENIAL_OVAL_FEED = 'com.ubuntu.xenial.cve.oval.xml.bz2'
TRUSTY_OVAL_FEED = 'com.ubuntu.trusty.cve.oval.xml.bz2'
BUSTER_OVAL_FEED = 'oval-definitions-buster.xml'
STRETCH_OVAL_FEED = 'oval-definitions-stretch.xml'
DEBIAN_JSON_FEED = 'security_tracker_local.json'
NVD_JSON_FEED = 'nvd-feed.*json$'
rhel5_oval_feed_path = os.path.join(test_data_path, 'feeds', 'rhel-feed', 'oval', RHEL5_OVAL_FEED)
rhel6_oval_feed_path = os.path.join(test_data_path, 'feeds', 'rhel-feed', 'oval', RHEL6_OVAL_FEED)
rhel7_oval_feed_path = os.path.join(test_data_path, 'feeds', 'rhel-feed', 'oval', RHEL7_OVAL_FEED)
rhel8_oval_feed_path = os.path.join(test_data_path, 'feeds', 'rhel-feed', 'oval', RHEL8_OVAL_FEED)
rhel_json_feed_path = os.path.join(test_data_path, 'feeds', 'rhel-feed', 'json', RHEL_JSON_FEED)
focal_oval_feed_path = os.path.join(test_data_path, 'feeds', 'canonical-feed', 'oval', FOCAL_OVAL_FEED)
bionic_oval_feed_path = os.path.join(test_data_path, 'feeds', 'canonical-feed', 'oval', BIONIC_OVAL_FEED)
xenial_oval_feed_path = os.path.join(test_data_path, 'feeds', 'canonical-feed', 'oval', XENIAL_OVAL_FEED)
trusty_oval_feed_path = os.path.join(test_data_path, 'feeds', 'canonical-feed', 'oval', TRUSTY_OVAL_FEED)
buster_oval_feed_path = os.path.join(test_data_path, 'feeds', 'debian-feed', 'oval', BUSTER_OVAL_FEED)
stretch_oval_feed_path = os.path.join(test_data_path, 'feeds', 'debian-feed', 'oval', STRETCH_OVAL_FEED)
debian_json_feed_path = os.path.join(test_data_path, 'feeds', 'debian-feed', 'json', DEBIAN_JSON_FEED)
nvd_json_feed_path = os.path.join(test_data_path, 'feeds', 'nvd-feed', 'json', NVD_JSON_FEED)

for value in min_full_scan_interval_values:
    for unit in min_full_scan_interval_units:
        if distro.lower().startswith("ubuntu"):
            parameters.append({'MIN_FULL_SCAN_INTERVAL': f'{value}{unit}',
                               'FOCAL_FEED_PATH': focal_oval_feed_path,
                               'BIONIC_FEED_PATH': bionic_oval_feed_path,
                               'XENIAL_FEED_PATH': xenial_oval_feed_path,
                               'TRUSTY_FEED_PATH': trusty_oval_feed_path,
                               'NVD_JSON_FEED_PATH': nvd_json_feed_path})
        elif distro.lower().startswith("debian"):
            parameters.append({'MIN_FULL_SCAN_INTERVAL': f'{value}{unit}',
                               'BUSTER_FEED_PATH': buster_oval_feed_path,
                               'STRETCH_FEED_PATH': stretch_oval_feed_path,
                               'DEBIAN_JSON_FEED_PATH': debian_json_feed_path,
                               'NVD_JSON_FEED_PATH': nvd_json_feed_path})
        else:
            parameters.append({'MIN_FULL_SCAN_INTERVAL': f'{value}{unit}',
                               'RHEL5_FEED_PATH': rhel5_oval_feed_path,
                               'RHEL6_FEED_PATH': rhel6_oval_feed_path,
                               'RHEL7_FEED_PATH': rhel7_oval_feed_path,
                               'RHEL8_FEED_PATH': rhel8_oval_feed_path,
                               'RHEL_JSON_FEED_PATH': rhel_json_feed_path,
                               'NVD_JSON_FEED_PATH': nvd_json_feed_path})
        metadata.append({'min_full_scan_interval': f'{value}{unit}'})
        ids.append(f'{value}{unit}')

# Configuration data
configurations = load_wazuh_configurations(configurations_path, __name__, params=parameters, metadata=metadata)

# Callbacks
callback_detect_full_scan_start = vd.make_vuln_callback('A full scan will be run on agent')
callback_detect_nvd_updated = vd.make_vuln_callback(
    "The update of the 'National Vulnerability Database' feed finished successfully.")
callback_detect_scan_finished = vd.make_vuln_callback("Vulnerability scan finished.")


# fixtures
@pytest.fixture(scope='module', params=configurations, ids=ids)
def get_configuration(request):
    """Get configurations from the module."""
    return request.param


@pytest.fixture(scope="module")
def get_local_internal_options():
    """Get configurations from the module."""
    return local_internal_options


def test_min_full_scan_interval(configure_local_internal_options, get_configuration, configure_environment,
                                restart_modulesd):
    """Check if modulesd waits the minimal time set in "min_full_scan_interval"
    to perform FULL_SCAN type scanning of vulnerability detector.

    To do so, it modifies the date of the last total scan in the manager's database to an earlier date.
    Then the system date is changed to a time after the date of the full scan, but before the minimum period
    set in min_full_scan_interval, so that the full scan should not be triggered. Finally, the date
    is changed back to a time when the time set in min_full_scan_interval has expired,
    at which point the full scan should be triggered.

    Args:
        configure_local_internal_options (fixture): Set internal configuration for testing.
        get_configuration (fixture): Get configurations from the module.
        configure_environment (fixture): Configure a custom environment for testing.
        restart_modulesd (fixture): Reset ossec.log and start a new monitor.
    """
    check_apply_test({'min_full_scan_interval'}, get_configuration['tags'])

    config = get_configuration['metadata']
    time_modifier = vd.interval_to_time_modifier(config['min_full_scan_interval'])

    # Stop the Wazuh to be able to query the database.
    control_service('stop')

    # Set the last total scan of the manager to the current date minus the interval time,
    # so that the time set in the interval has already expired.
    query_string = f"UPDATE vuln_metadata SET LAST_FULL_SCAN=strftime('%s','now', '-{time_modifier}');"
    vd.make_query(DB_PATH, [query_string])

    last_full_scan = int(vd.get_query_result(DB_PATH, "SELECT LAST_FULL_SCAN FROM vuln_metadata;")[0])
    seconds_to_travel = int((datetime.now().timestamp() - last_full_scan) / 2)

    # Travel back in time, halfway through the period set in "min_full_scan_interval".
    before = str(datetime.now())
    TimeMachine.travel_to_future(timedelta(seconds=-seconds_to_travel))
    logger.debug(f"Changing the system clock from {before} to {datetime.now()}")

    control_service('start')

    # Detect the NVD feed update, after this should launch (if applicable) the full scan.
    wazuh_log_monitor.start(timeout=vd.VULN_DETECTOR_FEED_OFFLINE_UPDATE_TIMEOUT,
                            callback=callback_detect_nvd_updated,
                            error_message='No NVD update detected in log.')

    # At this point, the conditions for launching a full scan are met,
    # except for the minimum interval which has not expired.
    # Therefore the full scan should not be triggered..
    with pytest.raises(TimeoutError):
        wazuh_log_monitor.start(timeout=vd.VULN_DETECTOR_FULL_SCAN_TIMEOUT,
                                callback=callback_detect_full_scan_start,
                                error_message='No full scan start detected in log.')

    # Return to the current time, at the moment when the minimum interval
    # for the full scan expires. Thus, the full scan should be launched.
    before = str(datetime.now())
    TimeMachine.travel_to_future(timedelta(seconds=seconds_to_travel))
    logger.debug(f"Changing the system clock from {before} to {datetime.now()}")

    control_service('restart')

    # Detect the NVD feed update, after this should launch (if applicable) the full scan.
    wazuh_log_monitor.start(timeout=vd.VULN_DETECTOR_FEED_OFFLINE_UPDATE_TIMEOUT,
                            callback=callback_detect_nvd_updated,
                            error_message='No NVD update detected in log.')

    wazuh_log_monitor.start(timeout=vd.VULN_DETECTOR_FULL_SCAN_TIMEOUT,
                            callback=callback_detect_full_scan_start,
                            error_message='No full scan start detected in log.')
