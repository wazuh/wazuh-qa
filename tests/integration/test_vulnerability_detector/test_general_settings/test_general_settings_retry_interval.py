# Copyright (C) 2015-2021, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is free software; you can redistribute it and/or modify it under the terms of GPLv2
import os
import time
import re
import math
import pytest
import wazuh_testing.vulnerability_detector as vd

from datetime import datetime
from wazuh_testing.tools import LOG_FILE_PATH
from wazuh_testing.tools.configuration import load_wazuh_configurations, check_apply_test
from wazuh_testing.tools.monitoring import FileMonitor
from wazuh_testing.tools.time import time_to_seconds

# Marks
pytestmark = [pytest.mark.server, pytest.mark.tier(level=0)]

local_internal_options = {
    'wazuh_modules.debug': 2,
    'monitord.rotate_log': 0
}

# variables
test_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
test_feed_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', 'data', 'feeds')
configurations_path = os.path.join(test_data_path, 'wazuh_retry_interval.yaml')
wazuh_log_monitor = FileMonitor(LOG_FILE_PATH)
retry_interval_values = [20, 30, 40]
retry_interval_units = ['s']
parameters = []
metadata = []
ids = []

# Offline feeds
buster_oval_feed_path = os.path.join(test_feed_path, vd.CUSTOM_DEBIAN_OVAL_FEED)
debian_json_feed_path = os.path.join(test_feed_path, vd.CUSTOM_DEBIAN_JSON_FEED)
nvd_json_feed_path = os.path.join(test_feed_path, vd.CUSTOM_NVD_FEED)

for value in retry_interval_values:
    for unit in retry_interval_units:
        parameters.append({'RETRY_INTERVAL': f'{value}{unit}',
                           'BUSTER_FEED_PATH': buster_oval_feed_path,
                           'DEBIAN_JSON_FEED_PATH': debian_json_feed_path,
                           'NVD_JSON_FEED_PATH': nvd_json_feed_path})
        metadata.append({'retry_interval': f'{value}{unit}'})
        ids.append(f'{value}{unit}')

# Configuration data
configurations = load_wazuh_configurations(configurations_path, __name__, params=parameters, metadata=metadata)


def pytest_namespace():
    return {'first_scan_fail_time': None,
            'scan_success_time': None}

# fixtures
@pytest.fixture(scope='module', params=configurations)
def get_configuration(request):
    """Get configurations from the module."""
    return request.param


@pytest.fixture(scope="module")
def get_local_internal_options():
    """Get configurations from the module."""
    return local_internal_options


@pytest.fixture(scope="module")
def add_simulated_agent(get_configuration):
    """Add a simulated agent to the system with basic functionality.

    For this purpose, it adds a dummy agent, inserts in its database (sys_programs table) a test package,
    and configures its database to appear to be up to date (sync_info table).
    """
    agent_id, sender, injector = vd.create_simulated_agent()
    vd.insert_package(agent=agent_id, name='wazuhintegrationpackage-0', vendor='WazuhIntegrationTests',
                      version='1.0.0', source='NULL')
    yield agent_id
    injector.stop_receive()
    vd.delete_simulated_agent(agent_id)


def test_retry_interval_skip_agent(configure_local_internal_options, get_configuration, configure_environment,
                                   restart_modulesd, add_simulated_agent):
    """Check if the Vulnerability Detector module skips an agent due to sys_collector database unsynced.

    For this purpose, the manager is configured to use custom feeds that include a vulnerability associated
    with a test package. This package is added to the database of the simulated agent and, after enrollment
    of the agent, the vulnerability detector must attempt to launch the first scan on it.

    As the sys_collector database is not synchronized (last_completion attribute in sync_info table does not match
    with the last_attemp attribute) the scan on the agent is skipped.

    Args:
        configure_local_internal_options (fixture): Set internal configuration for testing.
        get_configuration (fixture): Get configurations from the module.
        configure_environment (fixture): Configure a custom environment for testing.
        restart_modulesd (fixture): Reset ossec.log and start a new monitor.
        add_simulated_agent (fixture): Add a simulated agent to the manager for testing.
    """
    check_apply_test({'retry_interval'}, get_configuration['tags'])
    agent_id = add_simulated_agent

    # Callbacks
    callback_detect_collecting_software = vd.make_vuln_callback(pattern=f"Collecting agent '{agent_id}' software.",
                                                                prefix='.*')
    log_line = "Going to sleep \\d+ seconds before retrying pending agents"
    callback_detect_skip_agent_log = vd.make_vuln_callback(pattern=log_line,
                                                           prefix='.*')

    # Detect collection software log.
    wazuh_log_monitor.start(timeout=vd.VULN_DETECTOR_SCAN_TIMEOUT,
                            callback=callback_detect_collecting_software,
                            error_message='No collecting software detected in log.')

    # Detect agent skipped log.
    wazuh_log_monitor.start(timeout=vd.VULN_DETECTOR_SCAN_TIMEOUT,
                            callback=callback_detect_skip_agent_log,
                            error_message='No skip agent log detected.')

    pattern = "(\\d{4}/\\d{2}/\\d{2}\\s\\d{2}:\\d{2}:\\d{2}).*" + log_line + ""
    file = open(LOG_FILE_PATH, "r")
    lines = file.readlines()
    for line in lines:
        exist = re.search(pattern, line)
        if exist:
            pytest.first_scan_fail_time = datetime.strptime(exist.group(1), '%Y/%m/%d %H:%M:%S')
    file.close()


def test_retry_interval_scan_agent(configure_local_internal_options, get_configuration, configure_environment,
                                   restart_modulesd, add_simulated_agent):
    """Check if the Vulnerability Detector module performs the analysis of vulnerabilities correctly.

    For this purpose, the manager is configured to use custom feeds that include a vulnerability associated
    with a test package. This package is added to the database of the simulated agent and, after enrollment
    of the agent, the vulnerability detector must attempt to launch the first scan on it.

    As the sys_collector database is synchronized (last_completion attribute in sync_info table match
    with the last_attemp attribute) the scan on the agent is performed.

    Args:
        configure_local_internal_options (fixture): Set internal configuration for testing.
        get_configuration (fixture): Get configurations from the module.
        configure_environment (fixture): Configure a custom environment for testing.
        restart_modulesd (fixture): Reset ossec.log and start a new monitor.
        add_simulated_agent (fixture): Add a simulated agent to the manager for testing.
    """
    check_apply_test({'retry_interval'}, get_configuration['tags'])
    agent_id = add_simulated_agent

    # Force sys_collector database synchronization.
    vd.update_sync_info(agent=agent_id)

    # Callbacks
    callback_detect_collecting_software = vd.make_vuln_callback(pattern=f"Collecting agent '{agent_id}' software.",
                                                                prefix='.*')
    retry_interval = time_to_seconds(get_configuration['metadata']['retry_interval'])
    log_line = f"Analyzing OVAL vulnerabilities for agent '{agent_id}'"
    callback_detect_scan_agent_log = vd.make_vuln_callback(pattern=log_line,
                                                           prefix='.*')

    # Detect collection software log.
    wazuh_log_monitor.start(timeout=vd.VULN_DETECTOR_SCAN_TIMEOUT,
                            callback=callback_detect_collecting_software,
                            error_message='No collecting software detected in log.')

    # Detect vulnerabilities analysis log on agent.
    wazuh_log_monitor.start(timeout=vd.VULN_DETECTOR_SCAN_TIMEOUT,
                            callback=callback_detect_scan_agent_log,
                            error_message='No vulnerabilities analysis detected in log.')

    pattern = "(\\d{4}/\\d{2}/\\d{2}\\s\\d{2}:\\d{2}:\\d{2}).*" + log_line + ""
    file = open(LOG_FILE_PATH, "r")
    lines = file.readlines()
    for line in lines:
        exist = re.search(pattern, line)
        if exist:
            pytest.scan_success_time = datetime.strptime(exist.group(1), '%Y/%m/%d %H:%M:%S')
    file.close()

    time_between_scan_retries = (pytest.scan_success_time - pytest.first_scan_fail_time).total_seconds()

    assert math.trunc(time_between_scan_retries) >= retry_interval
