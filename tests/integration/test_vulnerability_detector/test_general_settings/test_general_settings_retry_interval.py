'''
copyright: Copyright (C) 2015-2021, Wazuh Inc.

           Created by Wazuh, Inc. <info@wazuh.com>.

           This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

type: integration

brief: These tests will check if the `retry_interval` option of the Vulnerability Detector module
       is working correctly. This option is located in its corresponding section of the `ossec.conf` file
       and allows to define the time to wait to re-scan an agent that wasn't able to be scanned the first time.

tier: 0

modules:
    - vulnerability_detector

components:
    - manager

daemons:
    - wazuh-modulesd

os_platform:
    - linux

os_version:
    - Arch Linux
    - Amazon Linux 2
    - Amazon Linux 1
    - CentOS 8
    - CentOS 7
    - CentOS 6
    - Ubuntu Focal
    - Ubuntu Bionic
    - Ubuntu Xenial
    - Ubuntu Trusty
    - Debian Buster
    - Debian Stretch
    - Debian Jessie
    - Debian Wheezy
    - Red Hat 8
    - Red Hat 7
    - Red Hat 6

references:
    - https://documentation.wazuh.com/current/user-manual/capabilities/vulnerability-detection/index.html
    - https://documentation.wazuh.com/current/user-manual/reference/ossec-conf/vuln-detector.html#retry_interval

tags:
    - settings
'''
import os
import time
import re
import math
import pytest
import wazuh_testing.vulnerability_detector as vd

from datetime import datetime
from wazuh_testing.tools import LOG_FILE_PATH
from wazuh_testing.tools.configuration import load_wazuh_configurations, check_apply_test
from wazuh_testing.tools.monitoring import FileMonitor
from wazuh_testing.tools.time import time_to_seconds

# Marks
pytestmark = [pytest.mark.server, pytest.mark.tier(level=0)]

# variables
test_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
test_feed_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', 'data', 'feeds')
configurations_path = os.path.join(test_data_path, 'wazuh_retry_interval.yaml')
wazuh_log_monitor = FileMonitor(LOG_FILE_PATH)
retry_interval_values = [25, 30, 35]
retry_interval_units = ['s']
parameters = []
metadata = []
ids = []

# Offline feeds
rhel_oval_feed_path = os.path.join(test_feed_path, vd.CUSTOM_REDHAT_OVAL_FEED)
rhel_json_feed_path = os.path.join(test_feed_path, vd.CUSTOM_REDHAT_JSON_FEED)
nvd_json_feed_path = os.path.join(test_feed_path, vd.CUSTOM_NVD_FEED)

for value in retry_interval_values:
    for unit in retry_interval_units:
        parameters.append({'RETRY_INTERVAL': f"{value}{unit}",
                           'RHEL_FEED_PATH': rhel_oval_feed_path,
                           'RHEL_JSON_FEED_PATH': rhel_json_feed_path,
                           'NVD_JSON_FEED_PATH': nvd_json_feed_path})
        metadata.append({'retry_interval': f"{value}{unit}"})
        ids.append(f"{value}{unit}")

# Configuration data
configurations = load_wazuh_configurations(configurations_path, __name__, params=parameters, metadata=metadata)

# fixtures
@pytest.fixture(scope='module', params=configurations, ids=ids)
def get_configuration(request):
    """Get configurations from the module."""
    return request.param


@pytest.fixture(scope='function')
def mock_system(mock_agent):
    """
    It mocks an agent with syscollector packages in a not synced state.
    """
    vd.insert_osinfo(agent=mock_agent)

    # Force not synced state for syscollector packages
    vd.update_sync_info(agent=mock_agent, last_attempt=0, last_completion=0)

    yield mock_agent

    vd.clean_vd_tables(mock_agent)


def test_retry_interval(get_configuration, configure_environment, restart_modulesd, mock_system):
    '''
    description: Checks if the `retry_interval ` option is working correctly. To do this,
                 it checks the `ossec.log` file for the message indicating that Vulnerability Detector will sleep before
                 attempting to scan the pending agents. After that, waits for the log saying that the agent will be
                 scanned again. And the time between both events is compared.
    wazuh_min_version: 4.3

    parameters:
        - configure_environment:
            type: fixture
            brief: Configure a custom environment for testing.
        - get_configuration:
            type: fixture
            brief: Get configurations from the module.
        - restart_modulesd:
            type: callable
            brief: Restart the `wazuh-modulesd` daemon.
        - mock_system:
            type: callable
            brief: Add a simulated agent to the manager for testing.

    assertions:
        - Verify that the retry to scan a failing agent is delayed until the time configured is up.

    input_description: The combination of retry_interval_values and retry_interval_units is used.

    expected_output:
        - 'Going to sleep \\d+ seconds before retrying pending agents'
        - f"Analyzing OVAL vulnerabilities for agent '{agent_id}'"
    '''
    check_apply_test({'retry_interval'}, get_configuration['tags'])
    agent_id = mock_system
    retry_interval = time_to_seconds(get_configuration['metadata']['retry_interval'])

    def get_timestamp(log_line):
        callback_log_line = vd.make_vuln_callback(pattern=log_line, prefix='.*')
        wazuh_log_monitor.start(timeout=vd.VULN_DETECTOR_SCAN_TIMEOUT,
                                callback=callback_log_line,
                                error_message='Log line not found.')

        regex = f"(\\d{{4}}/\\d{{2}}/\\d{{2}}\\s\\d{{2}}:\\d{{2}}:\\d{{2}}).*{log_line}"
        with open(LOG_FILE_PATH) as file:
            lines = file.readlines()
            for line in lines:
                exist = re.search(regex, line)
                if exist:
                    return datetime.strptime(exist.group(1), '%Y/%m/%d %H:%M:%S')

    first_scan_fail_time = get_timestamp('Going to sleep \\d+ seconds before retrying pending agents')

    # Force syscollector database synchronization.
    vd.update_sync_info(agent=agent_id)

    scan_success_time = get_timestamp(f"Analyzing OVAL vulnerabilities for agent '{agent_id}'")

    time_between_scan_retries = (scan_success_time - first_scan_fail_time).total_seconds()

    assert math.trunc(time_between_scan_retries) >= retry_interval
