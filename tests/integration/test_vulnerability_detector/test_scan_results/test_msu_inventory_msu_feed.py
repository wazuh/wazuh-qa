# Copyright (C) 2015-2021, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

import os
import pytest

import wazuh_testing.vulnerability_detector as vd
from wazuh_testing.tools import LOG_FILE_PATH, ALERT_FILE_PATH
from wazuh_testing.tools.configuration import load_wazuh_configurations
from wazuh_testing.tools.monitoring import FileMonitor
from wazuh_testing.tools import file

# Marks
pytestmark = [pytest.mark.server, pytest.mark.tier(level=1)]

# Variables
current_test_path = os.path.dirname(os.path.realpath(__file__))
test_data_path = os.path.join(current_test_path, 'data')
custom_msu_json_path = os.path.join(test_data_path, 'feeds', 'custom_msu.json')
configurations_path = os.path.join(test_data_path, 'configuration', 'wazuh_msu_inventory.yaml')

wazuh_log_monitor = FileMonitor(LOG_FILE_PATH)
wazuh_alert_monitor = FileMonitor(ALERT_FILE_PATH)

# Set configuration
parameters = [{'NVD_JSON_PATH': os.path.join(test_data_path, 'feeds', vd.CUSTOM_NVD_FEED),
               'MSU_JSON_PATH': custom_msu_json_path}]
ids = ['msu_scan_configuration']

# read vulnerabilities
vulnerabilities = file.read_json(custom_msu_json_path)

# Configuration data
configurations = load_wazuh_configurations(configurations_path, __name__, params=parameters)

system_data = [
    {"target": "WINDOWS10", "os_name": "Microsoft Windows 10", "os_major": "10", "os_release": "1809",
     "os_minor": "0", "name": "windows", "hotfixes": ["4540670", "KB4550947"], "arch": "x64"},
    # Scenario: Two supersedences, and no original patch.
    {"target": "WINDOWS_SERVER_2016", "os_name": "Microsoft Windows Server 2016", "os_major": "10",
     "os_release": "1607",
     "os_minor": "0", "name": "windows", "hotfixes": ["4534271", "4556813"], "arch": "*"},
    # Scenario: Original patch + supersedence.
    {"target": "WINDOWS_SERVER_2019", "os_name": "Microsoft Windows Server 2019", "os_major": "10",
     "os_release": "1809", "arch": "x86",
     "os_minor": "0", "name": "windows", "hotfixes": ["4534275"]},
    # Scenario: Original patch of a recently released CVE. (only supersedence)
]

system_data_ids = [system['target'] for system in system_data]
MODULESD_PREFIX = r'.*wazuh-modulesd.*'


@pytest.fixture(scope='module', params=configurations, ids=ids)
def get_configuration(request):
    """Get configurations from the module."""
    return request.param


@pytest.fixture(scope='module', params=system_data, ids=system_data_ids)
@vd.mock_cve_db
def mock_vulnerability_scan(request, mock_agent):
    """Mocks the vulnerability scan inserting custom hotfixes, feeds and changing the host system

    Args:
        request (dict): dictionary containing the data to mock the system and the agent
        mock_agent (callable): fixture used to mock the agent
    """
    # Modify the necessary databases. The arch follows a special format rather than the usual x64.
    vd.modify_system(agent_id=mock_agent, os_name=request.param['os_name'], os_major=request.param['os_major'],
                     os_minor=request.param['os_minor'], name=vd.MOCKED_AGENT_NAME, os_arch=request.param['arch'])

    os_version = f"{request.param['os_major']}.{request.param['os_minor']}.{request.param['os_release']}"
    vd.insert_osinfo(agent=mock_agent, os_name=request.param['os_name'], os_release=request.param['os_release'],
                     os_version=os_version, architecture=request.param['arch'])

    for patch in request.param["hotfixes"]:
        vd.insert_hotfix(agent=mock_agent, hotfix=patch)

    # Update sync status for both packages and hotfixes
    vd.update_sync_info(agent=mock_agent, component="syscollector-packages")
    vd.update_sync_info(agent=mock_agent, component="syscollector-hotfixes")

    # Clean the vulnerabilities inventory from the agent database
    vd.clean_vulnerabilities_inventory(agent=mock_agent)

    # Forcing a full-scan
    vd.update_last_full_scan(1, mock_agent)


def get_os_short_name(name):
    return name.replace('Microsoft ', '')


def is_hotfix_installed(cve_patch, dependencies, hotfixes):
    """
    Check if the given CVE's hotfix (or at least one of its supersedences) is installed.

    Parameters
    ----------
    cve_patch: str
        Patch that fixes the CVE being analyzed.
    dependencies: str
        The complete list of dependencies in the MSU.
    hotfixes: str
        The patches installed in the agent.
    """

    if cve_patch in hotfixes:
        return True, cve_patch

    else:
        # Check if any of the supersedences are installed
        for base, supersedence in dependencies.items():
            if cve_patch == base:
                for super_patch in supersedence:
                    if super_patch in hotfixes:
                        return True, super_patch

        return False, cve_patch


@pytest.mark.skip(reason="It will be blocked by #1602, when it was solve we can enable again this test")
def test_vulnerabilities_report(get_configuration, configure_environment, restart_modulesd, check_cve_db, mock_agent,
                                mock_vulnerability_scan):
    """
    Check if a missing patch triggers a vulnerability(only windows).
    """
    hotfixes = mock_vulnerability_scan['hotfixes']
    dep = vulnerabilities['dependencies']
    os_major = mock_vulnerability_scan['os_major']
    os_minor = mock_vulnerability_scan['os_minor']
    os_release = mock_vulnerability_scan['os_release']
    os_version = f"{os_major}.{os_minor}.{os_release}"

    # Check the vulnerabilities of installed and not installed hotfixes
    for cve, item in vulnerabilities['vulnerabilities'].items():
        installed, hotfix = is_hotfix_installed(item[0]['patch'], dep, hotfixes)
        if installed:
            wazuh_log_monitor.start(
                timeout=vd.VULN_DETECTOR_EXTENDED_GLOBAL_TIMEOUT,
                update_position=False,
                callback=vd.make_vuln_callback(
                    f"Agent '{mock_agent}' has installed '{hotfix}' that corrects the vulnerability '{cve}'"
                ),
                error_message=f"Could not find the report which says that the patch {hotfix} solves {cve}"
            )
        else:
            wazuh_log_monitor.start(
                timeout=vd.VULN_DETECTOR_EXTENDED_GLOBAL_TIMEOUT,
                update_position=False,
                callback=vd.make_vuln_callback(
                    f"Agent '{mock_agent}' is vulnerable to '{cve}'. Condition: 'KB{hotfix} patch is not installed'"
                ),
                error_message=f"Could not find the report which says that the system" +
                              f" is vulnerable to {cve} due to missing {hotfix}"
            )
            wazuh_alert_monitor.start(
                timeout=vd.VULN_DETECTOR_SCAN_TIMEOUT,
                update_position=False,
                callback=vd.make_vuln_callback(
                    f"KB{hotfix} patch is not installed",
                    prefix='.*'
                ),
                error_message=f"Could not find the report which says that the system" +
                              f" is vulnerable to {cve} due to missing {hotfix}"
            )
            vd.check_vulnerability_scan_inventory(agent=mock_agent,
                                                  package=get_os_short_name(mock_vulnerability_scan['os_name']),
                                                  arch=mock_vulnerability_scan['arch'],
                                                  version=os_version,
                                                  cve=cve,
                                                  condition='inserted')

    # Install the missing hotfixes
    for cve, item in vulnerabilities['vulnerabilities'].items():
        installed, hotfix = is_hotfix_installed(item[0]['patch'], dep, hotfixes)
        if not installed:
            vd.insert_hotfix(agent=mock_agent, hotfix=hotfix)

    # Check the removed vulnerabilities report of installed hotfixes
    for cve, item in vulnerabilities['vulnerabilities'].items():
        installed, hotfix = is_hotfix_installed(item[0]['patch'], dep, hotfixes)
        if not installed:
            vd.check_vulnerability_scan_remove_log(wazuh_log_monitor,
                                                   get_os_short_name(mock_vulnerability_scan['os_name']),
                                                   cve)
            vd.check_vulnerability_scan_remove_alerts(wazuh_alert_monitor,
                                                      get_os_short_name(mock_vulnerability_scan['os_name']),
                                                      cve)
            vd.check_vulnerability_scan_inventory(agent=mock_agent,
                                                  package=get_os_short_name(mock_vulnerability_scan['os_name']),
                                                  arch=mock_vulnerability_scan['arch'],
                                                  version=os_version,
                                                  cve=cve,
                                                  condition='removed')

    vd.check_if_modulesd_is_running()
