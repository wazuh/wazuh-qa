'''
copyright: Copyright (C) 2015-2021, Wazuh Inc.

           Created by Wazuh, Inc. <info@wazuh.com>.

           This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

type: integration

brief: Wazuh is able to detect vulnerabilities in the applications installed in agents using the Vulnerability Detector
       module. This software audit is performed through the integration of vulnerability feeds indexed by Redhat,
       Canonical, Debian, Amazon Linux and NVD Database.

tier: 1

modules:
    - vulnerability_detector

components:
    - manager

daemons:
    - wazuh-modulesd
    - wazuh-db
    - wazuh-analysisd

os_platform:
    - linux

os_version:
    - Arch Linux
    - Amazon Linux 2
    - Amazon Linux 1
    - CentOS 8
    - CentOS 7
    - CentOS 6
    - Ubuntu Focal
    - Ubuntu Bionic
    - Ubuntu Xenial
    - Ubuntu Trusty
    - Debian Buster
    - Debian Stretch
    - Debian Jessie
    - Debian Wheezy
    - Red Hat 8
    - Red Hat 7
    - Red Hat 6

references:
    - https://documentation.wazuh.com/current/user-manual/capabilities/vulnerability-detection/index.html

tags:
    - settings
    - vulnerability
    - vulnerability_detector
    - scan_results
'''
import os
import pytest

from wazuh_testing.modules import vulnerability_detector as vd
from wazuh_testing.tools import LOG_FILE_PATH, ALERT_FILE_PATH
from wazuh_testing.tools.configuration import load_wazuh_configurations
from wazuh_testing.tools.monitoring import FileMonitor
from wazuh_testing.tools import file

# Marks
pytestmark = [pytest.mark.server, pytest.mark.tier(level=1)]

# Variables
current_test_path = os.path.dirname(os.path.realpath(__file__))
test_data_path = os.path.join(current_test_path, 'data')
custom_msu_json_path = os.path.join(test_data_path, 'feeds', 'custom_msu.json')
configurations_path = os.path.join(test_data_path, 'configuration', 'wazuh_msu_inventory.yaml')
nvd_vulnerabilities_data_path = os.path.join(test_data_path, 'feeds', vd.CUSTOM_NVD_FEED)

wazuh_log_monitor = FileMonitor(LOG_FILE_PATH)
wazuh_alert_monitor = FileMonitor(ALERT_FILE_PATH)

# Set configuration
parameters = [{'NVD_JSON_PATH': os.path.join(test_data_path, 'feeds', vd.CUSTOM_NVD_FEED),
               'MSU_JSON_PATH': custom_msu_json_path}]
ids = ['msu_scan_configuration']

# read vulnerabilities
vulnerabilities = file.read_json(custom_msu_json_path)
nvd_vulnerabilities = file.read_json_file(nvd_vulnerabilities_data_path)

# Configuration data
configurations = load_wazuh_configurations(configurations_path, __name__, params=parameters)

system_data = [
    {"target": "WINDOWS10", "os_name": "Microsoft Windows 10", "os_major": "10", "os_release": "1809",
     "os_minor": "0", "name": "windows", "hotfixes": ["4540670", "KB4550947"], "arch": "x64"},
    # Scenario: Two supersedences, and no original patch.
    {"target": "WINDOWS_SERVER_2016", "os_name": "Microsoft Windows Server 2016", "os_major": "10",
     "os_release": "1607",
     "os_minor": "0", "name": "windows", "hotfixes": ["4534271", "4556813"], "arch": "*"},
    # Scenario: Original patch + supersedence.
    {"target": "WINDOWS_SERVER_2019", "os_name": "Microsoft Windows Server 2019", "os_major": "10",
     "os_release": "1809", "arch": "x86",
     "os_minor": "0", "name": "windows", "hotfixes": ["4534275"]},
    # Scenario: Original patch of a recently released CVE. (only supersedence)
]

system_data_ids = [system['target'] for system in system_data]
MODULESD_PREFIX = r'.*wazuh-modulesd.*'


@pytest.fixture(scope='module', params=configurations, ids=ids)
def get_configuration(request):
    """Get configurations from the module."""
    return request.param


@pytest.fixture(scope='module', params=system_data, ids=system_data_ids)

def mock_vulnerability_scan(request, mock_agent):
    """Mocks the vulnerability scan inserting custom hotfixes, feeds and changing the host system

    Args:
        request (dict): dictionary containing the data to mock the system and the agent
        mock_agent (callable): fixture used to mock the agent
    """
    # Modify the necessary databases. The arch follows a special format rather than the usual x64.
    vd.modify_system(agent_id=mock_agent, os_name=request.param['os_name'], os_major=request.param['os_major'],
                     os_minor=request.param['os_minor'], name=vd.MOCKED_AGENT_NAME, os_arch=request.param['arch'])

    os_version = f"{request.param['os_major']}.{request.param['os_minor']}.{request.param['os_release']}"
    vd.insert_osinfo(agent=mock_agent, os_name=request.param['os_name'], os_release=request.param['os_release'],
                     os_version=os_version, architecture=request.param['arch'])

    for patch in request.param["hotfixes"]:
        vd.insert_hotfix(agent=mock_agent, hotfix=patch)

    # Update sync status for both packages and hotfixes
    vd.update_sync_info(agent=mock_agent, component="syscollector-packages")
    vd.update_sync_info(agent=mock_agent, component="syscollector-hotfixes")

    # Clean the vulnerabilities inventory from the agent database
    vd.clean_vulnerabilities_inventory(agent=mock_agent)

    # Forcing a full-scan
    vd.update_last_full_scan(1, mock_agent)


def get_os_short_name(name):
    return name.replace('Microsoft ', '')


def is_hotfix_installed(cve_patch, dependencies, hotfixes):
    """
    Check if the given CVE's hotfix (or at least one of its supersedences) is installed.

    Args:
        cve_patch (str): Patch that fixes the CVE being analyzed.
        dependencies (str): The complete list of dependencies in the MSU.
        hotfixes (str): The patches installed in the agent.
    """

    if cve_patch in hotfixes:
        return True, cve_patch

    else:
        # Check if any of the supersedences are installed
        for base, supersedence in dependencies.items():
            if cve_patch == base:
                for super_patch in supersedence:
                    if super_patch in hotfixes:
                        return True, super_patch

        return False, cve_patch


@pytest.mark.skip(reason="It will be blocked by #1602, when it was solve we can enable again this test")
def test_vulnerabilities_report(get_configuration, configure_environment, restart_modulesd, check_cve_db, mock_agent,
                                mock_vulnerability_scan):
    '''
    description: Check if a missing patch triggers a vulnerability(only windows). To do this, it checks that the given
                 CVE's hotfix is installed and the report of the corresponding vulnerabilities are generated in the logs
                 file.

    wazuh_min_version: 4.2.0

    parameters:
        - get_configuration:
            type: fixture
            brief: Get configurations from the module.
        - configure_environment:
            type: fixture
            brief: Configure a custom environment for testing.
        - restart_modulesd:
            type: fixture
            brief: Reset the logs file and start a new monitor.
        - check_cve_db:
            type: fixture
            brief: Check if the CVE database exists and its tables are created.
        - mock_agent:
            type: callable
            brief: It allows to mock an agent.
        - mock_vulnerability_scan:
            type: fixture
            brief: It allows to mock the vulnerability scan inserting custom packages, feeds and changing the host.
                   system.

    assertions:
        - Verify that the given CVE's hotfix is installed.
        - Verify that the modulesd daemon is running.

    input_description:
        - Test cases are found in the test module. The `wazuh_msu_inventory.yaml` file provides the configuration of
          this module for this test. Feeds are got from custom_msu.json file.

    expected_output:
        - r'Agent .* has installed .* that corrects the vulnerability .*'
        - r'Agent .* is vulnerable to .*. Condition `KB.* patch is not installed`'
    '''
    hotfixes = mock_vulnerability_scan['hotfixes']
    dep = vulnerabilities['dependencies']
    os_major = mock_vulnerability_scan['os_major']
    os_minor = mock_vulnerability_scan['os_minor']
    os_release = mock_vulnerability_scan['os_release']
    os_version = f"{os_major}.{os_minor}.{os_release}"

    # Check the vulnerabilities of installed and not installed hotfixes
    for cve, item in vulnerabilities['vulnerabilities'].items():
        installed, hotfix = is_hotfix_installed(item[0]['patch'], dep, hotfixes)
        if installed:
            wazuh_log_monitor.start(
                timeout=vd.VULN_DETECTOR_EXTENDED_GLOBAL_TIMEOUT,
                update_position=False,
                callback=vd.make_vuln_callback(
                    f"Agent '{mock_agent}' has installed '{hotfix}' that corrects the vulnerability '{cve}'"
                ),
                error_message=f"Could not find the report which says that the patch {hotfix} solves {cve}"
            )
        else:
            wazuh_log_monitor.start(
                timeout=vd.VULN_DETECTOR_EXTENDED_GLOBAL_TIMEOUT,
                update_position=False,
                callback=vd.make_vuln_callback(
                    f"Agent '{mock_agent}' is vulnerable to '{cve}'. Condition: 'KB{hotfix} patch is not installed'"
                ),
                error_message=f"Could not find the report which says that the system" +
                              f" is vulnerable to {cve} due to missing {hotfix}"
            )
            wazuh_alert_monitor.start(
                timeout=vd.VULN_DETECTOR_SCAN_TIMEOUT,
                update_position=False,
                callback=vd.make_vuln_callback(
                    f"KB{hotfix} patch is not installed",
                    prefix='.*'
                ),
                error_message=f"Could not find the report which says that the system" +
                              f" is vulnerable to {cve} due to missing {hotfix}"
            )
            severity, cvss2_score, cvss3_score = vd.find_cve_severity_score(cve_array=nvd_vulnerabilities['CVE_Items'],
                                                                            cve_id=cve)
            vd.check_vulnerability_scan_inventory(agent=mock_agent,
                                                  package=get_os_short_name(mock_vulnerability_scan['os_name']),
                                                  arch=mock_vulnerability_scan['arch'],
                                                  version=os_version,
                                                  cve=cve,
                                                  condition='inserted',
                                                  severity=severity,
                                                  cvss2=cvss2_score,
                                                  cvss3=cvss3_score)

    # Install the missing hotfixes
    for cve, item in vulnerabilities['vulnerabilities'].items():
        installed, hotfix = is_hotfix_installed(item[0]['patch'], dep, hotfixes)
        if not installed:
            vd.insert_hotfix(agent=mock_agent, hotfix=hotfix)

    # Check the removed vulnerabilities report of installed hotfixes
    for cve, item in vulnerabilities['vulnerabilities'].items():
        installed, hotfix = is_hotfix_installed(item[0]['patch'], dep, hotfixes)
        if not installed:
            vd.check_vulnerability_scan_remove_log(wazuh_log_monitor,
                                                   get_os_short_name(mock_vulnerability_scan['os_name']),
                                                   cve)
            vd.check_vulnerability_scan_remove_alerts(wazuh_alert_monitor,
                                                      get_os_short_name(mock_vulnerability_scan['os_name']),
                                                      cve)
            vd.check_vulnerability_scan_inventory(agent=mock_agent,
                                                  package=get_os_short_name(mock_vulnerability_scan['os_name']),
                                                  arch=mock_vulnerability_scan['arch'],
                                                  version=os_version,
                                                  cve=cve,
                                                  condition='removed')

    vd.check_if_modulesd_is_running()
