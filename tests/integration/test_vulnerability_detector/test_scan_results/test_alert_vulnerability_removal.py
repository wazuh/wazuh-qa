# Copyright (C) 2015-2021, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is free software; you can redistribute it and/or modify it under the terms of GPLv2
import os
import time
from _pytest.fixtures import yield_fixture

import pytest

from wazuh_testing.modules import vulnerability_detector as vd
from wazuh_testing.tools import ALERT_FILE_PATH, LOG_FILE_PATH
from wazuh_testing.tools.configuration import load_wazuh_configurations, check_apply_test
from wazuh_testing.tools.monitoring import FileMonitor
from wazuh_testing.tools import file

# Marks
pytestmark = [pytest.mark.server, pytest.mark.tier(level=0)]

# variables
test_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
test_feed_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', 'data', 'feeds')
configurations_path = os.path.join(test_data_path, 'wazuh_alert_vulnerability_removal.yaml')
wazuh_log_monitor = FileMonitor(LOG_FILE_PATH)
wazuh_alert_monitor = FileMonitor(ALERT_FILE_PATH)
test_packet_vendor = 'WazuhIntegrationTests'
test_packet_version = '1.0.0'
test_packet_version_not_vulnerable = '2.1.0'
test_packet_0_name = 'wazuhintegrationpackage-0'
test_packet_1_name = 'wazuhintegrationpackage-1'
test_packet_0_cve = 'CVE-000'
test_packet_1_cve = 'CVE-001'

# Offline feeds
rhel_oval_feed_path = os.path.join(test_feed_path, vd.CUSTOM_REDHAT_OVAL_FEED)
rhel_json_feed_path = os.path.join(test_feed_path, vd.CUSTOM_REDHAT_JSON_FEED)
nvd_json_feed_path = os.path.join(test_feed_path, vd.CUSTOM_NVD_FEED)
parameters = [{
    'RHEL_FEED_PATH': rhel_oval_feed_path,
    'RHEL_JSON_FEED_PATH': rhel_json_feed_path,
    'NVD_JSON_FEED_PATH': nvd_json_feed_path
}]
metadata = parameters

# Configuration data
configurations = load_wazuh_configurations(configurations_path, __name__, params=parameters, metadata=metadata)

# Read JSON data template
nvd_vulnerabilities = file.read_json_file(nvd_json_feed_path)
rhel_vulnerabilities = file.read_json_file(rhel_json_feed_path)

# fixtures
@pytest.fixture(scope='module', params=configurations)
def get_configuration(request):
    """Get configurations from the module."""
    return request.param


@pytest.fixture(scope='function')
def mock_system(mock_agent_module):
    """
    It mocks an agent with syscollector packages in a synced state
    """
    vd.insert_osinfo(agent=mock_agent_module)

    vd.insert_package(agent=mock_agent_module, name=test_packet_0_name, vendor=test_packet_vendor,
                      version=test_packet_version, source='NULL')
    vd.insert_package(agent=mock_agent_module, name=test_packet_1_name, vendor=test_packet_vendor,
                      version=test_packet_version, source='NULL')

    # Force sync status for packages
    vd.update_sync_info(agent=mock_agent_module)

    # Forcing a baseline-scan
    vd.update_last_full_scan(0, mock_agent_module)

    yield mock_agent_module

    vd.clean_vd_tables()


@pytest.mark.skip(reason="It will be blocked by wazuh#9309, when it was solved we can enable again this test")
def test_alert_vulnerability_removal(get_configuration, configure_environment, restart_modulesd, mock_system):
    """Check if the Vulnerability Detector module generates an alert when a vulnerability is removed from the inventory.

    For this purpose, the manager is configured to use custom feeds that include vulnerabilities associated
    with two test packages. Those packages are added to the database of the simulated agent and, after enrollment
    of the agent, the vulnerability detector must launch the first scan on it, which is of BASELINE type.

    When the BASELINE scan is done, it will check that the vulnerabilities are added to the vuln_cves table.
    This will be verified by checking the log file. After this, one of the test packages will be removed
    and the other will be upgraded to a non-vulnerable version. These situations should generate alerts.

    Finally, it waits for the next scan, which should be of PARTIAL_SCAN type and, after it is finished,
    the alerts that should have been generated after the removal of the vulnerabilities are searched for.

    Args:
        get_configuration (fixture): Get configurations from the module.
        configure_environment (fixture): Configure a custom environment for testing.
        restart_modulesd (fixture): Reset wazuh_modulesd daemon, truncates ossec.log file and starts a new monitor.
        mock_system (fixture): Add a simulated agent to the manager for testing.
    """
    check_apply_test({'alert_vulnerability_removal'}, get_configuration['tags'])
    agent_id = mock_system

    # Set TIMESTAMP to the current time on METADATA of CVEs DB to simulate the feeds update.
    vd.modify_metadata_vuldet_feed('RHEL8', int(time.time()))

    # Callbacks
    callback_detect_baseline_scan_start = vd.make_vuln_callback(f"A baseline scan will be run on agent '{agent_id}'")
    callback_detect_partial_scan_start = vd.make_vuln_callback(f"A partial scan will be run on agent '{agent_id}'")
    callback_detect_scan_end = vd.make_vuln_callback(f"Finished vulnerability assessment for agent '{agent_id}'")
    callback_detect_test_package_0_alert = vd.make_vuln_callback(
        pattern=f"{test_packet_0_cve} affecting {test_packet_0_name} was eliminated", prefix='.*')
    callback_detect_test_package_1_alert = vd.make_vuln_callback(
        pattern=f"{test_packet_1_cve} affecting {test_packet_1_name} was eliminated", prefix='.*')

    # Detect the baseline scan.
    wazuh_log_monitor.start(timeout=vd.VULN_DETECTOR_SCAN_TIMEOUT,
                            callback=callback_detect_baseline_scan_start,
                            error_message='No baseline scan start has been detected in the log.')

    # Check if the NVD vulnerabilities are detected.
    vd.check_detected_vulnerabilities_number(agent=agent_id,
                                             wazuh_log_monitor=wazuh_log_monitor,
                                             expected_vulnerabilities_number=2,
                                             feed_source='NVD', timeout=vd.VULN_DETECTOR_SCAN_TIMEOUT)

    # Check the vulnerabilities in the inventory
    severity, cvss2_score, cvss3_score = vd.find_rhel_cve_severity_score(cve_nvd_array=nvd_vulnerabilities['CVE_Items'],
                                                                         cve_rhel_array=rhel_vulnerabilities,
                                                                         cve_id=test_packet_0_cve)

    vd.check_vulnerability_scan_inventory(agent=agent_id, package=test_packet_0_name, version=test_packet_version,
                                          arch='x86_64', cve=test_packet_0_cve, condition='inserted', severity=severity,
                                          cvss2=cvss2_score, cvss3=cvss3_score)

    severity, cvss2_score, cvss3_score = vd.find_rhel_cve_severity_score(cve_nvd_array=nvd_vulnerabilities['CVE_Items'],
                                                                         cve_rhel_array=rhel_vulnerabilities,
                                                                         cve_id=test_packet_1_cve)

    vd.check_vulnerability_scan_inventory(agent=agent_id, package=test_packet_1_name, version=test_packet_version,
                                          arch='x86_64', cve=test_packet_1_cve, condition='inserted', severity=severity,
                                          cvss2=cvss2_score, cvss3=cvss3_score)

    # Detect baseline scan completion.
    wazuh_log_monitor.start(timeout=vd.VULN_DETECTOR_SCAN_TIMEOUT,
                            callback=callback_detect_scan_end,
                            error_message='No baseline scan end has been detected in the log.')

    # Delete test package 0.
    vd.delete_package(agent=agent_id, package=test_packet_0_name)

    # Update test package 1 to a non-vulnerable version.
    vd.update_package(agent=agent_id, package=test_packet_1_name, version=test_packet_version_not_vulnerable)

    # Detect a partial scan.
    wazuh_log_monitor.start(timeout=vd.VULN_DETECTOR_SCAN_TIMEOUT,
                            callback=callback_detect_partial_scan_start,
                            error_message='No partial scan start has been detected in the log.')

    # Detect a partial scan completion.
    wazuh_log_monitor.start(timeout=vd.VULN_DETECTOR_SCAN_TIMEOUT,
                            callback=callback_detect_scan_end,
                            error_message='No partial scan end has been detected in the log.')

    # Ensure the removal of test package 0 has generated an alert.
    wazuh_alert_monitor.start(timeout=vd.VULN_DETECTOR_SCAN_TIMEOUT, update_position=False,
                              callback=callback_detect_test_package_0_alert,
                              error_message='No alert for test package 0 has been detected in the log.')

    # Ensure the test package update 1 has generated an alert.
    wazuh_alert_monitor.start(timeout=vd.VULN_DETECTOR_SCAN_TIMEOUT,
                              callback=callback_detect_test_package_1_alert,
                              error_message='No alert for test package 1 has been detected in the log.')

    # Check the vulnerabilities removal
    vd.check_vulnerability_scan_inventory(agent=agent_id, package=test_packet_0_name, version=test_packet_version,
                                          arch='x86_64', cve=test_packet_0_cve, condition='removed')
    vd.check_vulnerability_scan_inventory(agent=agent_id, package=test_packet_1_name,
                                          arch='x86_64', version=test_packet_version_not_vulnerable,
                                          cve=test_packet_1_cve, condition='removed')
