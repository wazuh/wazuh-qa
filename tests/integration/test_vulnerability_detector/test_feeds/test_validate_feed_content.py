'''
copyright: Copyright (C) 2015-2022, Wazuh Inc.

           Created by Wazuh, Inc. <info@wazuh.com>.

           This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

type: integration

brief: Wazuh is able to detect vulnerabilities in the applications installed in agents using the Vulnerability Detector
       module. This software audit is performed through the integration of vulnerability feeds indexed by Redhat,
       Canonical, Debian, Amazon Linux and NVD Database.

components:
    - vulnerability_detector

suite: feeds

targets:
    - manager

daemons:
    - wazuh-modulesd
    - wazuh-db
    - wazuh-analysisd

os_platform:
    - linux

os_version:
    - Arch Linux
    - Amazon Linux 2
    - Amazon Linux 1
    - CentOS 8
    - CentOS 7
    - Debian Buster
    - Red Hat 8
    - Ubuntu Trusty
    - Ubuntu Xenial
    - Ubuntu Bionic
    - Ubuntu Focal
    - Ubuntu Jammy
    - SUSE Linux Enterprise Desktop 11
    - SUSE Linux Enterprise Desktop 12
    - SUSE Linux Enterprise Desktop 15
    - SUSE Linux Enterprise Server 11
    - SUSE Linux Enterprise Server 12
    - SUSE Linux Enterprise Server 15

references:
    - https://documentation.wazuh.com/current/user-manual/capabilities/vulnerability-detection/
    - https://documentation.wazuh.com/current/user-manual/capabilities/syscollector.html

tags:
    - vulnerability
    - vulnerability_detector
    - feeds
'''
import os
import pytest
from datetime import datetime

from wazuh_testing.tools import file
from wazuh_testing.tools.configuration import get_test_cases_data


# Reference paths
TEST_DATA_PATH = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
TEST_CASES_PATH = os.path.join(TEST_DATA_PATH, 'test_cases')

# Configuration and cases data
t1_cases_path = os.path.join(TEST_CASES_PATH, 'cases_validate_json_feed_content.yaml')
t2_cases_path = os.path.join(TEST_CASES_PATH, 'cases_validate_xml_feed_content.yaml')

# Validate JSON feed content test configurations (t1)
_, t1_configuration_metadata, t1_case_ids = get_test_cases_data(t1_cases_path)

# Add NVD from 2002 to current year configuration and metadata
current_year = datetime.now().year
for year in range(2002, current_year + 1):
    t1_configuration_metadata.append({'provider_name': 'nvd', 'expected_format': 'application/gzip',
                                      'path': f"/tmp/nvdcve-1.1-{year}.json.gz", 'extension': 'gz',
                                      'url': f"https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-{year}.json.gz",
                                      'decompressed_file': f"/tmp/nvd-{year}.json"})
    t1_case_ids.append(f"NVD-{year}")

# Validate XML feed content test configurations (t2)
_, t2_configuration_metadata, t2_case_ids = get_test_cases_data(t2_cases_path)


def build_error_message(file_path, expected_format, check_type='extension'):
    """Define the error message when the extension or mime_type is not the expected one.

    Args:
        file_path (str): Path of the checked file.
        expected_format (str): Expected file format.
        check_type (str): 'extension` or `mime_type`.

    Returns:
        str: Error message.
    """
    return f"File {check_type} not expected. Got {file.get_file_info(file_path, check_type)} and expected " \
           f"{expected_format}"


@pytest.fixture
def manage_file(metadata):
    """Download and clean test files.

    Args:
        metadata (dict): Feed information which comes from metadata test case.
    """
    # Download the file
    file.download_file(source_url=metadata['url'], dest_path=metadata['path'])

    # Decompress files
    if 'application/gzip' in metadata['expected_format']:
        file.decompress_gzip(gzip_file_path=metadata['path'], dest_file_path=metadata['decompressed_file'])
    elif 'application/x-bzip2' in metadata['expected_format']:
        file.decompress_bz2(bz2_file_path=metadata['path'], dest_file_path=metadata['decompressed_file'])

    yield

    # Clean downloaded file/s
    file.remove_file(file_path=metadata['path'])

    if 'application/gzip' in metadata['expected_format'] or 'application/x-bzip2' in metadata['expected_format']:
        file.remove_file(file_path=metadata['decompressed_file'])


@pytest.mark.tier(level=2)
@pytest.mark.parametrize('metadata', t1_configuration_metadata, ids=t1_case_ids)
def test_validate_json_feed_content(metadata, manage_file):
    '''
    description: Check if the downloaded JSON feeds have the expected format and are JSON parseable.

    test_phases:
        - Download the feed file.
        - Check the content is JSON parseable (decompress if necessary).

    wazuh_min_version: 4.4.0

    tier: 2

    parameters:
        - metadata:
            type: dict
            brief: Wazuh configuration metadata
        - manage_file:
            type: fixture
            brief: Download and clean test files.

    assertions:
        - Check if the file is JSON parseable.

    input_description:
        - The `cases_validate_redhat_json_feed_content.yaml` file provides the module configuration for this test.
    '''
    if 'decompressed_file' in metadata:
        # Check compressed file extension
        assert file.get_file_info(file_path=metadata['path'], info_type="extension") == metadata['extension'], \
               build_error_message(metadata['path'], 'extension')

        # Check compressed file mim_type
        assert file.get_file_info(file_path=metadata['path'], info_type="mime_type") == metadata['expected_format'], \
               build_error_message(metadata['path'], 'mime_type')

    # Get the raw feed path
    raw_feed_file = metadata['decompressed_file'] if 'decompressed_file' in metadata else metadata['path']

    # Check if the raw feed is JSON parseable
    assert file.validate_json_file(raw_feed_file), f"{metadata['provider_name']} file is not JSON 'parseable'"


@pytest.mark.tier(level=2)
@pytest.mark.parametrize('metadata', t2_configuration_metadata, ids=t2_case_ids)
def test_validate_xml_feed_content(metadata, manage_file):
    '''
    description: Check if the downloaded XML feeds have the expected format and are XML parseable.

    test_phases:
        - Download the feed file.
        - Check the content is XML parseable (decompress if necessary).

    wazuh_min_version: 4.4.0

    tier: 2

    parameters:
        - metadata:
            type: dict
            brief: Wazuh configuration metadata
        - manage_file:
            type: fixture
            brief: Download and clean test files.

    assertions:
        - Check if the file is XML parseable.

    input_description:
        - The `cases_validate_redhat_xml_feed_content.yaml` file provides the module configuration for this test.
    '''
    if 'decompressed_file' in metadata:
        # Check compressed file extension
        assert file.get_file_info(file_path=metadata['path'], info_type="extension") == metadata['extension'], \
               build_error_message(metadata['path'], 'extension')

        # Check compressed file mim_type
        assert file.get_file_info(file_path=metadata['path'], info_type="mime_type") == metadata['expected_format'], \
               build_error_message(metadata['path'], 'mime_type')

    # Get the raw feed path
    raw_feed_file = metadata['decompressed_file'] if 'decompressed_file' in metadata else metadata['path']

    # Check if the raw feed is XML parseable
    assert file.validate_xml_file(raw_feed_file), f"{metadata['provider_name']} file is not XML 'parseable'"
