'''
brief: The tests will download the feeds for all the providers and verify if the format of each feed is the expected and if their content is a valid XML or JSON that can be parsed.

copyright:
    Copyright (C) 2015-2021, Wazuh Inc.

    Created by Wazuh, Inc. <info@wazuh.com>.

    This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

metadata:
    modules:
        - Vulnerability detector
    daemons:
        - wazuh-modulesd
    operating_system:
        - RedHat
        - Ubuntu
        - Debian
        - Windows
        - Arch Linux
    tiers:
        - 2
    tags:
        - NVD
'''

from datetime import datetime

import pytest
import wazuh_testing.tools.file as file

# Marks
pytestmark = pytest.mark.tier(level=2)

current_year = datetime.now().year

format_feed_data = [
    # Red Hat
    {'feed': 'redhat', 'os': 'generic', 'expected_format': 'json', 'path': '/tmp/cve.json', 'extension': 'json',
     'url': 'https://access.redhat.com/labs/securitydataapi/cve.json?after=1999-01-01'},
    {'feed': 'redhat', 'os': '5', 'expected_format': 'application/x-bzip2',
     'path': '/tmp/com.redhat.rhsa-RHEL5.xml.bz2', 'extension': 'bz2', 'decompressed_file': '/tmp/rhel5.xml',
     'url': 'https://www.redhat.com/security/data/oval/com.redhat.rhsa-RHEL5.xml.bz2'},
    {'feed': 'redhat', 'os': '6', 'expected_format': 'application/x-bzip2',
     'path': '/tmp/rhel-6-including-unpatched.oval.xml.bz2', 'extension': 'bz2', 'decompressed_file': '/tmp/rhel6.xml',
     'url': 'https://www.redhat.com/security/data/oval/v2/RHEL6/rhel-6-including-unpatched.oval.xml.bz2'},
    {'feed': 'redhat', 'os': '7', 'expected_format': 'application/x-bzip2',
     'path': '/tmp/rhel-7-including-unpatched.oval.xml.bz2', 'extension': 'bz2', 'decompressed_file': '/tmp/rhel7.xml',
     'url': 'https://www.redhat.com/security/data/oval/v2/RHEL7/rhel-7-including-unpatched.oval.xml.bz2'},
    {'feed': 'redhat', 'os': '8', 'expected_format': 'application/x-bzip2',
     'path': '/tmp/rhel-8-including-unpatched.oval.xml.bz2', 'extension': 'bz2', 'decompressed_file': '/tmp/rhel8.xml',
     'url': 'https://www.redhat.com/security/data/oval/v2/RHEL8/rhel-8-including-unpatched.oval.xml.bz2'},

    # Canonical
    {'feed': 'canonical', 'os': 'focal', 'expected_format': 'application/x-bzip2',
     'path': '/tmp/com.ubuntu.focal.cve.oval.xml.bz2', 'extension': 'bz2', 'decompressed_file': '/tmp/focal.xml',
     'url': 'https://people.canonical.com/~ubuntu-security/oval/com.ubuntu.focal.cve.oval.xml.bz2'},
    {'feed': 'canonical', 'os': 'bionic', 'expected_format': 'application/x-bzip2',
     'path': '/tmp/com.ubuntu.bionic.cve.oval.xml.bz2', 'extension': 'bz2', 'decompressed_file': '/tmp/bionic.xml',
     'url': 'https://people.canonical.com/~ubuntu-security/oval/com.ubuntu.bionic.cve.oval.xml.bz2'},
    {'feed': 'canonical', 'os': 'xenial', 'expected_format': 'application/x-bzip2',
     'path': '/tmp/com.ubuntu.xenial.cve.oval.xml.bz2', 'extension': 'bz2', 'decompressed_file': '/tmp/xenial.xml',
     'url': 'https://people.canonical.com/~ubuntu-security/oval/com.ubuntu.xenial.cve.oval.xml.bz2'},
    {'feed': 'canonical', 'os': 'trusty', 'expected_format': 'application/x-bzip2',
     'path': '/tmp/com.ubuntu.trusty.cve.oval.xml.bz2', 'extension': 'bz2', 'decompressed_file': '/tmp/trusty.xml',
     'url': 'https://people.canonical.com/~ubuntu-security/oval/com.ubuntu.trusty.cve.oval.xml.bz2'},

    # Debian
    {'feed': 'debian', 'os': 'buster', 'expected_format': 'xml', 'path': '/tmp/oval-definitions-buster.xml',
     'extension': 'xml', 'url': 'https://www.debian.org/security/oval/oval-definitions-buster.xml'},
    {'feed': 'debian', 'os': 'stretch', 'expected_format': 'xml', 'path': '/tmp/oval-definitions-stretch.xml',
     'extension': 'xml', 'url': 'https://www.debian.org/security/oval/oval-definitions-stretch.xml'},
    {'feed': 'debian', 'os': 'jessie', 'expected_format': 'xml', 'path': '/tmp/oval-definitions-jessie.xml',
     'extension': 'xml', 'url': 'https://www.debian.org/security/oval/oval-definitions-jessie.xml'},
    {'feed': 'debian', 'os': 'wheezy', 'expected_format': 'xml', 'path': '/tmp/oval-definitions-wheezy.xml',
     'extension': 'xml', 'url': 'https://www.debian.org/security/oval/oval-definitions-wheezy.xml'},
    {'feed': 'debian', 'os': 'generic', 'expected_format': 'json', 'path': '/tmp/debian-security-tracker.json',
     'extension': 'json', 'url': 'https://security-tracker.debian.org/tracker/data/json'},

    # MSU
    {'feed': 'msu', 'os': 'generic', 'expected_format': 'application/gzip', 'path': f'/tmp/msu-updates.json.gz',
     'extension': 'gz',
     'url': f'https://feed.wazuh.com/vulnerability-detector/windows/msu-updates.json.gz',
     'decompressed_file': f'/tmp/msu-updates.json'},

    # Arch Linux
    {'feed': 'arch', 'os': '', 'expected_format': 'json',
     'path': '/tmp/all.json', 'extension': 'json', 'url': 'https://security.archlinux.org/all.json'},
]

# NVD
for year in range(2002, current_year):
    format_feed_data.append({'feed': 'nvd', 'os': year, 'expected_format': 'application/gzip',
                             'path': f'/tmp/nvdcve-1.1-{year}.json.gz', 'extension': 'gz',
                             'url': f'https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-{year}.json.gz',
                             'decompressed_file': f'/tmp/nvd-{year}.json'})

format_feed_data_ids = [f"{item['feed']}_{item['os']}" for item in format_feed_data]


@pytest.fixture
def manage_file(feed, request):
    """
    Download and clean test files

    Parameters
    ----------
    feed: dict
        Feed information which comes from an element of 'format_feed_data' list
    """
    # Download the file
    file.download_file(source_url=feed['url'], dest_path=feed['path'])

    # Decompress files
    if feed['expected_format'] == 'application/gzip':
        file.decompress_gzip(gzip_file_path=feed['path'], dest_file_path=feed['decompressed_file'])
    elif feed['expected_format'] == 'application/x-bzip2':
        file.decompress_bz2(bz2_file_path=feed['path'], dest_file_path=feed['decompressed_file'])

    yield

    # Clean downloaded file/s
    file.remove_file(file_path=feed['path'])

    if feed['expected_format'] == 'application/gzip' or feed['expected_format'] == 'application/x-bzip2':
        file.remove_file(file_path=feed['decompressed_file'])


@pytest.mark.parametrize('feed', format_feed_data, ids=format_feed_data_ids)
def test_validate_feed_content(feed, manage_file):
    """
    test_logic:
        Check if the downloaded feeds have the expected format
    checks:
        - Feeds have the expected extension.
        - Feeds are parseable `JSON` or `XML`.
    """
    feed_source = feed['feed']
    error_file_extension_message = f"File extension not expected." \
                                   f"Got {file.get_file_info(file_path=feed['path'], info_type='extension')} " \
                                   f" and expected {feed['extension']}"

    error_file_mime_type_message = f"File mime type not expected." \
                                   f"Got {file.get_file_info(file_path=feed['path'], info_type='mime_type')} " \
                                   f"and expected {feed['expected_format']}"

    if feed_source == 'redhat':
        if feed['os'] == 'generic':
            assert file.validate_json_file(file_path=feed['path']), f"{feed_source} file is not JSON parseable"
        else:
            assert file.get_file_info(file_path=feed['path'], info_type="extension") == feed['extension'], \
                error_file_extension_message
            assert file.get_file_info(file_path=feed['path'], info_type="mime_type") == feed['expected_format'], \
                error_file_mime_type_message
            assert file.validate_xml_file(
                file_path=feed['decompressed_file']), f"{feed_source} file is not XML parseable"

    elif feed_source == 'canonical':
        assert file.get_file_info(file_path=feed['path'], info_type="extension") == feed['extension'], \
            error_file_extension_message
        assert file.get_file_info(file_path=feed['path'], info_type="mime_type") == feed['expected_format'], \
            error_file_mime_type_message
        assert file.validate_xml_file(file_path=feed['decompressed_file']), f"{feed_source} file is not XML parseable"

    elif feed_source == 'debian':
        if feed['os'] == 'generic':
            assert file.validate_json_file(file_path=feed['path']), f"{feed_source} file is not JSON parseable"
        else:
            assert file.validate_xml_file(file_path=feed['path']), f"{feed_source} file is not XML parseable"

    elif feed_source == 'nvd':
        assert file.get_file_info(file_path=feed['path'], info_type="extension") == feed['extension'], \
            error_file_extension_message
        assert file.get_file_info(file_path=feed['path'], info_type="mime_type") == feed['expected_format'], \
            error_file_mime_type_message
        assert file.validate_json_file(file_path=feed['decompressed_file']), f"{feed_source} file is not JSON parseable"

    elif feed_source == 'msu':
        assert file.get_file_info(file_path=feed['path'], info_type="extension") == feed['extension'], \
            error_file_extension_message
        assert file.get_file_info(file_path=feed['path'], info_type="mime_type") == feed['expected_format'], \
            error_file_mime_type_message
        assert file.validate_json_file(file_path=feed['decompressed_file']), f"{feed_source} file is not JSON parseable"

    elif feed_source == 'arch':
        assert file.validate_json_file(file_path=feed['path']), f"{feed_source} file is not JSON parseable"
