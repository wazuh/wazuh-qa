import json
import os
import re
import shutil
from typing import final
import pytest
from wazuh_testing.tools import file
from subprocess import run
import jsonschema
from jsonschema import validate
from wazuh_testing.tools import configuration


test_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
test_cases_path = os.path.join(test_data_path, 'test_cases')
feed_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', 'data')


test_feeds_path = os.path.join(test_cases_path, 'cases_cve5_format.yaml')

#Input feeds
test_input_nvd_feed_path = os.path.join(feed_path, 'input_feed', 'nvd', 'nvd_feed.json')
test_input_debian_feed_path = os.path.join(feed_path, 'input_feed', 'debian', 'debian_feed.json')
test_input_alas_json_feed_path = os.path.join(feed_path, 'input_feed', 'alas', 'alas_feed.json')
test_input_canonical_feed_path = os.path.join(feed_path, 'input_feed', 'canonical', 'canonical_feed.xml')
test_input_msu_feed_path = os.path.join(feed_path, 'input_feed', 'msu', 'msu_feed.json')
test_input_redhat_feed_path = os.path.join(feed_path, 'input_feed', 'redhat', 'redhat_feed.json')
test_input_arch_feed_path = os.path.join(feed_path, 'input_feed', 'arch', 'arch_feed.json')

test_output_feed_path = os.path.join(feed_path, 'output_feed', 'cve5.json')
test_output_schema_path = os.path.join(feed_path, 'output_feed', 'cve_5.0_schema.json')

ref_imports_path = os.path.join(feed_path, 'output_feed', 'imports', 'cvss')
ref_tags = os.path.join(feed_path, 'output_feed', 'tags')


output_path = "/home/belen/Feed-output/build/"
parser_type_json = "JSON"

_, configuration_metadata, test_case_ids = configuration.get_test_cases_data(test_feeds_path)

# Set offline custom feeds configuration
to_modify = ['CUSTOM_NVD_FEED_JSON_PATH', 'CUSTOM_DEBIAN_FEED_JSON_PATH', 'CUSTOM_ALAS_FEED_JSON_PATH',
             'CUSTOM_CANONICAL_FEED_JSON_PATH', 'CUSTOM_MSU_FEED_JSON_PATH', 'CUSTOM_REDHAT_FEED_JSON_PATH',
             'CUSTOM_ARCH_FEED_JSON_PATH']
new_values = [test_input_nvd_feed_path, test_input_debian_feed_path, test_input_alas_json_feed_path,
              test_input_canonical_feed_path, test_input_msu_feed_path, test_input_redhat_feed_path,
              test_input_arch_feed_path]

configuration_metadata = configuration.update_configuration_template(configuration_metadata, to_modify, new_values)

@pytest.fixture(scope='function')
def copy_references_json():
    """Copy in tmp folder files necessary to json schema """

    # Copy configuration
    shutil.copytree(ref_tags, '/tmp', dirs_exist_ok=True)
    shutil.copytree(ref_imports_path, '/tmp', dirs_exist_ok=True)


@pytest.mark.parametrize('metadata', configuration_metadata, ids=test_case_ids)
def test_format_cve5(metadata, copy_references_json):


    # Validate input file is a correct json
    assert file.validate_json_file(test_input_nvd_feed_path), "File is not JSON 'parseable'"

    # Execute migration tool
    os.chdir("/home/belen/Repositories/wazuh-content/build/third_party_migration/")
    os.system(f"./content_migration -i {test_input_nvd_feed_path} -t {parser_type_json} -o {output_path}")


    # Validate output file is a correct json
    assert file.validate_json_file(test_output_feed_path), "File is not JSON 'parseable'"

    cve5_file= file.read_json_file(test_output_feed_path)

    schema_file= file.read_json_file(test_output_schema_path)

    # Validate output is a correct cve5
    final_cve5_file = cve5_file['data'][0]['data_blob']['data'][0]

    isValid = validate_cve_format(final_cve5_file, schema_file)

    if isValid:
        #print(expected_cve)
        print("Given JSON data is Valid")
    else:
       #print(expected_cve)
        print("Given JSON data is InValid")



def validate_cve_format(cve_file, schema_file):
    try:
        validate(instance=cve_file, schema=schema_file)
    except jsonschema.exceptions.ValidationError as e:
        print(e.message)
        return False
    return True
    # # Validate required keys
    # cve5_file= file.read_json_file(test_output_feed_path)

    # source = ["source"]
    # data = ["data"]
    # operation = ["data", 0, "operation"]
    # cve_id = ["data", 0, "cve_id"]
    # data_hash = ["data", 0, "data_hash"]
    # data_blob = ["data", 0, "data_blob"]
    # data_type = ["data", 0, "data_blob", "data", 0, "dataType"]
    # data_version = ["data", 0, "data_blob", "data", 0, "dataVersion"]

    # cve_metadata = ["data", 0, "data_blob", "data", 0, "cveMetadata"]
    # feed_cve_id = ["data", 0, "data_blob", "data", 0, "cveMetadata", "cveId"]
    # assigner_org_id = ["data", 0, "data_blob", "data", 0, "cveMetadata", "assignerOrgId"]
    # state = [ "data", 0, "data_blob", "data", 0, "cveMetadata", "state"]

    # containers = ["data", 0, "data_blob", "data", 0, "containers"]
    # cna = ["data", 0, "data_blob", "data", 0, "containers", "cna"]
    # provider_metadata = ["data", 0, "data_blob", "data", 0, "containers", "cna", "providerMetadata"]
    # org_id = ["data", 0, "data_blob", "data", 0, "containers", "cna", "providerMetadata", "orgId"]
    # descriptions = ["data", 0, "data_blob", "data", 0, "containers", "cna", "descriptions"]
    # lang = ["data", 0, "data_blob", "data", 0, "containers", "cna", "descriptions" , 0 , "lang"]
    # value = ["data", 0, "data_blob", "data", 0, "containers", "cna", "descriptions" , 0 , "value"]
    # affected = ["data", 0, "data_blob", "data", 0, "containers", "cna", "affected"]
    # references = ["data", 0, "data_blob", "data", 0, "containers", "cna", "references"]
    # url = ["data", 0, "data_blob", "data", 0, "containers", "cna", "references", 0, "url"]

    # required_keys = [source, data, operation, cve_id, data_hash, data_blob, data_type, data_version, cve_metadata, feed_cve_id, assigner_org_id, state, containers,
    #                  cna, provider_metadata, org_id, descriptions, lang, value, affected, references, url]

    # for key in required_keys:
    #     assert keys_exists(cve5_file, key), f"Key {key} does not exist"



def keys_exists(element, keys):
    '''
    Check if *keys (nested) exists in `element` (dict).
    '''
    if not isinstance(element, dict):
        raise AttributeError('keys_exists() expects dict as first argument.')
    if len(keys) == 0:
        raise AttributeError('keys_exists() expects at least two arguments, one given.')

    _element = element
    for key in keys:
        try:
            _element = _element[key]
        except KeyError:
            return False
    return True


