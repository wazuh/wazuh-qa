'''
copyright: Copyright (C) 2015-2022, Wazuh Inc.

           Created by Wazuh, Inc. <info@wazuh.com>.

           This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

type: integration

brief: The 'wazuh-logcollector' daemon monitors configured files and commands for new log messages.
       Specifically, these tests will check if the 'only-future-events' option of the logcollector
       properly works when using the macOS unified logging system (ULS). Log data collection is
       the real-time process of making sense out of the records generated by servers or devices.
       This component can receive logs through text files or Windows event logs. It can also directly
       receive logs via remote syslog which is useful for firewalls and other such devices.

components:
    - logcollector

suite: macos

targets:
    - agent

daemons:
    - wazuh-logcollector

os_platform:
    - macos

os_version:
    - macOS Catalina
    - macOS Server

references:
    - https://documentation.wazuh.com/current/user-manual/capabilities/log-data-collection/index.html
    - https://documentation.wazuh.com/current/user-manual/reference/ossec-conf/localfile.html#only-future-events
    - https://developer.apple.com/documentation/os/logging

tags:
    - logcollector_macos
'''
import fnmatch
import os
import time

import pytest
from wazuh_testing import logcollector
from wazuh_testing.tools import LOG_FILE_PATH
from wazuh_testing.tools.configuration import load_wazuh_configurations
from wazuh_testing.tools.services import control_service
from wazuh_testing.tools.file import truncate_file
from wazuh_testing.tools.monitoring import FileMonitor

# Marks

pytestmark = [pytest.mark.darwin, pytest.mark.tier(level=0)]

# Configuration
test_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
configurations_path = os.path.join(test_data_path, 'wazuh_macos_format_only_future_events.yaml')
parameters = [{'ONLY_FUTURE_EVENTS': 'yes'}, {'ONLY_FUTURE_EVENTS': 'no'}]
metadata = [{'only-future-events': 'yes'}, {'only-future-events': 'no'}]

# Configuration data
configurations = load_wazuh_configurations(configurations_path, __name__, params=parameters, metadata=metadata)
configuration_ids = [f"{x['ONLY_FUTURE_EVENTS']}" for x in parameters]

elapsed_time_macos_log = 10

daemons_handler_configuration = {'daemons': ['wazuh-logcollector']}

local_internal_options = {'logcollector.debug': 2,
                          'logcollector.sample_log_length': 200}

macos_log_message_timeout = 40
macos_monitoring_macos_log_timeout = 30
macos_monitoring_timout_after_logcollector_started = 3


# Fixtures
@pytest.fixture(scope="module", params=configurations, ids=configuration_ids)
def get_configuration(request):
    """Get configurations from the module."""
    return request.param


@pytest.fixture(scope="module")
def get_connection_configuration():
    """Get configurations from the module."""
    return logcollector.DEFAULT_AUTHD_REMOTED_SIMULATOR_CONFIGURATION


@pytest.fixture(scope="module")
def get_connection_configuration():
    """Get configurations from the module."""
    return logcollector.DEFAULT_AUTHD_REMOTED_SIMULATOR_CONFIGURATIO


def test_macos_format_only_future_events(restart_logcollector_required_daemons_package, get_configuration,
                                         configure_environment, configure_local_internal_options_module,
                                         file_monitoring, daemons_handler_module):
    """
    description: Check if the 'only-future-events' option is used properly by the 'wazuh-logcollector' when
                 using the macOS unified logging system (ULS) events. For this purpose, the test will configure
                 a 'localfile' section using the macOS settings. Once the logcollector is started, it will check
                 if the 'monitoring' event is triggered, indicating that the logcollector starts to monitor
                 the macOS logs, and then, the test will generate a ULS event by using a logger tool. After this,
                 it will check if the logcollector event with the testing log message is triggered. Then, the test
                 will stop the 'wazuh-logcollector' daemon, generate a ULS event, and start it again. The test
                 will check if that event has been detected (depending on the value of the 'only-future-events' tag).
                 Finally, it will verify that the logcollector continues detecting new ULS events.

    wazuh_min_version: 4.2.0

    tier: 0

    parameters:
        - restart_logcollector_required_daemons_package:
            type: fixture
            brief: Restart the 'wazuh-agentd', 'wazuh-logcollector', and 'wazuh-modulesd' daemons.
        - get_configuration:
            type: fixture
            brief: Get configurations from the module.
        - configure_environment:
            type: fixture
            brief: Configure a custom environment for testing.
        - configure_local_internal_options_module:
            type: fixture
            brief: Set internal configuration for testing.
        - daemons_handler_module:
            type: fixture
            brief: Handler of Wazuh daemons.
        - file_monitoring:
            type: fixture
            brief: Handle the monitoring of a specified file.

    assertions:
        - Verify that the logcollector starts monitoring the macOS ULS log messages.
        - Verify that the logcollector detects the logs messages generated while it stopped
          when it is started, and the 'only-future-events' option is disabled.
        - Verify that the logcollector ignores the logs messages generated while it stopped
          when it is started, and the 'only-future-events' option is enabled.
        - Verify that the log collector continues detecting new logs messages when it is started.

    input_description: A configuration template (test_macos_format_only_future_events) is contained in an external
                       YAML file (wazuh_macos_format_only_future_events.yaml). That template is combined with two
                       test cases defined in the module. Those include configuration settings
                       for the 'wazuh-logcollector' daemon.

    expected_output:
        - r'Monitoring macOS logs with.*'
        - r'Old logger message'
        - r'New logger message'

    tags:
        - logs
    """
    log_monitor = FileMonitor(LOG_FILE_PATH)

    macos_logcollector_monitored = logcollector.callback_monitoring_macos_logs
    log_monitor.start(timeout=30, callback=macos_logcollector_monitored,
                      error_message=logcollector.GENERIC_CALLBACK_ERROR_TARGET_SOCKET)

    time.sleep(macos_monitoring_timout_after_logcollector_started)

    only_future_events = get_configuration['metadata']['only-future-events']

    old_message = 'Old logger message'
    new_message = 'New logger message'

    logcollector.generate_macos_logger_log(old_message)
    expected_old_macos_message = logcollector.format_macos_message_pattern('logger', old_message)

    log_monitor.start(timeout=macos_log_message_timeout,
                      callback=logcollector.callback_macos_log(expected_old_macos_message))

    # Stop logcollector and ensure it gets old macos messages if only-future-events option is disabled
    time.sleep(elapsed_time_macos_log)

    control_service('stop', 'wazuh-logcollector')

    truncate_file(LOG_FILE_PATH)
    log_monitor = FileMonitor(LOG_FILE_PATH)
    logcollector.generate_macos_logger_log(old_message)

    control_service('start', 'wazuh-logcollector')

    if only_future_events == 'yes':
        with pytest.raises(TimeoutError):
            log_monitor.start(timeout=macos_log_message_timeout,
                              callback=logcollector.callback_macos_log(expected_old_macos_message))

    else:
        log_monitor.start(timeout=macos_log_message_timeout,
                          callback=logcollector.callback_macos_log(expected_old_macos_message))

    logcollector.generate_macos_logger_log(new_message)

    expected_new_macos_message = logcollector.format_macos_message_pattern('logger', new_message)
    log_monitor.start(timeout=macos_log_message_timeout,
                      callback=logcollector.callback_macos_log(expected_new_macos_message),
                      error_message=logcollector.GENERIC_CALLBACK_ERROR_TARGET_SOCKET)
