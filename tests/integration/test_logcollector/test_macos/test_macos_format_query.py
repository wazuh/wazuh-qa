'''
copyright: Copyright (C) 2015-2022, Wazuh Inc.

           Created by Wazuh, Inc. <info@wazuh.com>.

           This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

type: integration

brief: The 'wazuh-logcollector' daemon monitors configured files and commands for new log messages.
       Specifically, these tests will check if the 'query' option of the logcollector properly works
       when using the macOS unified logging system (ULS). Log data collection is the real-time process
       of making sense out of the records generated by servers or devices. This component can receive
       logs through text files or Windows event logs. It can also directly receive logs via remote
       syslog which is useful for firewalls and other such devices.

components:
    - logcollector

suite: macos

targets:
    - agent

daemons:
    - wazuh-logcollector

os_platform:
    - macos

os_version:
    - macOS Catalina
    - macOS Server

references:
    - https://documentation.wazuh.com/current/user-manual/capabilities/log-data-collection/index.html
    - https://documentation.wazuh.com/current/user-manual/reference/ossec-conf/localfile.html#query
    - https://developer.apple.com/documentation/os/logging

tags:
    - logcollector_macos
'''
import os
import pytest
from time import sleep

from wazuh_testing import logcollector
from wazuh_testing.tools.configuration import load_wazuh_configurations
from wazuh_testing.tools import LOG_FILE_PATH
from wazuh_testing.tools.monitoring import FileMonitor


# Marks
pytestmark = [pytest.mark.darwin, pytest.mark.tier(level=1)]

# Configuration
test_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')

configurations_path_query = os.path.join(test_data_path, 'wazuh_macos_format_query.yaml')
configurations_path_query_type = os.path.join(test_data_path, 'wazuh_macos_format_query_type.yaml')
configurations_path_query_level = os.path.join(test_data_path, 'wazuh_macos_format_query_level.yaml')
configurations_path_query_type_level = os.path.join(test_data_path, 'wazuh_macos_format_query_type_level.yaml')

parameters_query_type_level = []
metadata_query_type_level = []

parameters_query_level = []
metadata_query_level = []

parameters_query_type = []
metadata_query_type = []

parameters_query = []
metadata_query = []

local_internal_options = {'logcollector.debug': 2,
                          'logcollector.sample_log_length': 200,
                          'monitord.rotate_log': 0}
macos_log_message_timeout = 10
macos_log_list = [
    {
        'program_name': 'logger',
        'message': "Logger testing message.",
    },
    {
        'program_name': 'logger',
        'message': "Custom oslog event message.",
    },
    {
        'program_name': 'logger',
        'message': "Not match Logger testing message.",
    },
    {
        'program_name': 'logger',
        'message': "Logger testing message not match.",
    },
    {
        'program_name': 'logger',
        'message': "Logger testingtestingnegative",
    },
    {
        'program_name': 'customlog',
        'level': 'default',
        'type': 'log',
        'subsystem': 'testing.wazuhagent.macos',
        'category': 'category.default'
    },
    {
        'program_name': 'customlogactivity',
        'level': 'default',
        'type': 'activity',
        'subsystem': '',
        'category': ''
    },
    {
        'program_name': 'customlogtrace',
        'level': 'default',
        'type': 'trace',
        'subsystem': '',
        'category': ''
    },
    {
        'program_name': 'customlog',
        'level': 'error',
        'type': 'log',
        'subsystem': 'testing.wazuhagent.macos',
        'category': 'category.error'
    },
    {
        'program_name': 'customlog1',
        'level': 'error',
        'type': 'log',
        'subsystem': 'testing.wazuhagent.macos',
        'category': 'category'
    },

    {
        'program_name': 'customloginfo',
        'level': 'info',
        'type': 'log',
        'subsystem': 'testing.wazuhagent.macos',
        'category': 'category'
    },
    {
        'program_name': 'customlogdebug',
        'level': 'debug',
        'type': 'log',
        'subsystem': 'testing.wazuhagent.example',
        'category': 'category'
    },
    {
        'program_name': 'customlogdebug',
        'level': 'default',
        'type': 'log',
        'subsystem': 'testing.wazuhagent.macos',
        'category': 'examplecategory1'
    },
]

query_list = [
    {
        'query_predicate': 'eventMessage == "Logger testing message."',
        'level': 'default',
        'type': ['log'],
        'lambda_function': lambda clause: clause == "Logger testing message.",
        'clause': ['message']
    },
    {
        'query_predicate': 'process = "logger"',
        'level': 'default',
        'type': ['log'],
        'lambda_function': lambda clause: clause == "logger",
        'clause': ['program_name']
    },
    {
        'query_predicate': 'eventMessage CONTAINS[c] "Logger testing" AND eventMessage CONTAINS[c] "testingnegative"',
        'level': 'default',
        'type': ['log'],
        'lambda_function': lambda message: "Logger testing" in message and "testingnegative" in message,
        'clause': ['message']
    },

    {
        'query_predicate': 'NOT messageType == "default"',
        'level': 'default',
        'type': ['log', 'trace'],
        'lambda_function': lambda clause: clause != "default",
        'clause': ['level'],
    },

    {
        'query_predicate': 'messageType == "error"',
        'level': 'default',
        'type': ['log'],
        'lambda_function': lambda clause: clause == "error",
        'clause': ['level'],
        'real_type': 'error'
    },

    {
        'query_predicate': 'messageType == "fault"',
        'level': 'default',
        'type': ['log', 'trace'],
        'lambda_function': lambda clause: clause == "fault",
        'clause': ['level'],
        'real_type': 'fault'
    },

    {
        'query_predicate': 'eventType == "logEvent"',
        'level': 'default',
        'type': ['log', 'activity'],
        'lambda_function': lambda clause: clause == "log",
        'clause': ['type']
    },

    {
        'query_predicate': 'eventType == "traceEvent"',
        'level': 'default',
        'type': ['log', 'trace'],
        'lambda_function': lambda clause: clause == "trace",
        'clause': ['type'],
        'real_type': 'trace'
    },

    {
        'query_predicate': 'eventType == "activityCreateEvent"',
        'level': 'default',
        'type': ['log'],
        'lambda_function': lambda clause: clause == "activity",
        'clause': ['type'],
        'real_type': 'activity'
    },

    {
        'query_predicate': 'process == "customlog"',
        'level': 'info',
        'type': ['log', 'activity'],
        'lambda_function': lambda clause: clause == "customlog",
        'clause': ['program_name']
    },

    {
        'query_predicate': 'process == "customlog"',
        'level': 'debug',
        'type': ['log', 'trace'],
        'lambda_function': lambda clause: clause == "customlog",
        'clause': ['program_name']
    },

    {
        'query_predicate': 'process == "customlog"',
        'level': 'default',
        'type': ['activity', 'log'],
        'lambda_function': lambda clause: clause == "customlog",
        'clause': ['program_name']
    },

    {
        'query_predicate': 'process == "customlog"',
        'level': 'default',
        'type': ['trace'],
        'lambda_function': lambda clause: clause == "customlog",
        'clause': ['program_name']
    },

    {
        'query_predicate': 'category CONTAINS[c] "examplecategory1"',
        'level': 'default',
        'type': ['log'],
        'lambda_function': lambda clause: "examplecategory1" in clause,
        'clause': ['category']
    },
    {
        'query_predicate': 'subsystem BEGINSWITH[c] "com"',
        'level': 'default',
        'type': ['log'],
        'lambda_function': lambda clause: clause.startswith("com"),
        'clause': ['subsystem']
    },

    {
        'query_predicate': '! subsystem ENDSWITH[c] "com"',
        'level': 'default',
        'type': ['log'],
        'lambda_function': lambda clause: not clause.endswith("com"),
        'clause': ['subsystem']
    },

    {
        'query_predicate': 'process == "logger" AND eventMessage CONTAINS[c] "Custom oslog event message"',
        'level': 'default',
        'type': ['log'],
        'lambda_function': lambda process, eventMessage: process == 'logger' and
                                                                    "Custom oslog event message" in eventMessage,
        'clause': ['program_name', 'message']
    },

    {
        'query_predicate': 'process BEGINSWITH[c] "custom" OR subsystem ENDSWITH[c] "example"',
        'level': 'default',
        'type': ['activity'],
        'lambda_function': lambda process, subsystem: process.startswith("custom") or subsystem.endswith("example"),
        'clause': ['program_name', 'subsystem']
    },
]

for query in query_list:
    type = ','.join(type for type in query['type'])
    parameters_query_type_level += [{'QUERY': query['query_predicate'], 'TYPE': type, 'LEVEL': query['level']}]
    metadata_query_type_level += [{'query': query['query_predicate'], 'type': type, 'level': query['level'],
                                   'lambda_function': query['lambda_function'], 'clause': query['clause']}]

    parameters_query_level += [{'QUERY': query['query_predicate'], 'LEVEL': query['level']}]
    metadata_query_level += [{'query': query['query_predicate'], 'level': query['level'],
                              'lambda_function': query['lambda_function'], 'clause': query['clause']}]

    parameters_query_type += [{'QUERY': query['query_predicate'], 'TYPE': type}]
    metadata_query_type += [{'query': query['query_predicate'], 'type': type,
                             'lambda_function': query['lambda_function'], 'clause': query['clause']}]

    parameters_query += [{'QUERY': query['query_predicate']}]
    metadata_query += [{'query': query['query_predicate'], 'lambda_function': query['lambda_function'],
                        'clause': query['clause']}]

configurations = load_wazuh_configurations(configurations_path_query_type_level, __name__,
                                           params=parameters_query_type_level, metadata=metadata_query_type_level)
configurations += load_wazuh_configurations(configurations_path_query_type, __name__,
                                            params=parameters_query_type, metadata=metadata_query_type)
configurations += load_wazuh_configurations(configurations_path_query_level, __name__,
                                            params=parameters_query_level, metadata=metadata_query_level)
configurations += load_wazuh_configurations(configurations_path_query, __name__,
                                            params=parameters_query, metadata=metadata_query)

configuration_ids = [f"{x['query']}_{x['level']}_{str(x['type'])}" for x in metadata_query_type_level] + \
                    [f"{x['query']}_{x['level']}" for x in metadata_query_level] + \
                    [f"{x['query']}_{str(x['type'])}" for x in metadata_query_type] + \
                    [f"{x['query']}" for x in metadata_query]


# Fixtures
@pytest.fixture(scope="module", params=configurations, ids=configuration_ids)
def get_configuration(request):
    """Get configurations from the module."""
    return request.param


@pytest.fixture(scope="module")
def get_connection_configuration():
    """Get configurations from the module."""
    return logcollector.DEFAULT_AUTHD_REMOTED_SIMULATOR_CONFIGURATION


def test_macos_format_query(configure_local_internal_options_module, restart_logcollector_required_daemons_package,
                            get_configuration, configure_environment, get_connection_configuration, file_monitoring,
                            restart_logcollector):
    """
    description: Check if the 'query' option together with its attributes ('type' and 'level') is properly used
                 by the 'wazuh-logcollector' when using the macOS unified logging system (ULS) events. For this
                 purpose, the test will configure a 'localfile' section using the macOS settings. Once the
                 logcollector is started, it will check if the 'monitoring' event is triggered, indicating
                 that the logcollector starts to monitor the macOS logs, and then, the test will generate
                 multiple ULS events by using a logger tool. Finally, it will verify that the log collector
                 events with the testing log messages are only triggered if they fulfill the query predicate.

    wazuh_min_version: 4.2.0

    tier: 1

    parameters:
        - configure_local_internal_options_module:
            type: fixture
            brief: Set internal configuration for testing.
        - restart_logcollector_required_daemons_package:
            type: fixture
            brief: Restart the 'wazuh-agentd', 'wazuh-logcollector', and 'wazuh-modulesd' daemons.
        - get_configuration:
            type: fixture
            brief: Get configurations from the module.
        - configure_environment:
            type: fixture
            brief: Configure a custom environment for testing.
        - get_connection_configuration:
            type: fixture
            brief: Get configurations from the module.
        - file_monitoring:
            type: fixture
            brief: Handle the monitoring of a specified file.
        - restart_logcollector:
            type: fixture
            brief: Reset the 'ossec.log' file and start a new monitor.

    assertions:
        - Verify that the logcollector starts monitoring the macOS ULS log messages.
        - Verify that the logcollector generates events for all ULS events that fulfill
          the 'query' predicate and vice versa.

    input_description: Configuration templates (test_macos_format_query) are contained in external YAML files
                       (wazuh_macos_format_query*.yaml, ). Those templates are combined with different
                       test cases defined in the module. Those include configuration settings
                       for the 'wazuh-logcollector' daemon.

    expected_output:
        - r'Monitoring macOS logs with.*'
        - Multiple testing log messages from the ULS events.

    tags:
        - logs
    """
    log_monitor = FileMonitor(LOG_FILE_PATH)

    sleep(1)

    cfg = get_configuration['metadata']

    macos_logcollector_monitored = logcollector.callback_monitoring_macos_logs
    log_monitor.start(timeout=logcollector.LOG_COLLECTOR_GLOBAL_TIMEOUT, callback=macos_logcollector_monitored,
                      error_message=logcollector.GENERIC_CALLBACK_ERROR_ANALYZING_MACOS)

    match_query_list = []
    sleep(macos_log_message_timeout)

    # Generate macOS log messages
    for macos_log in macos_log_list:
        log_message_command = macos_log['program_name']

        if log_message_command == 'logger':
            logcollector.generate_macos_logger_log(macos_log['message'])

        else:
            logcollector.generate_macos_custom_log(macos_log['type'], macos_log['level'], macos_log['subsystem'],
                                                   macos_log['category'], macos_log['program_name'])

        clauses_values = []

        same_type = True
        same_level = True

        macos_log_type = macos_log['type'] if 'type' in macos_log else 'log'
        macos_log_level = macos_log['level'] if 'level' in macos_log else 'default'

        if macos_log['program_name'] != 'logger':
            if macos_log['type'] == 'activity':
                macos_log['message'] = logcollector.TEMPLATE_ACTIVITY_MESSAGE
            elif macos_log['type'] == 'log':
                macos_log['message'] = logcollector.TEMPLATE_OSLOG_MESSAGE
            elif macos_log['type'] == 'trace':
                macos_log['message'] = logcollector.TEMPLATE_TRACE_MESSAGE

        macos_log['type'] = macos_log_type
        macos_log['level'] = macos_log_level

        configuration_level = cfg['level'] if 'level' in cfg else 'default'
        configuration_type = cfg['type'] if 'type' in cfg else ['log']

        if 'type' in cfg:
            if macos_log_type not in configuration_type:
                same_type = False

        if logcollector.MAP_MACOS_LEVEL_VALUE[macos_log_level] \
           < logcollector.MAP_MACOS_LEVEL_VALUE[configuration_level]:
            same_level = False

        for clause in cfg['clause']:
            clause_value = str(macos_log[clause]) if clause in macos_log else ""
            clauses_values += [clause_value]

        if log_message_command == 'logger':
            expected_macos_message = logcollector.format_macos_message_pattern(macos_log['program_name'],
                                                                               macos_log['message'])
        else:
            expected_macos_message = logcollector.format_macos_message_pattern(
                macos_log['program_name'],
                macos_log['message'], type=macos_log['type'], subsystem=macos_log['subsystem'],
                category=macos_log['category'])

        match_values = {'clauses_values': clauses_values,
                        'same_level': same_level,
                        'same_type': same_type,
                        'expected_macos_message': expected_macos_message}

        match_query_list.append(match_values)

    sleep(macos_log_message_timeout)
    elapsed_time_filemonitor_read_event = 2

    for macos_log in match_query_list:
        log_monitor = FileMonitor(LOG_FILE_PATH)
        if cfg['lambda_function'](*(macos_log['clauses_values'])) and macos_log['same_level'] \
           and macos_log['same_type']:
            log_monitor.start(timeout=elapsed_time_filemonitor_read_event,
                              callback=logcollector.callback_macos_log(macos_log['expected_macos_message']),
                              error_message=f"No macos log message generated: {macos_log['expected_macos_message']}")
        else:
            with pytest.raises(TimeoutError):
                log_monitor.start(timeout=elapsed_time_filemonitor_read_event,
                                  callback=logcollector.callback_macos_log(macos_log['expected_macos_message']),
                                  error_message=f"Unexpected macos log message generated: \
                                                 {macos_log['expected_macos_message']}")
