# Copyright (C) 2015-2023, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

import os
import sys
import subprocess
import json
from jsonschema import validate
from collections import Counter
from wazuh_testing import global_parameters, logger, WAZUH_TESTING_DATA_PATH
from wazuh_testing.modules.fim import REQUIRED_ATTRIBUTES, REQUIRED_REG_KEY_ATTRIBUTES, REQUIRED_REG_VALUE_ATTRIBUTES
from wazuh_testing.modules.fim.event_monitor import callback_detect_event

if sys.platform == 'linux2' or sys.platform == 'linux':
    from jq import jq

_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')


def validate_event(event, checks=None, mode=None):
    """Check if event is properly formatted according to some checks.

    Args:
        event (dict): represents an event generated by syscheckd.
        checks (:obj:`set`, optional): set of XML CHECK_* options. Default `{CHECK_ALL}`
        mode (:obj:`str`, optional): represents the FIM mode expected for the event to validate.
    """

    def get_required_attributes(check_attributes, result=None):
        result = set() if result is None else result
        for check in check_attributes:
            mapped = REQUIRED_ATTRIBUTES[check]
            if isinstance(mapped, str):
                result |= {mapped}
            elif isinstance(mapped, list):
                result |= set(mapped)
            elif isinstance(mapped, set):
                result |= get_required_attributes(mapped, result=result)
        return result

    json_file = 'syscheck_event_windows.json' if sys.platform == "win32" else 'syscheck_event.json'
    with open(os.path.join(WAZUH_TESTING_DATA_PATH, json_file), 'r') as f:
        schema = json.load(f)
    validate(schema=schema, instance=event)

    # Check FIM mode
    mode = global_parameters.current_configuration['metadata']['fim_mode'] if mode is None else mode.replace('-', '')
    assert (event['data']['mode']).replace('-', '') == mode, f"The event's FIM mode was '{event['data']['mode']}' \
        but was expected to be '{mode}'"

    # Check attributes
    if checks:
        attributes = event['data']['attributes'].keys() - {'type', 'checksum'}

        required_attributes = get_required_attributes(checks)
        required_attributes -= get_required_attributes({CHECK_GROUP}) if sys.platform == "win32" else {'attributes'}

        intersection = attributes ^ required_attributes
        intersection_debug = "Event attributes are: " + str(attributes)
        intersection_debug += "\nRequired Attributes are: " + str(required_attributes)
        intersection_debug += "\nIntersection is: " + str(intersection)
        assert (intersection == set()), f'Attributes and required_attributes are not the same. ' + intersection_debug

        # Check add file event
        if event['data']['type'] == 'added':
            assert 'old_attributes' not in event['data'] and 'changed_attributes' not in event['data']
        # Check modify file event
        if event['data']['type'] == 'modified':
            assert 'old_attributes' in event['data'] and 'changed_attributes' in event['data']

            old_attributes = event['data']['old_attributes'].keys() - {'type', 'checksum'}
            old_intersection = old_attributes ^ required_attributes
            old_intersection_debug = "Event attributes are: " + str(old_attributes)
            old_intersection_debug += "\nRequired Attributes are: " + str(required_attributes)
            old_intersection_debug += "\nIntersection is: " + str(old_intersection)
            assert (old_intersection == set()), (f'Old_attributes and required_attributes are not the same. ' +
                                                 old_intersection_debug)


def validate_registry_event(event, checks=None, mode=None, is_key=True):
    """Check if event is properly formatted according to some checks.

    Args:
        event (dict): represents an event generated by syscheckd.
        checks (:obj:`set`, optional): set of XML CHECK_* options. Default `{CHECK_ALL}`
        mode (:obj:`str`, optional): represents the FIM mode expected for the event to validate.
        is_key(Boolean): define if event to validate is a registry_key (True) or registry_value(False). Default True
    """

    def get_required_attributes(check_attributes, result=None):
        result = set() if result is None else result
        for check in check_attributes:
            mapped = REQUIRED_REG_KEY_ATTRIBUTES[check] if is_key else REQUIRED_REG_VALUE_ATTRIBUTES[check]

            if isinstance(mapped, str):
                result |= {mapped}
            elif isinstance(mapped, list):
                result |= set(mapped)
            elif isinstance(mapped, set):
                result |= get_required_attributes(mapped, result=result)

        return result

    json_file = 'syscheck_event_windows.json' if sys.platform == "win32" else 'syscheck_event.json'
    with open(os.path.join(_data_path, json_file), 'r') as f:
        schema = json.load(f)

    validate(schema=schema, instance=event)

    # Check FIM mode
    mode = global_parameters.current_configuration['metadata']['fim_mode'] if mode is None else mode.replace('-', '')
    assert (event['data']['mode']).replace('-', '') == mode, f"The event's FIM mode was '{event['data']['mode']}' \
        but was expected to be '{mode}'"

    # Check attributes
    if checks:
        attributes = event['data']['attributes'].keys() - {'type', 'checksum'}

        required_attributes = get_required_attributes(checks)

        intersection = attributes ^ required_attributes
        intersection_debug = "Event attributes are: " + str(attributes)
        intersection_debug += "\nRequired Attributes are: " + str(required_attributes)
        intersection_debug += "\nIntersection is: " + str(intersection)

        assert (intersection == set()), f'Attributes and required_attributes are not the same. ' + intersection_debug

        # Check add file event
        if event['data']['type'] == 'added':
            assert 'old_attributes' not in event['data'] and 'changed_attributes' not in event['data']

        # Check modify file event
        if event['data']['type'] == 'modified':
            assert 'old_attributes' in event['data'] and 'changed_attributes' in event['data']

            old_attributes = event['data']['old_attributes'].keys() - {'type', 'checksum'}
            old_intersection = old_attributes ^ required_attributes
            old_intersection_debug = "Event attributes are: " + str(old_attributes)
            old_intersection_debug += "\nRequired Attributes are: " + str(required_attributes)
            old_intersection_debug += "\nIntersection is: " + str(old_intersection)

            assert (old_intersection == set()), (f'Old_attributes and required_attributes are not the same. ' +
                                                 old_intersection_debug)


class CustomValidator:
    """Enable using user-defined validators over the events when validating them with EventChecker"""

    def __init__(self, validators_after_create=None, validators_after_update=None,
                 validators_after_delete=None, validators_after_cud=None):
        self.validators_create = validators_after_create
        self.validators_update = validators_after_update
        self.validators_delete = validators_after_delete
        self.validators_cud = validators_after_cud

    def validate_after_create(self, events):
        """Custom validators to be applied by default when the event_type is 'added'.

        Args:
            events (list): list of events to be validated.
        """
        if self.validators_create is not None:
            for event in events:
                for validator in self.validators_create:
                    validator(event)

    def validate_after_update(self, events):
        """Custom validators to be applied by default when the event_type is 'modified'.

        Args:
            events (list): list of events to be validated.
        """
        if self.validators_update is not None:
            for event in events:
                for validator in self.validators_update:
                    validator(event)

    def validate_after_delete(self, events):
        """Custom validators to be applied by default when the event_type is 'deleted'.

        Args:
            events (list): list of events to be validated.
        """
        if self.validators_delete is not None:
            for event in events:
                for validator in self.validators_delete:
                    validator(event)

    def validate_after_cud(self, events):
        """Custom validators to be applied always by default.

        Args:
            events (list): list of events to be validated.
        """
        if self.validators_cud is not None:
            for event in events:
                for validator in self.validators_cud:
                    validator(event)


class EventChecker:
    """Utility to allow fetch events and validate them."""

    def __init__(self, log_monitor, folder, file_list=['testfile0'], options=None, custom_validator=None, encoding=None,
                 callback=callback_detect_event):
        self.log_monitor = log_monitor
        self.folder = folder
        self.file_list = file_list
        self.custom_validator = custom_validator
        self.options = options
        self.encoding = encoding
        self.events = None
        self.callback = callback

    def fetch_and_check(self, event_type, min_timeout=1, triggers_event=True, extra_timeout=0, event_mode=None,
                        escaped=False):
        """Call both 'fetch_events' and 'check_events'.

        Args:
            event_type (str): Expected type of the raised event {'added', 'modified', 'deleted'}.
            event_mode (str, optional): Specifies the scan mode to check in the events
            min_timeout (int, optional): seconds to wait until an event is raised when trying to fetch. Defaults `1`
            triggers_event (boolean, optional): True if the event should be raised. False otherwise. Defaults `True`
            extra_timeout (int, optional): Additional time to wait after the min_timeout
        """
        num_files = len(self.file_list)
        error_msg = "TimeoutError was raised because "
        error_msg += str(num_files) if num_files > 1 else "a single"
        error_msg += " '" + str(event_type) + "' "
        error_msg += "events were " if num_files > 1 else "event was "
        error_msg += "expected for " + str(self._get_file_list())
        error_msg += " but were not detected." if len(self.file_list) > 1 else " but was not detected."

        self.events = self.fetch_events(min_timeout, triggers_event, extra_timeout, error_message=error_msg)
        self.check_events(event_type, mode=event_mode, escaped=escaped)

    def fetch_events(self, min_timeout=1, triggers_event=True, extra_timeout=0, error_message=''):
        """Try to fetch events on a given log monitor. Will return a list with the events detected.

        Args:
            min_timeout (int, optional): seconds to wait until an event is raised when trying to fetch. Defaults `1`
            triggers_event (boolean, optional): True if the event should be raised. False otherwise. Defaults `True`
            extra_timeout (int, optional): Additional time to wait after the min_timeout
            error_message (str): Message to explain a possible timeout error
        """

        def clean_results(event_list):
            """Iterate the event_list provided and check if the 'modified' events contained should be merged to fix
            whodata's bug that raise more than one modification event when a file is modified. If some 'modified' event
            shares 'path' and 'timestamp' we assume that belongs to the same modification.
            """
            if not isinstance(event_list, list):
                return event_list
            result_list = list()
            previous = None
            while len(event_list) > 0:
                current = event_list.pop(0)
                if current['data']['type'] == "modified":
                    if not previous:
                        previous = current
                    elif (previous['data']['path'] == current['data']['path'] and
                          current['data']['timestamp'] in [previous['data']['timestamp'],
                                                           previous['data']['timestamp'] + 1]):
                        previous['data']['changed_attributes'] = list(set(previous['data']['changed_attributes']
                                                                          + current['data']['changed_attributes']))
                        previous['data']['attributes'] = current['data']['attributes']
                    else:
                        result_list.append(previous)
                        previous = current
                else:
                    result_list.append(current)
            if previous:
                result_list.append(previous)
            return result_list

        try:
            result = self.log_monitor.start(timeout=max(len(self.file_list) * 0.01, min_timeout),
                                            callback=self.callback,
                                            accum_results=len(self.file_list),
                                            timeout_extra=extra_timeout,
                                            encoding=self.encoding,
                                            error_message=error_message).result()
            assert triggers_event, f'No events should be detected.'
            if extra_timeout > 0:
                result = clean_results(result)
            return result if isinstance(result, list) else [result]
        except TimeoutError:
            if triggers_event:
                raise
            logger.info("TimeoutError was expected and correctly caught.")

    def check_events(self, event_type, mode=None, escaped=False):
        """Check and validate all events in the 'events' list.

        Args:
            event_type (str): Expected type of the raised event {'added', 'modified', 'deleted'}.
            mode (str, optional): Specifies the FIM scan mode to check in the events
            escaped (Boolean): check if file path has to be escaped.
        """

        def validate_checkers_per_event(events, options, mode):
            """Check if each event is properly formatted according to some checks.

            Args:
                events (list): event list to be checked.
                options (set): set of XML CHECK_* options. Default `{CHECK_ALL}`
                mode (str): represents the FIM mode expected for the event to validate.
            """
            for ev in events:
                validate_event(ev, options, mode)

        def check_events_type(events, ev_type, file_list=['testfile0']):
            event_types = Counter(filter_events(events, ".[].data.type"))
            msg = f"Non expected number of events. {event_types[ev_type]} != {len(file_list)}"
            assert (event_types[ev_type] == len(file_list)), msg

        def check_events_path(events, folder, file_list=['testfile0'], mode=None, escaped=False):
            mode = global_parameters.current_configuration['metadata']['fim_mode'] if mode is None else mode
            data_path = filter_events(events, ".[].data.path")
            for file_name in file_list:
                expected_path = os.path.join(folder, file_name)
                if escaped:
                    expected_path = expected_path.replace("\\", "\\\\")
                if self.encoding is not None:
                    for index, item in enumerate(data_path):
                        data_path[index] = item.encode(encoding=self.encoding)
                if sys.platform == 'darwin' and self.encoding and self.encoding != 'utf-8':
                    logger.info(f"Not asserting {expected_path} in event.data.path. "
                                f'Reason: using non-utf-8 encoding in darwin.')
                else:
                    error_msg = f"Expected data path was '{expected_path}' but event data path is '{data_path}'"
                    assert (expected_path in str(data_path)), error_msg

        def filter_events(events, mask):
            """Returns a list of elements matching a specified mask in the events list using jq module."""
            if sys.platform in ("win32", 'sunos5', 'darwin'):
                stdout = subprocess.check_output(["jq", "-r", mask], input=json.dumps(events).encode())
                return stdout.decode("utf8").strip().split(os.linesep)
            else:
                return jq(mask).transform(events, multiple_output=True)

        if self.events is not None:
            validate_checkers_per_event(self.events, self.options, mode)
            check_events_type(self.events, event_type, self.file_list)
            check_events_path(self.events, self.folder, file_list=self.file_list, mode=mode, escaped=escaped)

            if self.custom_validator is not None:
                self.custom_validator.validate_after_cud(self.events)
                if event_type == "added":
                    self.custom_validator.validate_after_create(self.events)
                elif event_type == "modified":
                    self.custom_validator.validate_after_update(self.events)
                elif event_type == "deleted":
                    self.custom_validator.validate_after_delete(self.events)

    def _get_file_list(self):
        result_list = []
        for file_name in self.file_list:
            expected_file_path = os.path.join(self.folder, file_name)
            expected_file_path = expected_file_path[:1].lower() + expected_file_path[1:]
            result_list.append(expected_file_path)
        return result_list


class RegistryEventChecker:
    """Utility to allow fetch events and validate them."""

    def __init__(self, log_monitor, registry_key, registry_dict=None, options=None, custom_validator=None,
                 encoding=None, callback=callback_detect_event, is_value=False):
        self.log_monitor = log_monitor
        self.registry_key = registry_key
        global registry_ignore_path
        registry_ignore_path = registry_key
        self.registry_dict = registry_dict
        self.custom_validator = custom_validator
        self.options = options
        self.encoding = encoding
        self.events = None
        self.callback = callback
        self.is_value = is_value

    def __del__(self):
        global registry_ignore_path
        registry_ignore_path = None

    def fetch_and_check(self, event_type, min_timeout=1, triggers_event=True, extra_timeout=0):
        """Call 'fetch_events', 'fetch_key_events' and 'check_events', depending on the type of event expected.

        Args:
            event_type (str): Expected type of the raised event {'added', 'modified', 'deleted'}.
            min_timeout (int, optional): seconds to wait until an event is raised when trying to fetch. Defaults `1`
            triggers_event (boolean, optional): True if the event should be raised. False otherwise. Defaults `True`
            extra_timeout (int, optional): Additional time to wait after the min_timeout
        """
        assert event_type in ['added', 'modified', 'deleted'], f'Incorrect event type: {event_type}'

        num_elems = len(self.registry_dict)

        error_msg = "TimeoutError was raised because "
        error_msg += str(num_elems) if num_elems > 1 else "a single"
        error_msg += " '" + str(event_type) + "' "
        error_msg += "events were " if num_elems > 1 else "event was "
        error_msg += "expected for " + str(self._get_elem_list())
        error_msg += " but were not detected." if num_elems > 1 else " but was not detected."

        key_error_msg = f"TimeoutError was raised because 1 event was expected for {self.registry_key} "
        key_error_msg += 'but was not detected.'

        if event_type == 'modified' or self.is_value:
            self.events = self.fetch_events(min_timeout, triggers_event, extra_timeout, error_message=error_msg)
            self.check_events(event_type)
        elif event_type == 'added':
            self.events = self.fetch_events(min_timeout, triggers_event, extra_timeout, error_message=error_msg)
            self.check_events(event_type)
        elif event_type == 'deleted':
            self.events = self.fetch_events(min_timeout, triggers_event, extra_timeout, error_message=error_msg)
            self.check_events(event_type)

    def fetch_events(self, min_timeout=1, triggers_event=True, extra_timeout=0, error_message=''):
        """ Gets as much events that match the callback as possible in the given time.

        Args:
            min_timeout (int, optional): seconds to wait until an event is raised when trying to fetch. Defaults `1`
            triggers_event (boolean, optional): True if the event should be raised. False otherwise. Defaults `True`
            extra_timeout (int, optional): Additional time to wait after the min_timeout
            error_message(str, optional): Message that will be printed by the FileMonitor in case of error.
        """
        timeout_per_registry_estimation = 0.01
        try:
            result = self.log_monitor.start(timeout=max((len(self.registry_dict)) * timeout_per_registry_estimation,
                                            min_timeout), callback=self.callback, accum_results=len(self.registry_dict),
                                            timeout_extra=extra_timeout, encoding=self.encoding,
                                            error_message=error_message).result()

            assert triggers_event, 'No events should be detected.'
            return result if isinstance(result, list) else [result]
        except TimeoutError:
            if triggers_event:
                raise
            logger.info("TimeoutError was expected and correctly caught.")

    def check_events(self, event_type, mode=None):
        """Check and validate all events in the 'events' list.

        Args:
            event_type (str): Expected type of the raised event {'added', 'modified', 'deleted'}.
            mode (str): expected mode of the raised event.
        """

        def validate_checkers_per_event(events, options, mode):
            """Check if each event is properly formatted according to some checks.

            Args:
                events (list): event list to be checked.
                options (set): set of XML CHECK_* options. Default `{CHECK_ALL}`
                mode (str): represents the FIM mode expected for the event to validate.
            """
            for ev in events:
                if self.is_value:
                    validate_registry_event(ev, options, mode, is_key=False)
                else:
                    validate_registry_event(ev, options, mode, is_key=False)

        def check_events_type(events, ev_type, reg_list=['testkey0']):
            """Checks the event type of each events in a list.

            Args:
                events (list): event list to be checked.
                ev_type (str): type of expected event.
                reg_list (list): list of keys that are being checked.
            """
            event_types = Counter(filter_events(events, ".[].data.type"))

            assert (event_types[ev_type] == len(reg_list)), f'Non expected number of \
                                                              events. {event_types[ev_type]} != {len(reg_list)}'

        def check_events_key_path(events, registry_key, reg_list=['testkey0'], mode=None):
            """Checks the path for a registry_key event in a list.

            Args:
                events (list): event list to be checked.
                registry_key (str): path to the key being checked.
                reg_list (list, optional): list of keys that are being checked.
                mode(str, optional): defines the type of FIM monitoring mode configured
            """
            mode = global_parameters.current_configuration['metadata']['fim_mode'] if mode is None else mode
            key_path = filter_events(events, ".[].data.path")

            for reg in reg_list:
                expected_path = os.path.join(registry_key, reg)

                if self.encoding is not None:
                    for index, item in enumerate(key_path):
                        key_path[index] = item.encode(encoding=self.encoding)

                error_msg = f"Expected key path was '{expected_path}' but event key path is '{key_path}'"
                assert (expected_path in key_path), error_msg

        def check_events_registry_value(events, key, value_list=['testvalue0'], mode=None):
            """Checks the path for a registry_value event in a list.

            Args:
                events (list): event list to be checked.
                key (str): path to the key being checked where the value has been added.
                value_list (list, optional): list of values that are being checked.
                mode(str, optional): defines the type of FIM monitoring mode configured
            """
            mode = global_parameters.current_configuration['metadata']['fim_mode'] if mode is None else mode
            key_path = filter_events(events, ".[].data.path")
            value_name = filter_events(events, ".[].data.value_name")

            for value in value_list:
                error_msg = f"Expected value name was '{value}' but event value name is '{value_name}'"
                assert (value in value_name), error_msg

                error_msg = f"Expected key path was '{key}' but event key path is '{key_path}'"
                assert (key in key_path), error_msg

        def filter_events(events, mask):
            """Returns a list of elements matching a specified mask in the events list using jq module.

            Args:
                events (list): event list to be checked.
                mask(str): mask to be used to check events using jq module
            """
            if sys.platform in ("win32", 'sunos5', 'darwin'):
                stdout = subprocess.check_output(["jq", "-r", mask], input=json.dumps(events).encode())

                return stdout.decode("utf8").strip().split(os.linesep)
            else:
                return jq(mask).transform(events, multiple_output=True)

        if self.events is not None:
            validate_checkers_per_event(self.events, self.options, mode)

            if self.is_value:
                check_events_type(self.events, event_type, self.registry_dict)
                check_events_registry_value(self.events, self.registry_key, value_list=self.registry_dict,
                                            mode=mode)
            else:
                check_events_type(self.events, event_type, self.registry_dict)
                check_events_key_path(self.events, self.registry_key, reg_list=self.registry_dict, mode=mode)

            if self.custom_validator is not None:
                self.custom_validator.validate_after_cud(self.events)

                if event_type == "added":
                    self.custom_validator.validate_after_create(self.events)
                elif event_type == "modified":
                    self.custom_validator.validate_after_update(self.events)
                elif event_type == "deleted":
                    self.custom_validator.validate_after_delete(self.events)

    def _get_elem_list(self):
        """returns the elements in the registry_dict variable as a list"""
        result_list = []

        for elem_name in self.registry_dict:
            if elem_name in self.registry_key:
                continue

            expected_elem_path = os.path.join(self.registry_key, elem_name)
            result_list.append(expected_elem_path)

        return result_list
