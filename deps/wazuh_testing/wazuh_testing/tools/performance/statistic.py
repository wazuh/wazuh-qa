# Copyright (C) 2015-2021, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

import csv
import json
import logging
from datetime import datetime
from os.path import basename, isfile, join, splitext
from re import sub
from tempfile import gettempdir
from threading import Thread, Event
from time import sleep

import wazuh_testing.tools as tls

logger = logging.getLogger('wazuh-statistics-monitor')
logger.setLevel(logging.INFO)


class StatisticMonitor:
    """This class generates a Python object to monitor the statistics file generated by Wazuh.

    There are four files: wazuh-analysisd.state, wazuh-remoted.state, wazuh-agentd.state and wazuh-logcollector.state
    and each one of them has unique characteristics and data. This class will parse the file, extract the data to a
    Python dictionary and then create a CSV file.

    The statistics file for Logcollector has a different behavior. It's a JSON file showing statistic data from the
    start of the daemon and it also shows it for a fixed interval. Also

    Attributes:
        time_step (int): Time between intervals.
        target (str, optional): target file to monitor.
        dst_dir (str, optional): path to store the file.
    """

    def __init__(self, target='agent', time_step=5, dst_dir=gettempdir()):
        self.event = None
        self.thread = None
        self.time_step = time_step
        self.target = target
        self.dst_dir = dst_dir
        self.parse_json = False

        if self.target == 'agent':
            self.statistics_file = tls.AGENT_STATISTICS_FILE
        elif self.target == 'logcollector':
            self.statistics_file = tls.LOGCOLLECTOR_STATISTICS_FILE
            self.parse_json = True
        elif self.target == 'remote':
            self.statistics_file = tls.REMOTE_STATISTICS_FILE
        elif self.target == 'analysis':
            self.statistics_file = tls.ANALYSIS_STATISTICS_FILE
        else:
            raise ValueError(f'The target {self.target} is not a valid one.')

        state_file = splitext(basename(self.statistics_file))[0]
        self.csv_file = join(self.dst_dir, f'{state_file}.csv')

    def _parse_classic_state_file(self, data):
        """Parse the info from the .state files from Wazuh with shell compatible format

        Args:
            data (dict): dictionary to store the data of the file
        """
        with open(self.statistics_file) as state_file:
            for line in state_file:
                if line.rstrip() and line.rstrip()[0] != '#':
                    key, value = line.splitlines()[0].split('=')
                    data[key] = value.split("'")[1]

        self._write_csv(data, self.csv_file)

    def _parse_logcollector_state_file(self, data):
        """Parse the info from the .state files from Wazuh with shell compatible format

        Args:
            data (dict): dictionary to store the data of the file
        """
        with open(self.statistics_file) as state_file:
            state_info = json.load(state_file)

        for file in state_info['global']['files']:
            if isfile(file['location']):
                csv_name = sub(r'\.', '_', basename(file['location']))
            else:
                csv_name = file['location'].split(' ')[0]

            file_data = data
            for target in file['targets']:
                file_data['location'] = file['location']
                file_data['events'] = file['events']
                file_data['bytes'] = file['bytes']
                file_data['target'] = target['name']
                file_data['target_drops'] = target['drops']
                self._write_csv(file_data, join(self.dst_dir, f'{csv_name}.csv'))

    def _parse_state_file(self):
        """Read the data from the statistics file generated by Wazuh"""
        try:
            logging.info("Getting statistics data from {}".format(self.statistics_file))
            data = {'Timestamp': datetime.now().strftime('%H:%M:%S')}
            if not self.parse_json:
                self._parse_classic_state_file(data)
            else:
                self._parse_logcollector_state_file(data)
        except Exception as e:
            logger.error(f'Exception with {self.statistics_file} | {str(e)}')

    @staticmethod
    def _write_csv(data, csv_file):
        """Write the data collected from the .state into a CSV file

        Args:
            data (dict): dictionary containing the info from the .state file.
            csv_file (string): path to the CSV file.
        """
        header = not isfile(csv_file)
        with open(csv_file, 'a', newline='') as f:
            csv_writer = csv.writer(f)
            if header:
                csv_writer.writerow(list(data))

            csv_writer.writerow(list(data.values()))
        logger.debug(f'Added new entry in {csv_file}')

    def _monitor_stats(self):
        """Read the .state files and log the data into a CSV file"""
        while not self.event.is_set():
            self._parse_state_file()
            sleep(self.time_step)

    def run(self):
        self.event = Event()
        self.thread = Thread(target=self._monitor_stats)
        self.thread.start()

    def start(self):
        self.run()
        logger.info(f'Started monitoring statistics from {self.statistics_file}')

    def shutdown(self):
        self.event.set()
        self.thread.join()
