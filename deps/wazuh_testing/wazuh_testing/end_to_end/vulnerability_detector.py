"""
Vulnerability detector module.
-------------------------


Functions:
    - load_packages_metadata: Load packages metadata from the packages.json file.
    - get_vulnerability_detector_alerts: Parse vulnerability detector alerts index.
    - parse_vulnerabilities_from_alerts: Parse vulnerabilities from the vulnerability detector alerts.
    - parse_vulnerabilities_from_states: Parse vulnerabilities from the vulnerability state index.
    - get_vulnerabilities_from_alerts_by_agent: Get vulnerabilities from the alerts by agent.


Copyright (C) 2015, Wazuh Inc.
Created by Wazuh, Inc. <info@wazuh.com>.
This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2
"""
import logging
import re
import os
import json
from typing import Dict, List

from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.indexer_api import get_indexer_values, create_vulnerability_states_indexer_filter, \
    create_alerts_filter, get_wazuh_states_vulnerabilities_indexname
from wazuh_testing.end_to_end.regex import REGEX_PATTERNS
from collections import namedtuple


PACKAGE_VULNERABILITY_SCAN_TIME = 160
TIMEOUT_PER_AGENT_VULNERABILITY_FIRST_SCAN = 240

Vulnerability = namedtuple('Vulnerability', ['cve', 'package_name', 'package_version', 'architecture'])


def normalize_architecture(architecture: str) -> str:
    if architecture == 'amd64':
        architecture = 'x86_64'
    elif architecture == 'aarch64':
        architecture = 'arm64'

    return architecture


def load_packages_metadata() -> Dict:
    """
    Load packages metadata from the packages.json file.

    Returns:
        dict: Dictionary containing the packages metadata.

    Example of packages.json:
      "vlc-3.0.11": {
        "package_name": "VLC media player",
        "package_version": "3.0.11",
        "CVE": [
          "CVE-2021-25804",
          "CVE-2021-25803",
          "CVE-2021-25802",
          "CVE-2021-25801",
          "CVE-2020-26664"
        ],
        "url": {
          "windows": {
            "amd64": "https://get.videolan.org/vlc/3.0.11/win64/vlc-3.0.11-win64.exe"
          }
        },
        "uninstall_custom_playbook": "remove_vlc_win.yml"
      },
    """
    packages_filepath = os.path.join(os.path.dirname(__file__),
                                     'vulnerability_detector_packages', 'vuln_packages.json')

    with open(packages_filepath, 'r') as packages_file:
        packages_data = json.load(packages_file)

    return packages_data


def get_vulnerability_detector_alerts(alerts: List) -> Dict:
    """Filter vulnerability detector alerts from alert index list.

    Args:
        alerts (list): List of alerts index.

    Example of alerts:
    [
             {
            "_index":"wazuh-alerts-4.x-2024.04.22",
            "_id":"YqpJBY8BJodbzcVedMR2",
            "_score":4.6972857,
            ...
               "data":{
                  "vulnerability":{
                     "severity":"Medium",
                     "package":{
                        "condition":"Package less than 0.7.0",
                        "name":"http-proxy",
                        "source":" ",
                        "version":"0.5.9",
                        "architecture":" "
                     },
                     ...
                  }
               },
               "rule":{
               ...
                  "description":"CVE-2017-16014 affects http-proxy",
                  ...
               "timestamp":"2024-04-22T10:10:45.737+0000"
            }
         }
      ]]

    Returns:
        dict: Dictionary containing the alerts by agent.

    Example of return value:
    {
        'affected': [{ "_index":"wazuh-alerts-4.x-2024.04.22",
                         "_id":"YqpJBY8BJodbzcVedMR2", "_score":4.6972857, ... }]
        'mitigated': []
    }
    """
    vulnerability_detector_alerts = {}
    vulnerability_detector_alerts['affected'] = []
    vulnerability_detector_alerts['mitigated'] = []

    vuln_affected_regex = REGEX_PATTERNS['vuln_affected']['regex']
    vuln_mitigated_regex = REGEX_PATTERNS['vuln_mitigated']['regex']

    for alert in alerts:
        if re.match(vuln_affected_regex, alert['_source']['rule']['description']):
            vulnerability_detector_alerts['affected'].append(alert)
        elif re.match(vuln_mitigated_regex, alert['_source']['rule']['description']):
            vulnerability_detector_alerts['mitigated'].append(alert)

    return vulnerability_detector_alerts


def parse_vulnerabilities_from_alerts(vulnerabilities_alerts: List) -> List:
    """Parse vulnerabilities from the vulnerability detector alerts.

    Args:
        vulnerabilities_alerts (list): List of vulnerabilities from the vulnerability detector alerts.

    Example of vulnerabilities_alerts:
    [
        {
            "_index":"wazuh-alerts-4.x-2024.04.22",
            "_id":"YqpJBY8BJodbzcVedMR2",
            "_score":4.6972857,
            ...
               "data":{
                  "vulnerability":{
                     "severity":"Medium",
                     "package":{
                        "condition":"Package less than 0.7.0",
                        "name":"http-proxy",
                        "source":" ",
                        "version":"0.5.9",
                        "architecture":" "
                     },
                     ...
                  }
               },
            ...
        }
    ]

    Returns:
        list: List of vulnerabilities sorted by cve, package_name, package_version, and architecture.

    Example of return value:
    [
        Vulnerability(cve='CVE-2021-25804', package_name='http-proxy', package_version='0.5.9', architecture=''),
    ]
    """
    def parse_vulnerability_from_alert(alert):
        vulnerability_data = alert.get('_source', {}).get('data', {}).get('vulnerability', {})
        package_data = vulnerability_data.get('package', {})
        architecture = normalize_architecture(package_data.get('architecture', ''))

        vulnerability = Vulnerability(
            cve=vulnerability_data.get('cve', '').rstrip(),
            package_name=package_data.get('name', '').rstrip(),
            package_version=package_data.get('version', '').rstrip(),
            architecture=architecture.rstrip()
        )

        return vulnerability

    vulnerabilities = []

    for alert in vulnerabilities_alerts:
        try:
            vulnerability = parse_vulnerability_from_alert(alert)
            vulnerabilities.append(vulnerability)

        except KeyError as e:
            logging.error(f"Error parsing vulnerability: {alert}: {str(e)}")
            raise e

    vulnerabilities = sorted(vulnerabilities, key=lambda x: (x.cve, x.package_name, x.package_version, x.architecture))

    return vulnerabilities


def parse_vulnerabilities_from_states(vulnerabilities_states: List) -> List:
    """Parse vulnerabilities from the vulnerability state index.

    Args:
        vulnerabilities_states (list): List of vulnerabilities from the vulnerability state index.

    Example of vulnerabilities_states:
    [
        {
            "_index":"wazuh-vulnerabilities-4.x-2024.04.22",
            "_id":"YqpJBY8BJodbzcVedMR2",
            "_score":4.6972857,
            ...
               "data":{
                  "vulnerability":{
                     "severity":"Medium",
                     "package":{
                        "condition":"Package less than 0.7.0",
                        "name":"http-proxy",
                        "source":" ",
                        "version":"0.5.9",
                        "architecture":" "
                     },
                     ...
                  }
            }
        }
    ]

    Returns:
        list: List of vulnerabilities sorted by cve, package_name, package_version, and architecture.

    Example of return value:
    [
        Vulnerability(cve='CVE-2021-25804', package_name='http-proxy', package_version='0.5.9', architecture=''),
    ]
    """
    def parse_vulnerability_from_state(state):
        source_data = state.get('_source', {})
        package_data = source_data.get('package', {})
        vulnerability_data = source_data.get('vulnerability', {})
        architecture = normalize_architecture(package_data.get('architecture', ''))

        vulnerability = Vulnerability(
            cve=vulnerability_data.get('id', ''),
            package_name=package_data.get('name', ''),
            package_version=package_data.get('version', ''),
            architecture=architecture
        )

        return vulnerability

    vulnerabilities = []

    for state_vulnerability in vulnerabilities_states:
        try:
            vulnerability = parse_vulnerability_from_state(state_vulnerability)
            vulnerabilities.append(vulnerability)
        except KeyError as e:
            logging.error(f"Error parsing vulnerability: {state_vulnerability}: {str(e)}")
            raise e

    vulnerabilities = sorted(vulnerabilities, key=lambda x: (x.cve, x.package_name, x.package_version, x.architecture))

    return vulnerabilities


def get_vulnerabilities_from_states_by_agent(host_manager: HostManager, agents: List[str],
                                             greater_than_timestamp: str = None, cluster_name='wazuh') -> dict:
    """Get vulnerabilities from the vulnerability state index by agent.

    Args:
        host_manager (HostManager): Host manager object.
        agents (list): List of agents.
        greater_than_timestamp (str, optional): Greater than timestamp. Defaults to None.

    Returns:
        dict: Dictionary of vulnerabilities by agent.

    Example of return value:
    {
        'agent1': [
            Vulnerability(cve='CVE-2021-25804', package_name='http-proxy', package_version='0.5.9', architecture=''),
        ],
        'agent2': [
            Vulnerability(cve='CVE-2021-25804', package_name='http-proxy', package_version='0.5.9', architecture=''),
        ],
    }
    """
    vuln_by_agent_index = {}
    indexer_user, indexer_password = host_manager.get_indexer_credentials()

    for agent in agents:
        agent_all_vulnerabilities = []
        try:
            index = get_wazuh_states_vulnerabilities_indexname(cluster_name)
            states_filter = create_vulnerability_states_indexer_filter(target_agent=agent,
                                                                       greater_than_timestamp=greater_than_timestamp)
            agent_all_vulnerabilities = get_indexer_values(host_manager,
                                                           filter=states_filter,
                                                           index=index,
                                                           credentials={'user': indexer_user,
                                                                        'password': indexer_password}
                                                           )['hits']['hits']
        except KeyError as e:
            logging.error(f"No vulnerabilities were obtained for {agent}. Exception {str(e)}")

        vuln_by_agent_index[agent] = parse_vulnerabilities_from_states(agent_all_vulnerabilities)

    return vuln_by_agent_index


def get_vulnerabilities_from_alerts_by_agent(host_manager: HostManager, agents: List[str], greater_than_timestamp: str):
    """Get vulnerabilities from the vulnerability alert index by agent.

    Args:
        host_manager (HostManager): Host manager object.
        agents (list): List of agents.
        greater_than_timestamp (str, optional): Greater than timestamp. Defaults to None.

    Returns:
        dict: Dictionary of vulnerabilities by agent.

    Example of return value:
    {
        'agent1': [
            Vulnerability(cve='CVE-2021-25804', package_name='http-proxy', package_version='0.5.9', architecture=''),
        ],
        'agent2': [
            Vulnerability(cve='CVE-2021-25804', package_name='http-proxy', package_version='0.5.9', architecture=''),
        ],
    }
    """
    vuln_by_agent_index = {
        'mitigated': {},
        'affected': {}
    }
    indexer_user, indexer_password = host_manager.get_indexer_credentials()

    for agent in agents:
        agent_all_vulnerabilities = []
        try:
            alerts_filter = create_alerts_filter(target_agent=agent, greater_than_timestamp=greater_than_timestamp)
            vuln_by_agent_index['mitigated'][agent] = []
            agent_all_alerts = get_indexer_values(host_manager,
                                                  filter=alerts_filter,
                                                  credentials={'user': indexer_user,
                                                               'password': indexer_password})['hits']['hits']
            agent_all_vulnerabilities = get_vulnerability_detector_alerts(agent_all_alerts)
            parsed_vulnerabilities_mitigated = parse_vulnerabilities_from_alerts(agent_all_vulnerabilities['mitigated'])
            parsed_vulnerabilities_affected = parse_vulnerabilities_from_alerts(agent_all_vulnerabilities['affected'])

            vuln_by_agent_index['mitigated'][agent] = parsed_vulnerabilities_mitigated
            vuln_by_agent_index['affected'][agent] = parsed_vulnerabilities_affected

        except KeyError as e:
            logging.error(f"No vulnerabilities were obtained for {agent}. Exception {str(e)}")

    return vuln_by_agent_index
