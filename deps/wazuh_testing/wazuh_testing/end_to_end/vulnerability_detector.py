"""
Vulnerability detector module.
-------------------------


Functions:
    - load_packages_metadata: Load packages metadata from the packages.json file.
    - check_vuln_state_index: Check vulnerability state index for a host.
    - get_indexed_vulnerabilities_by_agent: Get indexed vulnerabilities by agent.
    - check_vuln_alert_indexer: Check vulnerability alerts in the indexer for a host.
    - parse_vulnerability_detector_alerts: Parse vulnerability detector alerts.
    - check_vuln_state_consistency: Check vulnerability state consistency.


Copyright (C) 2015, Wazuh Inc.
Created by Wazuh, Inc. <info@wazuh.com>.
This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2
"""
import logging
import re
import os
import json
from typing import Dict, List

from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.indexer_api import get_indexer_values
from wazuh_testing.end_to_end.regex import REGEX_PATTERNS


def load_packages_metadata() -> Dict:
    """
    Load packages metadata from the packages.json file.

    Returns:
        dict: Dictionary containing the packages metadata.

    Example of packages.json:
      "vlc-3.0.11": {
        "package_name": "VLC media player",
        "package_version": "3.0.11",
        "CVE": [
          "CVE-2021-25804",
          "CVE-2021-25803",
          "CVE-2021-25802",
          "CVE-2021-25801",
          "CVE-2020-26664"
        ],
        "url": {
          "windows": {
            "amd64": "https://get.videolan.org/vlc/3.0.11/win64/vlc-3.0.11-win64.exe"
          }
        },
        "uninstall_custom_playbook": "remove_vlc_win.yml"
      },
    """
    packages_filepath = os.path.join(os.path.dirname(__file__),
                                     'vulnerability_detector_packages', 'vuln_packages.json')

    with open(packages_filepath, 'r') as packages_file:
        packages_data = json.load(packages_file)

    return packages_data


def check_vuln_state_index(host_manager: HostManager, host: str, package: Dict[str, Dict],
                           current_datetime: str = "") -> List:
    """
    Check vulnerability state index for a host. This function checks if the vulnerability state index contains the
    expected vulnerabilities for a host. It returns a dictionary containing the expected alerts not found.

    Args:
        host_manager (HostManager): An instance of the HostManager class containing information about hosts.
        host (str): Host name.
        package (dict): Dictionary containing package data.
        current_datetime (str): Datetime to filter the vulnerability state index.
    """
    index_vuln_state_content = get_indexer_values(host_manager, index='wazuh-states-vulnerabilities',
                                                  greater_than_timestamp=current_datetime)['hits']['hits']
    expected_alerts_not_found = []

    logging.info(f"Checking vulnerability state index {package}")
    vulnerabilities = package['CVE']

    for vulnerability in vulnerabilities:
        found = False
        vulnerability_case = {
            'agent': host,
            'cve': vulnerability,
            'package_name': package['package_name'],
            'package_version': package['package_version']
        }

        for indice_vuln in index_vuln_state_content:
            state_agent = indice_vuln['_source']['agent']['name']
            state_cve = indice_vuln["_source"]['vulnerability']['id']
            state_package_name = indice_vuln['_source']['package']['name']
            state_package_version = indice_vuln['_source']['package']['version']

            if state_agent == host and state_cve == vulnerability \
                and state_package_name == package['package_name'] and \
                    state_package_version == package['package_version']:
                found = True
                break

        if not found:
            expected_alerts_not_found.append(vulnerability_case)

    return expected_alerts_not_found


def parse_vulnerability_detector_alerts(alerts) -> Dict:
    """
    Parse vulnerability detector alerts.

    Args:
        alerts (list): List of alerts.

    Returns:
        dict: Dictionary containing the alerts by agent.
    """
    vulnerability_detector_alerts = {}
    vulnerability_detector_alerts['affected'] = []
    vulnerability_detector_alerts['mitigated'] = []

    vuln_affected_regex = REGEX_PATTERNS['vuln_affected']['regex']
    vuln_mitigated_regex = REGEX_PATTERNS['vuln_mitigated']['regex']

    # Parse affected vuln alerts
    for alert in alerts:
        if re.match(vuln_affected_regex, alert['_source']['rule']['description']):
            vulnerability_detector_alerts['affected'].append(alert)
        elif re.match(vuln_mitigated_regex, alert['_source']['rule']['description']):
            vulnerability_detector_alerts['mitigated'].append(alert)

    return vulnerability_detector_alerts


def get_indexed_vulnerabilities_by_agent(indexed_vulnerabilities) -> Dict:
    """Get indexed vulnerabilities by agent.

    Args:
        indexed_vulnerabilities (dict): Dictionary containing the indexed vulnerabilities.

    Returns:
        dict: Dictionary containing the indexed vulnerabilities by agent.
    """
    vulnerabilities_by_agent = {}
    for vulnerabilities_state in indexed_vulnerabilities['hits']['hits']:
        if 'agent' in vulnerabilities_state['_source']:
            agent = vulnerabilities_state['_source']['agent']['name']
            if agent not in vulnerabilities_by_agent:
                vulnerabilities_by_agent[agent] = []

            vulnerabilities_by_agent[agent].append(vulnerabilities_state)

    return vulnerabilities_by_agent


def check_vuln_alert_indexer(vulnerabilities_alerts: Dict, host: str, package: Dict[str, Dict],
                             current_datetime: str = '') -> List:
    """
    Check vulnerability alerts in the indexer for a host.

    Args:
        vulnerabilities_alerts (Dict): Dictionary containing the indexed vulnerabilities by agent.
        host (str): Host name.
        package (dict): Dictionary containing package data.
        vuln_mitigated (bool): Indicates if the vulnerability is mitigated.
        vulnerability_data (dict): Dictionary containing vulnerability data.

    Returns:
        list: List of vulnerability alerts.
    """
    logging.info(f"Checking vulnerability alerts in the indexer {package}")

    # Get CVE affects alerts for all agents
    if host in vulnerabilities_alerts:
        triggered_alerts = vulnerabilities_alerts[host]
    else:
        triggered_alerts = []

    expected_alerts_not_found = []

    for cve in package['CVE']:
        logging.info(f"Checking vulnerability: {cve}")

        package_name = package['package_name']
        package_version = package['package_version']

        found = False

        for triggered_alert in triggered_alerts:
            alert_package_name = triggered_alert['_source']['data']['vulnerability']['package']["name"]
            alert_package_version = \
                triggered_alert['_source']['data']['vulnerability']['package']['version']
            alert_cve = triggered_alert['_source']['data']['vulnerability']['cve']

            if alert_cve == cve and alert_package_name == package_name and \
               alert_package_version == package_version:
                found = True
                break

        if not found:
            logging.info(f"Vulnerability not found: {cve} for package {package} {package_version}")
            expected_alerts_not_found.append({'CVE': cve, 'PACKAGE_NAME': package_name,
                                              'PACKAGE_VERSION': package_version})

    return expected_alerts_not_found


def check_vuln_state_consistency(vulnerabilities_alerts, vulnerabilities_states):
    # Get the indexer values
    alerts_vulnerabilities = {}
    indices_vulnerabilities = {}

    for agent, vuln_alerts in vulnerabilities_alerts.items():
        for vuln_alert in vuln_alerts:
            if agent != vuln_alert['_source']['agent']['name']:
                logging.critical("Agent name is not the same as the agent in the alert")
            alert_agent = vuln_alert['_source']['agent']['name']
            alert_cve = vuln_alert['_source']['data']['vulnerability']['cve']
            alert_package_version = vuln_alert['_source']['data']['vulnerability']['package']['version']
            alert_package_name = vuln_alert['_source']['data']['vulnerability']['package']['name']

            if agent not in alerts_vulnerabilities:
                alerts_vulnerabilities[agent] = []

            alerts_vulnerabilities[agent].append({
                'cve': alert_cve,
                'agent': alert_agent,
                'package_name': alert_package_name,
                'package_version': alert_package_version
            })

    for agent, vulnerabilities in vulnerabilities_states.items():
        for vulnerability in vulnerabilities:
            if agent != vulnerability['_source']['agent']['name']:
                logging.critical("Agent name is not the same as the agent in the vulnerability state")

            state_agent = vulnerability['_source']['agent']['name']
            state_cve = vulnerability['_source']['vulnerability']['id']
            state_package_name = vulnerability['_source']['package']['name']
            state_package_version = vulnerability['_source']['package']['version']

            if agent not in indices_vulnerabilities:
                indices_vulnerabilities[agent] = []

            indices_vulnerabilities[agent].append({
                'cve': state_cve,
                'agent': state_agent,
                'package_name': state_package_name,
                'package_version': state_package_version
            })

    if vulnerabilities_states.keys() != vulnerabilities_alerts.keys():
        logging.critical("The number of agents is not the same between alerts and states")

    agents_in_alerts_states = [agent for agent in vulnerabilities_states.keys() \
            if agent in vulnerabilities_alerts.keys()]

    alerts_not_in_states = []
    states_not_in_alerts = []

    for agent in agents_in_alerts_states:
        agent_alerts = [] if agent not in alerts_vulnerabilities else alerts_vulnerabilities[agent]
        agent_states = [] if agent not in indices_vulnerabilities else indices_vulnerabilities[agent]

        if len(agent_alerts) != len(agent_states):
            logging.critical(f"The number of alerts is not the same as the number of states for agent {agent}")
            logging.critical(f"Alerts: {len(agent_alerts)}")
            logging.critical(f"States: {len(agent_states)}")

        # Check that all alerts are in the index
        for alert in agent_alerts:
            if alert not in agent_states:
                alerts_not_in_states.append(alert)

        # Check that all index states are in the alerts
        for state in agent_states:
            if state not in agent_alerts:
                alerts_not_in_states.append(state)

    return {
        'alerts_not_in_states': alerts_not_in_states,
        'states_not_in_alerts': states_not_in_alerts
        }
