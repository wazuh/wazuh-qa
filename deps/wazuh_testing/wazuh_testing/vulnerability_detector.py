# Copyright (C) 2015-2021, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

import datetime
import functools
import json
import os
import random
import re
import sqlite3
from time import time, sleep

from wazuh_testing.tools import WAZUH_PATH, LOG_FILE_PATH, ALERT_FILE_PATH, GLOBAL_DB_PATH, CLIENT_KEYS_PATH
from wazuh_testing.tools import file
from wazuh_testing.tools import agent_simulator as ag
from wazuh_testing.tools.services import control_service, check_if_process_is_running
from wazuh_testing.tools.utils import retry
from wazuh_testing.wazuh_db import query_wdb

VULN_DETECTOR_GLOBAL_TIMEOUT = 20
VULN_DETECTOR_EXTENDED_GLOBAL_TIMEOUT = 60
VULN_DETECTOR_SCAN_TIMEOUT = 40
VULN_DETECTOR_BASELINE_SCAN_TIMEOUT = 90
DEBIAN_IMPORT_FEED_TIMEOUT = 50
DOWNLOAD_TIMEOUT = 140

DB_PATH = os.path.join(WAZUH_PATH, 'queue', 'db')
CVE_DB_PATH = os.path.join(WAZUH_PATH, 'queue', 'vulnerabilities', 'cve.db')
MSU_PATH = os.path.join(WAZUH_PATH, 'queue', 'vulnerabilities', 'dictionaries', 'msu.json.gz')
CPE_HELPER_PATH = os.path.join(WAZUH_PATH, 'queue', 'vulnerabilities', 'dictionaries', 'cpe_helper.json')
DEFAULT_PACKAGE_NAME = "wazuhintegrationpackage"
DEFAULT_VULNERABILITY_ID = "WVE-000"

MOCKED_AGENT_NAME = 'mocked_agent'
CVE_NUM_TABLES = 24

REAL_NVD_FEED = 'real_nvd_feed.json'
CUSTOM_NVD_FEED = 'custom_nvd_feed.json'
CUSTOM_REDHAT_JSON_FEED = 'custom_redhat_json_feed.json'
CUSTOM_REDHAT_OVAL_FEED = 'custom_redhat_oval_feed.xml'
CUSTOM_CANONICAL_OVAL_FEED = 'custom_canonical_oval_feed.xml'
CUSTOM_DEBIAN_OVAL_FEED = 'custom_debian_oval_feed.xml'
CUSTOM_DEBIAN_JSON_FEED = 'custom_debian_json_feed.json'
CUSTOM_NVD_VULNERABILITIES_1 = 'nvd_vulnerabilities_1.json'
CUSTOM_NVD_VULNERABILITIES_2 = 'nvd_vulnerabilities_2.json'
CUSTOM_MSU_JSON_FEED = 'custom_msu.json'
CUSTOM_ARCHLINUX_JSON_FEED = 'custom_archlinux_feed.json'
CUSTOM_ALAS_JSON_FEED = 'custom_alas_feed.json'
CUSTOM_ALAS2_JSON_FEED = 'custom_alas2_feed.json'
INVALID_RHEL_FEEDS_CONF = 'wazuh_invalid_redhat_feed.yaml'
INVALID_CANONICAL_FEEDS_CONF = 'wazuh_invalid_canonical_feed.yaml'
INVALID_ARCHLINUX_FEEDS_CONF = 'wazuh_invalid_archlinux_feed.yaml'
INVALID_DEBIAN_FEEDS_CONF = 'wazuh_invalid_debian_feed.yaml'
INVALID_MSU_FEEDS_CONF = 'wazuh_invalid_msu_feed.yaml'
INVALID_ALAS_FEEDS_CONF = 'wazuh_invalid_alas_feed.yaml'
INVALID_ALAS2_FEEDS_CONF = 'wazuh_invalid_alas2_feed.yaml'

REDHAT_NUM_CUSTOM_VULNERABILITIES = 1
CANONICAL_NUM_CUSTOM_VULNERABILITIES = 1
DEBIAN_NUM_CUSTOM_VULNERABILITIES = 3
NVD_NUM_CUSTOM_VULNERABILITIES = 5
ARCH_NUM_CUSTOM_VULNERABILITIES = 50
ALAS_NUM_CUSTOM_VULNERABILITIES = 36
ALAS2_NUM_CUSTOM_VULNERABILITIES = 18

SYSTEM_DATA = {
    'WINDOWS10': {'target': 'WINDOWS10', 'os_name': 'Microsoft Windows Server 2016 Datacenter Evaluation',
                  'os_major': '10', 'os_minor': '0', 'os_platform': 'windows', 'name': 'windows', 'format': 'win'},
    'MAC': {'target': 'MAC', 'os_name': 'Mac OS X', 'os_major': '10', 'os_minor': '15', 'os_platform': 'darwin',
            'name': 'macos-catalina', 'format': 'pkg'},
    'MACS': {'target': 'MAC', 'os_name': 'Mac OS X Server', 'os_major': '5', 'os_minor': '10', 'os_platform': 'darwin',
             "name": "macos-server", 'format': 'pkg'},
    'ARCH': {'target': 'ARCH', 'os_name': 'Arch Linux', 'os_major': '', 'os_minor': '', 'os_platform': '',
             'name': 'archlinux', 'format': 'rpm'},
    'ALAS': {'target': 'Amazon-Linux', 'os_name': 'Amazon Linux AMI', 'os_major': '2018', 'os_minor': '03',
             'os_platform': 'amzn', 'name': 'amazonlinux', 'format': 'rpm'},
    'ALAS2': {'target': 'Amazon-Linux-2', 'os_name': 'Amazon Linux', 'os_major': '2', 'os_minor': '',
              'os_platform': 'amzn', 'name': 'amazonlinux2', 'format': 'rpm'},
    'RHEL8': {'target': 'RHEL8', 'os_name': 'CentOS Linux', 'os_major': '8', 'os_minor': '1', 'os_platform': 'centos',
              'name': 'centos8', 'format': 'rpm'},
    'RHEL7': {'target': 'RHEL7', 'os_name': 'CentOS Linux', 'os_major': '7', 'os_minor': '1', 'os_platform': 'centos',
              'name': 'centos7', 'format': 'rpm'},
    'RHEL6': {'target': 'RHEL6', 'os_name': 'CentOS Linux', 'os_major': '6', 'os_minor': '1', 'os_platform': 'centos',
              'name': 'centos6', 'format': 'rpm'},
    'RHEL5': {'target': 'RHEL5', 'os_name': 'CentOS Linux', 'os_major': '5', 'os_minor': '1', 'os_platform': 'centos',
              'name': 'centos5', 'format': 'rpm'},
    'BIONIC': {'target': 'BIONIC', 'os_name': 'Ubuntu', 'os_major': '18', 'os_minor': '04', 'os_platform': 'ubuntu',
               'name': 'Ubuntu-bionic', 'format': 'deb'},
    'XENIAL': {'target': 'XENIAL', 'os_name': 'Ubuntu', 'os_major': '16', 'os_minor': '04', 'os_platform': 'ubuntu',
               'name': 'Ubuntu-xenial', 'format': 'deb'},
    'TRUSTY': {'target': 'TRUSTY', 'os_name': 'Ubuntu', 'os_major': '14', 'os_minor': '04', 'os_platform': 'ubuntu',
               'name': 'Ubuntu-trusty', 'format': 'deb'},
    'BUSTER': {'target': 'BUSTER', 'os_name': 'Debian GNU/Linux', 'os_major': '10', 'os_minor': '0',
               'os_platform': 'debian', 'name': 'debian10', 'format': 'deb'},
    'STRETCH': {'target': 'STRETCH', 'os_name': 'Debian GNU/Linux', 'os_major': '9', 'os_minor': '0',
                'os_platform': 'debian', 'name': 'debian9', 'format': 'deb'}
}

VENDOR = {
    'RHEL8': 'Red Hat, Inc.',
    'RHEL7': 'Red Hat, Inc.',
    'RHEL6': 'Red Hat, Inc.',
    'RHEL5': 'Red Hat, Inc.',
    'BIONIC': 'canonical',
    'XENIAL': 'canonical',
    'TRUSTY': 'canonical',
    'BUSTER': 'debian',
    'STRETCH': 'debian',
    'Amazon-Linux': 'Amazon.com',
    'Amazon-Linux-2': 'Amazon.com',
    'ARCH': 'Arch Linux',
}

NVD_LOG = 'National Vulnerability Database'
REDHAT_LOG = 'Red Hat Enterprise Linux'
BIONIC_LOG = 'Ubuntu Bionic'
ARCH_LOG = 'Arch Linux'
ALAS_LOG = 'Amazon Linux 1'
ALAS2_LOG = 'Amazon Linux 2'
BUSTER_LOG = 'Debian Buster'
MSU_LOG = 'Microsoft Security Update'
CUSTOM_MSU = 'custom_msu.json'
CUSTOM_CPE_HELPER = 'custom_cpe_helper.json'
VULNERABILITIES = 'vulnerabilities.json'

NVD_TABLES = [
    {'name': 'NVD_REFERENCE', 'path': CVE_DB_PATH},
    {'name': 'NVD_METRIC_CVSS', 'path': CVE_DB_PATH},
    {'name': 'NVD_METADATA', 'path': CVE_DB_PATH},
    {'name': 'NVD_CVE_MATCH', 'path': CVE_DB_PATH},
    {'name': 'NVD_CVE_CONFIGURATION', 'path': CVE_DB_PATH},
    {'name': 'NVD_CVE', 'path': CVE_DB_PATH},
    {'name': 'NVD_CPE', 'path': CVE_DB_PATH},
]

REDHAT_KEY_FIELDS_FEEDS = ['CVE', 'bugzilla_description', 'affected_packages']

XML_FEED_NAMESPACES = [
    {'name': '', 'url': 'http://oval.mitre.org/XMLSchema/oval-definitions-5'},
    {'name': 'ind-def', 'url': 'http://oval.mitre.org/XMLSchema/oval-definitions-5#independent'},
    {'name': 'oval', 'url': 'http://oval.mitre.org/XMLSchema/oval-common-5'},
    {'name': 'unix-def', 'url': 'http://oval.mitre.org/XMLSchema/oval-definitions-5#unix'},
    {'name': 'linux-def', 'url': 'http://oval.mitre.org/XMLSchema/oval-definitions-5#linux'}
]

VULNERABILITY_DETECTOR_PREFIX = r'.*wazuh-modulesd:vulnerability-detector.*'
VULNERABILITY_DETECTOR_ALERT_PREFIX = r'^vulnerability.*'

# Test data variables
EXTRA_TEST_DATA = [[1, 2, 3], {'a': 1, 'b': 2}, 'extra_tag', 12345, 'ñ', 'テスト', 'ИСПЫТАНИЕ', '测试', 'اختبار', ' ', '']
EXTRA_TEST_VALUES = [(tag, value) for tag in EXTRA_TEST_DATA for value in EXTRA_TEST_DATA]
EXTRA_TEST_IDS = [f"tag: {value[0]}, value: {value[1]}" for value in EXTRA_TEST_VALUES]

TEST_CHARACTERS = ['.', ':', '@', '#', '*', '-', '_', "'", '"', '/', '=', 'ñ', 'ç', '+', '^', '!', '?', '%', '&', '`',
                   '¿', '?', '(', ')', '|', 'º', '$', '½', '¬', '!', '~', '¡', '[', ']', '{', '}']

CUSTOM_INPUT_TEST_VALUES = [None, '', 'dummy value', 12345, ['1', '2', '3', '4', '5'], 'ñ', 'テスト', 'ИСПЫТАНИЕ', '测试',
                            'اختبار']


def mock_cve_db(func):
    """Decorator used in any function that needs to mock cve.db

    This function will execute `func` after stopping wazuh-modulesd and wazuh-db and cleaning the db. After that,
    it will start the daemons again, clean the logs, etc.

    Args:
         func (callable): function that will mock the cve.db

    Example:
        @vd.mock_cve_db
        def mock_vulnerability_scan(request, mock_agent):
    """

    @functools.wraps(func)
    def magic(*args, **kwargs):
        control_service('stop', daemon='wazuh-modulesd')

        # Clean tables
        clean_vd_tables(agent=kwargs['mock_agent'])

        func(*args, **kwargs)

        # Truncate the log file
        file.truncate_file(LOG_FILE_PATH)

        # Truncate the alerts log file
        file.truncate_file(ALERT_FILE_PATH)

        control_service('start', daemon='wazuh-modulesd')

        yield kwargs['request'].param

        clean_vuln_and_sys_programs_tables(agent=kwargs['mock_agent'])

    return magic


def callback_detect_vulnerability_scan_sleeping(line):
    msg = rf"{VULNERABILITY_DETECTOR_PREFIX} Sleeping for (.*)..."
    match = re.match(msg, line)

    return match.group(1) if match is not None else ""


def callback_detect_vulnerability_detector_disabled(line):
    msg = rf"{VULNERABILITY_DETECTOR_PREFIX}DEBUG: Module disabled. Exiting..."
    match = re.match(msg, line)

    return match is not None


def callback_detect_vulnerability_detector_enabled(line):
    msg = r'(.*)wazuh-modulesd:vulnerability-detector(.*)'
    match1 = re.match(msg, line)
    msg = r'(.*)DEBUG: Module disabled. Exiting...(.*)'
    match2 = re.match(msg, line)

    return match1 is not None and match2 is None


def make_vuln_callback(pattern, prefix=VULNERABILITY_DETECTOR_PREFIX):
    """Creates a callback function from a text pattern.

    It already contains the vulnerability-detector prefix.

    Args:
        pattern (str): String to match on the log
        prefix (str): regular expression used as prefix before the pattern.

    Returns:
        lambda: function that returns if there's a match in the file

    Examples:
        >>> callback_bionic_update_started = make_vuln_callback("Starting Ubuntu Bionic database update")
    """
    pattern = r'\s+'.join(pattern.split())
    regex = re.compile(r'{}{}'.format(prefix, pattern))

    return lambda line: regex.match(line) is not None


def load_db(db_path):
    """Load a database in db_path

    Args:
        db_path (str): path to the database
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    return conn, cursor


def make_query(db_path, query_list):
    """Makes a query to the database in db_path for each item in query_list

    Args:
        db_path (string): Path where is located the DB.
        query_list (list): List with queries to run.
    """
    connect = sqlite3.connect(db_path)

    try:
        with connect:
            for item in query_list:
                connect.execute(item)
    finally:
        connect.close()


def get_query_result(db_path, query):
    """Return the result of a query in a specified DB

    Args:
        db_path (str): path to the database
        query (str): SQL query. (SELECT * ..)

    Returns:
        result (List[list]): each row is the query result row and each column is the query field value
    """
    try:
        db, cursor = load_db(db_path)
        cursor.execute(query)
        records = cursor.fetchall()
        result = []

        for row in records:
            result.append(', '.join([f"{item}" for item in row]))

        return result

    finally:
        cursor.close()
        db.close()


def clean_table(db_path, table):
    """Deletes all entries in a table of a database.

    Args:
        db_path (str): path to the database
        table (str): table from the DB
    """
    query_string = f"DELETE FROM {table}"
    make_query(db_path, [query_string])


def clean_table_wazuh_db(agent, table):
    """Deletes all entries in a table of a database.

    Args:
        db_path (str): path to the database
        table (str): table from the DB
    """
    query_string = f"agent {agent} sql DELETE FROM {table}"
    query_wdb(query_string)


def clean_vd_tables(agent="000"):
    """Clean the tables involved with vulnerability detector packages and feeds

    Args:
        agent (str): id of the agent
    """
    tables = [
        {'name': 'sys_programs', 'path': os.path.join(DB_PATH, f"{agent}.db")},
        {'name': 'sys_hotfixes', 'path': os.path.join(DB_PATH, f"{agent}.db")},
        {'name': 'sys_osinfo', 'path': os.path.join(DB_PATH, f"{agent}.db")},
        {'name': 'vulnerabilities', 'path': CVE_DB_PATH},
        {'name': 'vulnerabilities_info', 'path': CVE_DB_PATH},
        {'name': 'references_info', 'path': CVE_DB_PATH},
        {'name': 'bugzilla_references_info', 'path': CVE_DB_PATH},
        {'name': 'advisories_info', 'path': CVE_DB_PATH},
        {'name': 'metadata', 'path': CVE_DB_PATH},
        {'name': 'variables', 'path': CVE_DB_PATH}
    ]

    tables_wazuh_db = [
        {"name": "sys_programs"},
        {"name": "sys_hotfixes"},
        {"name": "sys_osinfo"}
    ]

    # Clean tables in Wazuh-DB
    for item in tables_wazuh_db:
        try:
            clean_table_wazuh_db(agent, item['name'])
        except sqlite3.OperationalError:
            pass

    # Clean providers and sys_programs tables
    for item in tables:
        try:
            clean_table(item['path'], item['name'])
        except sqlite3.OperationalError:
            pass

    # Clean NVD tables
    for item in NVD_TABLES:
        try:
            clean_table(item['path'], item['name'])
        except sqlite3.OperationalError:
            pass


def update_last_full_scan(last_scan=0, agent="000"):
    """Changes the value of the last scan of an agent.

    Args:
        last_scan (int): id of the last scan. This is compute by casting to int the result of time()
        agent (str): id of the agent
    """

    query_string = f"agent {agent} sql UPDATE vuln_metadata SET LAST_FULL_SCAN={last_scan}"
    query_wdb(query_string)


def insert_hotfix(agent='000', scan_id=int(time()), scan_time=datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S"),
                  hotfix='000000', checksum='dummychecksum'):
    """Changes the value of the last scan of an agent.

    Args:
        agent (str): id of the agent
        scan_id (int): id of the last scan
        scan_time (str): date of the scan with this format "%Y/%m/%d %H:%M:%S"
        hotfix (str): id representing the hotfix value
        checksum (str): checksum of the hotfix
    """
    query_string = f'''agent {agent} sql INSERT INTO sys_hotfixes
        (scan_id, scan_time, hotfix, checksum)
        VALUES
        ({scan_id}, "{scan_time}", "{hotfix}", "{checksum}")
        '''
    query_wdb(query_string)

def insert_osinfo(agent='000', scan_id=int(time()), scan_time=datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S"),
                  hostname='WINDOWS', architecture='x86_64',
                  os_name='Microsoft Windows Server 2016 Datacenter Evaluation',
                  os_version='10.0.14393', os_major='10', os_minor='0', os_build='14393', version='6.2',
                  os_release='1607', os_patch='0', release='0.0.0', checksum='dummychecksum'):
    """Changes the value of the last scan of an agent.

    Args:
        agent (str): id of the agent
        scan_id (int): id of the last scan
        scan_time (str): date of the scan with this format "%Y/%m/%d %H:%M:%S"
        hostname (str): name of the host
        architecture (str): architecture of the host
        os_name (str): complete name of the OS
        os_version (str): version of the OS
        os_major (str): major version of the OS
        os_minor (str): minor version of the OS
        os_build (str): build id of the OS
        version (str): version of the OS
        os_release (str): release of the OS
        os_patch (str): current patch of the OS
        release (str): release of the OS
        checksum (str): checksum of the OS
    """

    query_string = f'''agent {agent} sql INSERT OR REPLACE INTO sys_osinfo
        (scan_id, scan_time, hostname, architecture, os_name, os_version, os_major, os_minor, os_patch, os_build,
        release, version, os_release, checksum)
        VALUES
        ("{scan_id}", "{scan_time}", "{hostname}", "{architecture}", "{os_name}", "{os_version}", "{os_major}",
        "{os_minor}", "{os_patch}", "{os_build}", "{release}", "{version}", "{os_release}", "{checksum}")
        '''

    query_wdb(query_string)



def insert_package(agent='000', scan_id=int(time()), format='rpm', name=DEFAULT_PACKAGE_NAME,
                   priority='', section='Unspecified', size=99, vendor='wazuhintegrationtests', version='1.0.0-1.el7',
                   architecture='x86_64', multiarch='', description='Wazuh Integration tests mock package',
                   source='Wazuh Integration tests mock package', location='', triaged=0,
                   install_time=datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S"),
                   scan_time=datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S"), checksum="dummychecksum",
                   item_id="dummyitemid"):
    """Insert a new package in the installed package database, with the parameters given as arguments.

    If used in conjunction with ``insert_vulnerability`` using the default arguments it will generate an alert.

    Args:
        agent (str): id of the agent
        scan_id (int): id of the last scan
        format (str): format of the package. It may be rpm, deb, etc
        name (str): name of the package. Defaults to wazuhintegrationpackage
        priority (str): priority of the released package
        section (str): section of the package
        size (int): size of the package
        vendor (str): vendor of the package. Defaults to wazuhintegrationtests
        version (str): version of the package.
        architecture (str): architecture of the package
        multiarch (str): defines if a package may be installed in different architectures.
        description (str): description of the package
        source (str): source of the package
        location (str): location of the package
        triaged (int): times installed
        install_time (str): timestamp containing the installation time
        scan_time (str): timestamp of the scan
        checksum (str): checksum of the package
        item_id (str): id of the package
    """
    arguments = locals()
    for key, value in arguments.items():
        if type(value) is str:
            if value != 'NULL':
                arguments[key] = f"'{value}'"

    query_wdb(f"agent {agent} sql INSERT INTO sys_programs (scan_id, scan_time, format, name, priority, section, size,"
              f"vendor, install_time, version, architecture, multiarch, source, description, location, triaged,"
              f"checksum, item_id) VALUES ({arguments['scan_id']}, {arguments['scan_time']}, {arguments['format']},"
              f"{arguments['name']}, {arguments['priority']}, {arguments['section']}, {arguments['size']},"
              f"{arguments['vendor']}, {arguments['install_time']}, {arguments['version']},"
              f"{arguments['architecture']}, {arguments['multiarch']}, {arguments['source']}, "
              f"{arguments['description']}, {arguments['location']}, {arguments['triaged']}, {arguments['checksum']},"
              f"{arguments['item_id']})")


def insert_vulnerability(cveid=DEFAULT_VULNERABILITY_ID, target='RHEL7', target_minor='',
                         package=DEFAULT_PACKAGE_NAME, operation='less than', operation_value='2.0.0-1.el7',
                         title='', severity='critical',
                         published=datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ"),
                         updated='', reference='https://github.com/wazuh/wazuh-qa', target_v='REDHAT', cvss='10.000000',
                         cvss_vector="AV:N/AC:L/Au:N/C:C/I:C/A:C", rationale='Wazuh integration test vulnerability',
                         cvss3='', bugzilla_reference='https://github.com/wazuh/wazuh-qa', cwe='WVE-000 -> WVE-001',
                         advisory='RHSA-2010:0029', ref_target='RHEL'):
    """Insert a new vulnerability in the database of vulnerabilities, with the parameters given as arguments.

    If used in conjunction with ``insert_package_in_db`` using the default arguments it will generate an alert.

    Args:
        cveid (str): id of the vulnerability
        target (str): id of the target OS. Defaults to RHEL7
        target_minor (str): minor version of the target OS
        package (str): name of the package. Defaults to wazuhintegrationpackage
        operation (str): operation to compare the version of the packages
        operation_value (str): value used to compare the packages
        title (str): title of the vulnerability
        severity (str): severity of the vulnerability
        published (str): date when the vulnerability was published
        updated (str): string containing if the package was updated
        reference (str): URL referencing the vulnerability
        target_v (str): target of the family OS. Defaults to REDHAT
        cvss (str): common vulnerability scoring system
        cvss_vector (str): a compressed textual representation of the values used to derive the score
        rationale (str): set of reasons to descrive de vulnerability
        cvss3 (str): common vulnerability scoring system version 3
        bugzilla_reference (str): URL referencing to bugzilla
        cwe (str): CWE id
        advisory (str): advisory ID
        ref_target (str): id of the target OS. Defaults to RHEL
    """

    vulnerabilities_query_string = f'''INSERT INTO VULNERABILITIES
        (cveid, target, target_minor, package, operation, operation_value)
        VALUES
        ("{cveid}", "{target}", "{target_minor}", "{package}", "{operation}",
        "{operation_value}")'''
    query_vulnerabilities_info_query_string = f'''INSERT INTO VULNERABILITIES_INFO
        (ID, title, severity, published, updated, target, rationale, cvss, cvss_vector, CVSS3, cwe)
        VALUES
        ("{cveid}", "{title}", "{severity}", "{published}", "{updated}", "{target_v}",
        "{rationale}", "{cvss}", "{cvss_vector}", "{cvss3}", "{cwe}")
        '''
    query_references_info = f'''INSERT INTO REFERENCES_INFO
        (id, target, reference)
        VALUES
        ("{cveid}", "{ref_target}", "{reference}")
        '''
    query_bugzilla_info = f'''INSERT INTO BUGZILLA_REFERENCES_INFO
        (id, target, bugzilla_reference)
        VALUES
        ("{cveid}", "{ref_target}", "{bugzilla_reference}")
        '''
    query_advisories_info = f'''INSERT INTO ADVISORIES_INFO
        (id, target, advisory)
        VALUES
        ("{cveid}", "{ref_target}", "{advisory}")
        '''

    make_query(CVE_DB_PATH, [vulnerabilities_query_string, query_vulnerabilities_info_query_string,
                             query_references_info, query_bugzilla_info, query_advisories_info])


def update_sync_info(agent="000", component="syscollector-packages", last_attempt=1, last_completion=1,
                     n_attempts=0, n_completions=0, last_agent_checksum=''):
    """Update the sync_info table of the specified agent for the selected component."""
    query_wdb(f"agent {agent} sql UPDATE sync_info SET last_attempt = {last_attempt},"
              f"last_completion = {last_completion}, n_attempts = {n_attempts}, n_completions = {n_completions},"
              f"last_agent_checksum = '{last_agent_checksum}' where component = '{component}'")


def update_package(version, package, agent="000"):
    """Update version of installed package in database.

    Used to simulate upgrades and downgrades of the package given as argument.

    Args:
        version (str): version of the package
        package (str): package name
        agent (str): id of the agent
    """
    update_query_string = f'agent {agent} sql UPDATE sys_programs SET version="{version}" WHERE name="{package}"'
    query_wdb(update_query_string)


def delete_package(package, agent='000'):
    """Remove package from database.

    Used to simulate uninstall of the package given as argument or remove a package after a test.

    Args:
        package (str): package name
        agent (str): id of the agent
    """
    delete_query_string = f'agent {agent} sql DELETE FROM sys_programs WHERE name="{package}"'
    query_wdb(delete_query_string)


def delete_vulnerability(cveid):
    """Update version of installed package in database.

    Used to simulate uninstall of the package given as argument or remove a package after a test.

    Args:
        cveid (str): id of the vulnerability
    """
    delete_vulnerabilities_query_string = f"DELETE FROM VULNERABILITIES WHERE cveid='{cveid}'"
    delete_vulnerabilities_info_query_string = f"DELETE FROM VULNERABILITIES_INFO WHERE id='{cveid}'"
    delete_references_info_query_string = f"DELETE FROM REFERENCES_INFO WHERE id='{cveid}'"
    delete_bugzilla_info_query_string = f"DELETE FROM BUGZILLA_REFERENCES_INFO WHERE id='{cveid}'"
    delete_advisories_info_query_string = f"DELETE FROM ADVISORIES_INFO WHERE id='{cveid}'"
    make_query(CVE_DB_PATH, [delete_vulnerabilities_query_string, delete_vulnerabilities_info_query_string,
                             delete_references_info_query_string, delete_bugzilla_info_query_string,
                             delete_advisories_info_query_string])


def clean_vulnerabilities_inventory(agent="000"):
    """Clean the vulnerabilities inventory from database.

    Args:
        agent (str): id of the agent
    """
    clean_query_string = f"agent {agent} sql DELETE from vuln_cves"
    query_wdb(clean_query_string)


def modify_system(os_name='CentOS Linux', os_major='7', name='centos7', agent_id='000', os_minor='1', os_arch='x86_64',
                  os_version='7.1', os_platform='centos', version='4.0'):
    """Modify the system of the manager.

    Used to select the feed that will be used to search vulnerabilities.

    Args:
        os_name (str): complete name of the OS
        os_major (str): major version of the OS
        name (str): name of the OS
        agent_id (int): id of the agent
        os_minor (str): minor version of the OS
        os_arch (str): architecture of the host
        os_version (str): version of the OS
        os_platform (str): platform of the os (centos, ubuntu)
        version (str): version of the OS
    """

    query_string = f"global sql update AGENT set OS_NAME='{os_name}', OS_VERSION='{os_version}', OS_MAJOR='{os_major}', "\
                   f"OS_MINOR='{os_minor}', OS_ARCH='{os_arch}', NAME='{name}', OS_PLATFORM='{os_platform}', "\
                   f"VERSION='{version}' WHERE id='{int(agent_id)}'"
    query_wdb(query_string)


def get_num_vulnerabilities():
    """Get the number of vulnerabilities inserted in VULNERABILITIES table of CVE DB.

    Returns:
        int: total number of vulnerabilities in the VULNERABILITIES table
    """
    query_string = f'SELECT count(*) from VULNERABILITIES'
    query_result = get_query_result(CVE_DB_PATH, query_string)
    vulnerabilities_number = int(query_result[0])

    return vulnerabilities_number


def clean_vuln_and_sys_programs_tables(agent='000'):
    """Clean vulnerability detector and sys programs table/s

    Args:
        agent (str): id of the agent
    """
    clean_vd_tables(agent)


def insert_custom_package(**kwargs):
    """Insert a custom package in sys_programs table

    Args:
        kwargs (dict): Required arguments of the ``insert_package`` function (see its argument list)
    """
    insert_package(**kwargs)


def set_custom_system(**kwargs):
    """It allows to modify the agent system, modifying the corresponding entry in the agent table of the global.d

    Args:
        kwargs (dict): Required arguments of the ``modify_system`` function (see its argument list)
    """
    modify_system(**kwargs)


def check_vuln_detector_event(wazuh_log_monitor, callback, error_message='', update_position=True,
                              timeout=VULN_DETECTOR_EXTENDED_GLOBAL_TIMEOUT, prefix=VULNERABILITY_DETECTOR_PREFIX):
    """Check if a vulnerability event occurs

    Args:
        wazuh_log_monitor (FileMonitor): FileMonitor object to monitor the Wazuh log
        callback (str): log regex to check in Wazuh log
        error_message (str): error message to show in case of expected event does not occur
        update_position (boolean): filter configuration parameter to search in Wazuh log
        timeout (str): timeout to check the event in Wazuh log
        prefix (str): log pattern regex
    """
    wazuh_log_monitor.start(
        timeout=timeout,
        update_position=update_position,
        callback=make_vuln_callback(callback, prefix),
        error_message=error_message
    )


def check_vulnerabilities_number(expected_number):
    """Check if the number of vulnerabilities inserted in VULNERABILITIES table of CVE DB is the expected.

    Args:
        expected_number (int): number of expected vulnerabilities
    """
    vulnerabilities_number = get_num_vulnerabilities()
    assert vulnerabilities_number == expected_number, f"Number of inserted vulnerabilities is not the expected." \
                                                      f" Expected: {expected_number}, Got: {vulnerabilities_number}"


def check_log_event(wazuh_log_monitor, log_event, update_position=False, timeout=VULN_DETECTOR_EXTENDED_GLOBAL_TIMEOUT,
                    prefix=VULNERABILITY_DETECTOR_PREFIX):
    """Check if the vulnerable package has been reported

    Parameters
    ----------
    wazuh_log_monitor: FileMonitor
        FileMonitor object to monitor the Wazuh log
    log_event: str
        Log event to find in ossec.log
    update_position : boolean
        Filter configuration parameter to search in Wazuh log
    timeout: str
        Timeout to check the event in Wazuh log
    prefix: str
        Log pattern regex
    """
    check_vuln_detector_event(
        wazuh_log_monitor=wazuh_log_monitor, update_position=update_position, timeout=timeout, callback=log_event,
        error_message=f"Could not find the log event: {log_event}", prefix=prefix
    )


def check_feed_imported_successfully(wazuh_log_monitor, log_system_name, expected_vulnerabilities_number,
                                     update_position=False, timeout=VULN_DETECTOR_EXTENDED_GLOBAL_TIMEOUT,
                                     check_vuln_number=True):
    """Check that redhat OVAL feeds have been imported successfully

    Args:
        wazuh_log_monitor (FileMonitor): FileMonitor object to monitor the Wazuh log
        log_system_name (str): system name in ossec.log. For instance 'Red Hat Enterprise Linux'
        expected_vulnerabilities_number (int): number of expected vulnerabilities imported in the BD
        update_position (boolean): filter configuration parameter to search in Wazuh log
        timeout (str): timeout to check the event in Wazuh log
        check_vuln_number (bool): boolean to enable the check that compares the number of generated alerts with
            the number of expected alerts
    """
    check_vuln_detector_event(
        wazuh_log_monitor=wazuh_log_monitor, update_position=update_position, timeout=timeout,
        callback=rf"INFO: \(\d+\): The update of the '{log_system_name}' feed finished successfully.",
        error_message=f"Could not find the message: '{log_system_name}' feed finished successfully"
    )
    if check_vuln_number:
        check_vulnerabilities_number(expected_number=expected_vulnerabilities_number)


def check_failure_when_importing_feed(wazuh_log_monitor, expected_vulnerabilities_number=0, update_position=False,
                                      timeout=VULN_DETECTOR_EXTENDED_GLOBAL_TIMEOUT, parser_error=False):
    """Check an error message when importing redhat OVAL feeds and checks that the vulnerabilities table is empty

    Args:
        wazuh_log_monitor (FileMonitor): FileMonitor object to monitor the Wazuh log
        expected_vulnerabilities_number (int): number of expected vulnerabilities imported in the BD
        update_position (bool): filter configuration parameter to search in Wazuh log
        timeout (str): timeout to check the event in Wazuh log
        parser_error (bool): check if there is a parser error message
    """
    if parser_error:
        check_log_event(
            wazuh_log_monitor=wazuh_log_monitor, update_position=update_position, timeout=timeout,
            log_event=r"ERROR: \(\d+\): The .* feed couldn't be parsed from .* file"
        )

    check_log_event(
        wazuh_log_monitor=wazuh_log_monitor, update_position=update_position, timeout=timeout,
        log_event=r"ERROR: \(\d+\): CVE database could not be updated."
    )

    check_vulnerabilities_number(expected_number=expected_vulnerabilities_number)


def check_detected_vulnerabilities_number(wazuh_log_monitor, expected_vulnerabilities_number, feed_source, agent=None,
                                          update_position=False, timeout=VULN_DETECTOR_GLOBAL_TIMEOUT):
    """Check the number of vulnerabilities found by the feed source

    Args:
        wazuh_log_monitor (FileMonitor): FileMonitor object to monitor the Wazuh log
        expected_vulnerabilities_number (int): number of expected vulnerabilities
        feed_source (str): OVAL or NVD
        agent (str, optional): Agent id
        update_position (bool): filter configuration parameter to search in Wazuh log
        timeout (str): timeout to check the event in Wazuh log
    """
    callback = f"The {feed_source} found a total of '{expected_vulnerabilities_number}' " \
               "potential vulnerabilities for agent .* "
    if agent is not None:
        callback = f"The {feed_source} found a total of '{expected_vulnerabilities_number}' " \
                   f"potential vulnerabilities for agent '{agent}' "
    check_vuln_detector_event(
        wazuh_log_monitor=wazuh_log_monitor, update_position=update_position, timeout=timeout,
        callback=callback,
        error_message=f"The expected number of {feed_source} vulnerabilities have not been found"
    )


def set_system(system):
    """Set custom system in global DB Agent info

    Args
        system (str): system to set. Available systems in SYSTEM_DATA variable
    """
    try:
        set_custom_system(os_name=SYSTEM_DATA[system]['os_name'], os_major=SYSTEM_DATA[system]['os_major'],
                          os_minor=SYSTEM_DATA[system]['os_minor'], name=SYSTEM_DATA[system]['name'])
    except KeyError:
        pass


def insert_data_json_feed(data, field_name, field_value, append_data, brackets=True):
    """Allow insert key:value pair as string, since otherwise, you could not insert lists or dictionaries as a key

    Args:
        data (dict): data dictionary
        field_name (str): field name to insert
        field_value (str): field value to insert
        append_data (dict): additional data to insert
        brackets (bool): insert data between brackets

    Returns:
        str: JSON string
    """
    if type(field_name) is str:
        data[field_name] = field_value
        raw_data = json.dumps(data, indent=4, ensure_ascii=False)
    else:
        data['replace_me'] = field_value  # This is necessary to make a non-string field
        raw_data = json.dumps(data, indent=4, ensure_ascii=False).replace('"replace_me"', f"{field_name}")

    if append_data:
        response = f"\n{raw_data},\n{json.dumps(append_data, indent=4, ensure_ascii=False)}\n"
        return f"[{response}]" if brackets else response
    else:
        return f"[\n{raw_data}]" if brackets else f"\n{raw_data}"


def check_if_modulesd_is_running():
    """Check if modulesd daemon is running"""
    assert check_if_process_is_running('wazuh-modulesd'), 'wazuh-modulesd is not running!'


def check_feed_uncompressed_successfully(wazuh_log_monitor, feed, update_position=False,
                                         timeout=VULN_DETECTOR_EXTENDED_GLOBAL_TIMEOUT):
    """Check that a feed from path or url have been uncompressed successfully

    Args:
        wazuh_log_monitor (FileMonitor): FileMonitor object to monitor the Wazuh log
        feed (str): path or url where the feed is
        update_position (boolean): filter configuration parameter to search in Wazuh log
        timeout (str): timeout to check the event in Wazuh log
    """
    if feed[-1] == '$':
        feed = feed[:-1]
    prefix = r'.*wazuh-modulesd.*'
    check_vuln_detector_event(
        wazuh_log_monitor=wazuh_log_monitor, update_position=update_position, timeout=timeout,
        callback=rf"(The file|File from URL) '{feed}' was successfully uncompressed into .*",
        error_message=f"Could not find the message: '{feed}' was successfully uncompressed",
        prefix=prefix
    )


def modify_metadata_vuldet_feed(feed, timestamp):
    """Function to modify the timestamp value of the metadata table for a specific feed.

    Args:
        feed (str): The feed name.
        timestamp (str): The new timestamp value to set.
    """
    query_string = f"update METADATA set TIMESTAMP='{timestamp}' where TARGET='{feed}'"
    make_query(CVE_DB_PATH, [query_string])
    sleep(1)


def modify_nvd_metadata_vuldet(timestamp):
    """Function to modify the timestamp value of the nvd_metadata table.

    Args:
        timestamp (int): The new timestamp value to set.

    Raises:
        sqlite3.OperationalError: If the modification has not been possible.
    """
    query_string = f"UPDATE NVD_METADATA SET LAST_UPDATE={timestamp};"
    for _ in range(VULN_DETECTOR_GLOBAL_TIMEOUT):
        try:
            make_query(CVE_DB_PATH, [query_string])
            break
        except sqlite3.OperationalError:
            sleep(1)
    else:
        raise sqlite3.OperationalError


def check_vulnerability_scan_log(wazuh_log_monitor, package, cve):
    """Check if inserted vulnerable packages are reported by vulnerability detector.

    Args:
        wazuh_log_monitor (FileMonitor): FileMonitor object to monitor the Wazuh log
        package (str): Name of custom package to check. Example: 'firefox-0'
        cve (str): Package CVE. Example: 'CVE-2019-11764'
    """
    check_vuln_detector_event(
        wazuh_log_monitor=wazuh_log_monitor, timeout=VULN_DETECTOR_EXTENDED_GLOBAL_TIMEOUT, update_position=False,
        callback=f"The '{package}' package .* from agent .* is vulnerable to '{cve}'",
        error_message=f"Could not find the report which says that the package {package} is vulnerable with {cve}",
    )


def check_vulnerability_scan_discarded(wazuh_log_monitor, package):
    """Check if kernel packages are discarded by vulnerability detector.

    Args:
        wazuh_log_monitor (FileMonitor): FileMonitor object to monitor the Wazuh log
        package (str): Name of custom kernel package to check. Example: 'linux-image-aws'
    """
    check_vuln_detector_event(
        wazuh_log_monitor=wazuh_log_monitor, timeout=VULN_DETECTOR_SCAN_TIMEOUT, update_position=False,
        callback=f"Discarded Linux Kernel package '{package}' .*",
        error_message=f"Could not find the report which says that the package {package} was discarded",
        prefix='.*'
    )


def check_vulnerability_scan_alert(wazuh_alert_monitor, package, cve):
    """Check if inserted vulnerable packages are reported by vulnerability detector.
    Args:
        wazuh_alert_monitor (FileMonitor): FileMonitor object to monitor the Wazuh alerts log
        package (str): Name of custom package to check. Example: 'firefox-0'
        cve (str): Package CVE. Example: 'CVE-2019-11764'
    """
    check_vuln_detector_event(
        wazuh_log_monitor=wazuh_alert_monitor, timeout=VULN_DETECTOR_SCAN_TIMEOUT, update_position=False,
        callback=f"{cve} affects {package}",
        error_message=f"Could not find the report which says that {cve} affects the package {package}",
        prefix='.*'
    )


def check_vulnerability_scan_remove_log(wazuh_log_monitor, package, cve):
    """Check if removed vulnerable packages are reported by vulnerability detector in yhe logs.
    Args:
        wazuh_log_monitor (FileMonitor): FileMonitor object to monitor the Wazuh log
        package (str): Name of custom package to check. Example: 'firefox-0'
        cve (str): Package CVE. Example: 'CVE-2019-11764'
    """
    check_vuln_detector_event(
        wazuh_log_monitor=wazuh_log_monitor, timeout=VULN_DETECTOR_SCAN_TIMEOUT, update_position=False,
        callback=f"The vulnerability '{cve}' affecting '{package}' was eliminated",
        error_message=f"Could not find the log which says that the package {package} is no longer vulnerable with {cve}"
    )


def check_vulnerability_scan_remove_alerts(wazuh_alerts_monitor, package, cve):
    """Check if removed vulnerable packages are reported by vulnerability detector in the alerts.
    Args:
        wazuh_alerts_monitor (FileMonitor): FileMonitor object to monitor the Wazuh alerts log
        package (str): Name of custom package to check. Example: 'firefox-0'
        cve (str): Package CVE. Example: 'CVE-2019-11764'
    """
    check_vuln_detector_event(
        wazuh_log_monitor=wazuh_alerts_monitor, timeout=VULN_DETECTOR_SCAN_TIMEOUT, update_position=False,
        callback=f"The {cve} that affected {package} was eliminated due to a package removal/update or a system upgrade",
        prefix='.*',
        error_message=f"Could not find the alert which says that the package {package} is no longer vulnerable with {cve}"
    )


def restart_modulesd():
    """Restart modulesd daemon"""
    control_service('restart', daemon='wazuh-modulesd')
    sleep(1)


def add_client_keys_entry(agent_id, agent_name, agent_ip='any', agent_key=None):
    """Add new entry to client keys file. If the agent_id already exists, this will be overwritten.

    Args:
        agent_id (str): Agent identifier.
        agent_name (str): Agent name.
        agent_ip (str): Agent ip.
        agent_key (str): Agent key.
    """
    registered_client_key_entries_dict = {}

    # Generate new key if necessary
    if agent_key is None:
        agent_key = ''.join(random.choice('0123456789abcdef') for i in range(64))

    # Read client keys data
    with open(CLIENT_KEYS_PATH, 'r') as client_keys:
        registered_client_key_entries_str = client_keys.readlines()

    # Process current client key entries
    for client_key_entry in registered_client_key_entries_str:
        _agent_id, _agent_name, _agent_ip, _agent_key = client_key_entry.split()
        registered_client_key_entries_dict[_agent_id] = f"{_agent_id} {_agent_name} {_agent_ip} {_agent_key}"

    # Add the new client key entry
    registered_client_key_entries_dict[agent_id] = f"{agent_id} {agent_name} {agent_ip} {agent_key}"

    # Save new client keys content
    with open(CLIENT_KEYS_PATH, 'w') as client_keys:
        for _, client_key_entry in registered_client_key_entries_dict.items():
            client_keys.write(f"{client_key_entry}\n")


def delete_client_keys_entry(agent_id):
    """Delete an entry from client keys file.

    Args:
        agent_id (str): Agent identifier.
    """
    registered_client_key_entries_dict = {}

    # Read client keys data
    with open(CLIENT_KEYS_PATH, 'r') as client_keys:
        registered_client_key_entries_str = client_keys.readlines()

    # Process current client key entries
    for client_key_entry in registered_client_key_entries_str:
        _agent_id, _agent_name, _agent_ip, _agent_key = client_key_entry.split()
        registered_client_key_entries_dict[_agent_id] = f"{_agent_id} {_agent_name} {_agent_ip} {_agent_key}"

    # Remove client key entry
    registered_client_key_entries_dict.pop(agent_id, None)

    # Save new client keys content
    with open(CLIENT_KEYS_PATH, 'w') as client_keys:
        for _, client_key_entry in registered_client_key_entries_dict.items():
            client_keys.write(f"{client_key_entry}\n")


def create_mocked_agent(name='centos8-agent', ip='127.0.0.1', register_ip='127.0.0.1', internal_key='',
                        os_name='CentOS Linux', os_version='7.1', os_major='7', os_minor='1', os_codename='centos-8',
                        os_build='4.18.0-147.8.1.el8_1.x86_64', os_platform='#1 SMP Thu Apr 9 13:49:54 UTC 2020',
                        os_uname='x86_64', os_arch='x86_64', version='4.2', config_sum='', merged_sum='',
                        manager_host='centos-8', node_name='node01', date_add='1612942494',
                        last_keepalive='253402300799', group='', sync_status='synced', connection_status='active',
                        client_key_secret=None):
    """Mock a new agent creating a new client keys entry, adding it to the global db and creating a new agent id DB."""
    # Get new agent_id
    last_id = query_wdb('global sql SELECT id FROM agent order by id desc limit 1')
    agent_id = int(last_id[0]['id']) + 1

    query_create_agent = f'''global sql INSERT OR REPLACE INTO AGENT
           (id, name, ip, register_ip, internal_key, os_name, os_version, os_major, os_minor,
            os_codename, os_build, os_platform, os_uname, os_arch, version, config_sum, merged_sum,
            manager_host, node_name, date_add, last_keepalive, "group", sync_status, connection_status)
           VALUES
           ( "{agent_id}", "{name}", "{ip}", "{register_ip}", "{internal_key}", "{os_name}", "{os_version}",
             "{os_major}", "{os_minor}", "{os_codename}", "{os_build}", "{os_platform}", "{os_uname}",
             "{os_arch}", "{version}", "{config_sum}", "{merged_sum}", "{manager_host}", "{node_name}",
             "{date_add}", "{last_keepalive}", "{group}", "{sync_status}", "{connection_status}")
           '''

    agent_id_str = str(agent_id).zfill(3)  # Convert from x to 00x

    add_client_keys_entry(agent_id_str, name, ip, client_key_secret)

    # A dummy sql query creates a new DB
    query_wdb(f'''agent {agent_id} sql DELETE FROM sys_osinfo''')
    query_wdb(query_create_agent)

    # Restarting Wazuh-DB before creating new DB
    control_service('restart', daemon='wazuh-db')
    # sleep is needed since, without it, the agent database creation may fail
    sleep(3)

    return agent_id_str


@retry(AttributeError, attempts=2, delay=2, delay_multiplier=1)
def create_simulated_agent(manager_address="localhost", operating_system="debian10"):
    """Create a new agent using the Agent class of agent_simulator module with a minimal functionality.

    Args:
        manager_address (str, optional): Manager address. Defaults to "localhost".
        operating_system (str, optional): Operating system of the simulated agent. Defaults to "Debian 10".

    Returns:
        (str, Sender, Injector): A tuple with the id, the Sender and the Injector of the simulated agent.
    """
    agent = ag.Agent(manager_address=manager_address, os=operating_system)
    agent.set_module_status('syscollector', 'enabled')
    agent.set_module_status('fim', 'disabled')
    sender, injector = ag.connect(agent)
    return agent.id, sender, injector


def modify_agent_scan_timestamp(agent="000", timestamp=0, full_scan=True):
    """Function to modify the timestamp of the agent scans in the vuln_metadata table.

    Args:
        agent (str, optional) = Id of the agent. Defaults to "000".
        timestamp (int, optional): The new timestamp value to set. Defaults to 0.
        full_scan (bool, optional): True for set LAST_FULL_SCAN or False to set LAST_SCAN. Defaults to True.
    """
    scan_type = "LAST_FULL_SCAN" if full_scan else "LAST_PARTIAL_SCAN"
    query_wdb(f"agent {agent} sql UPDATE vuln_metadata SET {scan_type}={timestamp}")


def delete_mocked_agent(agent_id):
    """Delete a mocked agent removing it from the global db, client keys and db file."""
    # Remove from global db
    query_wdb(f"global sql DELETE FROM agent where id={int(agent_id)}")

    # Remove agent id DB file
    os.remove(os.path.join(DB_PATH, f"{agent_id}.db"))

    # Remove entry from client keys
    delete_client_keys_entry(agent_id)


def delete_simulated_agent(agent_id):
    """Delete a simulated agent removing it from the global db, client keys and db file."""
    # Remove from global db
    query_wdb(f"global delete-agent {agent_id}")

    # Remove agent id DB file
    os.remove(os.path.join(DB_PATH, f"{agent_id}.db"))

    # Remove entry from client keys
    delete_client_keys_entry(agent_id)

def check_vulnerability_scan_inventory(agent, package, version, arch, cve, condition, severity='-', cvss2=0, cvss3=0):
    """Checks the existence or lack of a vulnerability in the agent's DB

    Args:
        agent (str) = Id of the agent.
        package (str) = Vulnerable package to look for.
        version (str) = Version of the vulnerable package to look for.
        arch (str) = Architecture of the vulnerable package to look for.
        cve (str) = Vulnerability ID associated to the vulnerable package to look for.
        condition (str) = This parameter is used to check if the vulnerability exists ('inserted') or
                          not ('removed') in the inventory
        severity (str,optional) = Severity of the vulnerable package to look for.
        cvss2 (str,optional) = CVSS2 score of the vulnerable package to look for.
        cvss3 (str,optional) = CVSS3 score of the vulnerable package to look for.
    """

    if condition == 'inserted':
        query = f"""agent {agent} sql SELECT CASE WHEN EXISTS
            (select 1 FROM vuln_cves WHERE cve = '{cve}' AND name = '{package}' AND version = '{version}' AND architecture = '{arch}'
            AND severity = '{severity}' AND cvss2_score = {cvss2} AND cvss3_score = {cvss3})
            THEN 'true' ELSE 'false' END as 'result'"""
    elif condition == 'removed':
        query = f"""agent {agent} sql SELECT CASE WHEN NOT EXISTS
            (select 1 FROM vuln_cves WHERE cve = '{cve}' AND name = '{package}' AND version = '{version}' AND architecture = '{arch}')
            THEN 'true' ELSE 'false' END as 'result'"""
    else:
        raise Exception(f'The "condition" parameter has an unexpected value: {condition}')

    wdb_result = query_wdb(query)
    if wdb_result[0]['result'] == 'false':
        raise Exception(f'The vulnerability {cve} has not been {condition} as expected')


def find_cve_severity_score (cve_array, cve_id):
    """It looks for the cve_id in cve_array and returns its severity and score

    Args:
        cve_array (str) = The CVE's data read from the NVD feed.
        cve_id (str) = The CVE ID to find and return its severity and score.
    """
    severity = '-'
    cvss2_score = 0
    cvss3_score = 0

    for cve in cve_array:
        if cve['cve']['CVE_data_meta']['ID'] == cve_id:
            # The CVSS3 has priority over CVSS2
            if 'baseMetricV2' in cve['impact']:
                cvss2_score = cve['impact']['baseMetricV2']['cvssV2']['baseScore']
                severity = calculate_severity_from_score(cvss2_score, 'cvss2')

            if 'baseMetricV3' in cve['impact']:
                cvss3_score = cve['impact']['baseMetricV3']['cvssV3']['baseScore']
                severity = calculate_severity_from_score(cvss3_score, 'cvss3')
            break

    return severity, cvss2_score, cvss3_score


def calculate_severity_from_score(base_score, cvss):
    """It obtains the corresponding severity according to a CVSS2 or CVSS3 score

    Args:
        base_score (real) = The base score to get its severity.
        cvss (str) = A string to indicate the CVSS scale to use ('cvss2/cvss3').
    """
    severity = '-'

    if cvss == 'cvss2':
        if base_score >= 7:
            severity = 'High'
        elif base_score >= 4:
            severity = 'Medium'
        else:
            severity = 'Low'

    elif cvss == 'cvss3':
        if base_score >= 9:
            severity = 'Critical'
        elif base_score >= 7:
            severity = 'High'
        elif base_score >= 4:
            severity = 'Medium'
        elif base_score >= 0.1:
            severity = 'Low'
        else:
            severity = '-'

    return severity
